---
title: c++ review
date: 2022-09-06 19:04:24
tags:
typora-root-url: c-review
---

# Accelerated c++

### 使用字符串

1. `>>`运算符从标准输入读进一个字符串，它会首先略去输入开始碰到的空白字符（空白、制表符、回退键和换行符），然后连续的读入字符到某个变量中，直到遇到了另一个空白字符或文件结束标记为止

2. c++的数据结构可以用struct实现

   ```c++
   struct studentInfo{
     string name;
     double midterm;
     vector<double> homework;
   };
   ```

3. 随机访问：s[2],s[5],这样随机的数字进行访问就是随机访问，顺序访问就是从第一个元素开始，按照既定顺序一个一个遍历到结尾

4. 半开[i,j)区间的元素个数是j-i，[i,j]闭区间的元素个数是j-i+1

<!--more-->

1. 反向迭代器

   ```c++
   #include <iostream>
   #include<vector>
   using namespace std;
   int main()
   {
       vector<char> v{'j','a','v','a'};
       vector<char>::reverse_iterator rtr;
       for(rtr=v.rbegin();rtr!=v.rend();rtr++)
           std::cout<< *rtr;
       return 0;
   }
   ```

   **输出：**

   ```
   avaj
   ```

2. 如果我们在类的内部定义了一个成员函数，就是请求把对这个函数的调用扩展成内联子过程，这样就避免了函数调用额外的开销。如果成员函数是在类的外部定义的，那么我们必须在这个函数的函数名中指明他是来自类作用域的：`"class-name::membername"`

3. 如果在第一个保护标识符之前有成员，class中的成员是私有的（private），struct中的成员是共有的（public）

# C++ Primer

>Part1也就是前七章，除了6.6，6.7节，都要通读。尤其是第三章初步介绍了vector和string，简直就是新手福音，搞定这两个容器就能写一些简单的程序。
>Part2基本就是数据结构和算法，如果有基础读起来很轻松。
>9，11两章介绍的容器，以及12.1节的智能指针要通读。多用智能指针和容器，远离segment fault. 第10章里的泛型算法可以慢慢读，读完以后可以写出高逼格的函数式风格C++。12.2节讲了怎么用new和delete分配空间，题主作为新手，知道这种写法就行，写程序时尽量用容器代替原始数组，尤其是代码里最好不要有delete。
>Part3是块硬骨头，标题就是Tools for Class Authors. 作为一个"class user"，有些部分第一次是可以略过的。
>13章很重要，要细读。初始化，复制，赋值，右值引用是C++里很微妙很重要的部分，别的语言对于这些概念很少有区分得这么细的。这一章不但要精读，还要完全掌握。
>14章的操作符重载第一次可以观其大略；14.9节第一次可以跳过。
>15章讲OOP，重要性不言而喻。如果之前一点概念都没有，学起来会觉得比较抽象。网上关于OOP有很多通俗有趣的文章，可以一起看看。
>16章讲泛型编程，第一次读16.1节，掌握最基本的函数模板和类模板就行了。
>Part4就更高档了，很多内容第一次就算啃下来，长久不用又忘了。第一次读推荐把18.2节读懂，命名空间简单易用效果好。别的内容可以观其大略，用时再看。17.1节的tuple是个有趣的东东，可以读一读。17.3节的正则表达式和17.4节的随机数也许有用，也可以读一读。如果需要读写文件，要读一下17.5.2节的raw I/O和17.5.3节的random I/O。
>
>最后给题主的建议是，写C++，要尽量避免C的写法。用static_cast而不是括号转换符；用vector而不是C里面的数组；用string而不是char *；用智能指针而不是原始指针。当然I/O是个例外，printf()还是比cout好用的；转换数字和字符串时sprintf()也比stringstream快

1. 如果想声明一个变量而非定义它，就在变量名前加关键字extern，定义与声明的区别：定义申请存储空间，也可能会为变量赋一个初始值

2. 头文件不应该包含using声明

3. **顶层const**表示指针本身是个常量，**底层const**表示指针所指对象是个常量

4. 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内

5. 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值

6. 将只有一个参数的构造函数声明为explicit可以抑制构造函数定义的隐式转换，只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

7. 要想确保对象只定义一次，最好的办法是把静态数据成员的定义和其他非内联函数的定义放在同一个文件中

8. lambda表达式

   ![image-20220715200844207](image-20220715200844207.png)

9. 11.4节的hasher函数`hash<string>()(sd.isbn());`hash<string>()生成了可调用对象,然后该可调用对象(可以看作是函数)作用在sd.isbn()上

10. 返回const和非const的函数重载，是因为调用函数时隐式的传递了this指针

11. ![image-20220716144342905](image-20220716144342905.png)

12. 用new分配数组时值初始化和默认初始化,默认情况下动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化.也可以对动态分配的对象进行值初始化,只需在类型名之后跟一对空括号即可

13. 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数

14. 一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符.一旦一个类需要一个拷贝构造函数,它一定也需要一个拷贝复制运算符,但不一定需要析构函数

15. 拷贝赋值运算符应该返回一个指向其左侧运算对象的引用,即在赋值函数中`return *this`

16. 通常情况下，不应该重载逗号、取地址、逻辑与、和逻辑或运算符

17. 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做，这两类运算符都应该返回左侧运算对象的引用

18. 如果类定义了调用运算符，则该类的对象称作函数对象，因为可以调用这种对象，所以我们说这些对象的行为像函数一样

19. 赋值（包括复合赋值）、下标、函数调用和箭头运算符必须作为类的成员

20. 在c++中，当我们使用**基类的引用或指针**调用一个**虚函数**时将发生**动态绑定**（又称作运行时绑定）

21. 派生类构造函数只初始化它的直接基类

22. 派生列表中用到的访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见

23. explicit关键字：指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化

24. 必须使用初始化列表的时候：

    （1）常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    （2）引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面

    （3）没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

    下图解释了拷贝构造函数

    ![image-20220907104527530](image-20220907104527530.png)

25. 构造函数的调用：

    ![image-20220907115924242](image-20220907115924242.png)

    26. 一个左值是一个标识非临时性对象的表达式。一个右值是一个标识临时性对象的表达式，或者一个不与任何对象相联系的值（如字面值常数），一般的法则是，如果程序中有一个变量名，那么他就是一个左值。在所有情况下函数调用的结果都是右值。
    
    27. 
    
    28. 当一个类包含指针作为数据成员时，一般我们必须自己实现析构函数，拷贝赋值函数和拷贝构造函数
    
        ![image-20220907150933740](image-20220907150933740.png)
