---
title: 算法与数据结构（左程云）
date: 2022-09-19 19:55:24
tags:
- 数据结构与算法
- LeetCode
categories:
- 个人技术栈
typora-root-url: 算法与数据结构（左程云）
---

# 1. 复杂度、二分法、与异或运算 

## 1.1 二分法

只要能构建出排他性的逻辑就可以用二分，比如说我虽然不知道左边可不可以，但我知道右边一定不可以，那么就可以二分。

## 1.2 异或运算

### 1.2.1 异或运算就是**无进位的加法运算**。

### 1.2.2 异或运算的应用

**（1）**怎么把一个数字（int）最右侧的1提取出来？（注意是最右侧的1）

答案为：`N&((~N)+1)`，N取反首先会让最右侧1（记为1r）的右边的0变为1，让1r左边的1变0，0变1，然后加一会使1r右边的1依次进位变成0，直到进位到1r为止，此时1r变为1，最后与运算，因为1r左边取反了所以全为0，1r右边进位了全为0，得到结果

![image-20220919211646027](image-20220919211646027.png)

<!--more-->

# 2. 二叉树

## 2.1 先序、中序、后序遍历（非递归实现）

**先序**

（1）弹打印

（2）如有右，压入右

（3）如有左，压入左

**后序**

上面先序是中左右，那么改变压栈顺序为中右左，倒过来就是左右中。

（1）弹加入另外一个栈

（2）如有左，压入左

（3）如有右，压入右

（4）从另外那个栈弹出一个打印一个

**中序**

（1）整条左边界依次入栈

（2）条件（1）不成立时，弹出打印，来到弹出结点的右树上继续条件（1）

## 2.2 二叉树递归套路

（1）假设以x为头，假设可以问x左树和x右树要任何信息。

（2）在上一步的假设下，讨论以x为头节点的树，得到**答案的可能性**（最重要的一步，常见分类：这道题的答案跟x有关和跟x无关）。

（3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息。

（4）把左树信息和右树信息求全集，就是一棵子树都需要返回的信息S。

（5）递归函数都返回S，每一棵子树都这么要求。

（6）写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息。

## 2.3 堆和排序是解决贪心问题的常用技巧

# 3. 图

# 4. 暴力递归

暴力递归就是尝试

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件
3. 有当得到了**子问题结果**之后的**决策过程**
4. 不记录每一子问题的解

# 5. 动态规划

## 5.1 四种尝试模型

（1）从左往右尝试

（2）范围上尝试

（3）多样本位置全对应尝试

（4）寻找业务限制尝试

## 5.2 设计暴力递归过程的原则

（1）每一个可变参数类型，一定不要比int类型更加复杂

（2）原则（1）可以违反，让类型突破到一维线性结构，那必须是唯一可变参数

（3）如果发现原则（1）被违反，但不违反原则（2），只需要做到记忆化搜索即可

（4）可变参数的个数，能少则少

# 6. 滑动窗口

求窗口最大值
双端队列中的数据一定是严格从大到小的，双端队列维持的是在依次过期的情况下成为最大值的可能性，当有一个值cur需要从队尾加入队列时，如果比此时队尾的值大，将队尾值弹出，因为cur比队尾值大而且比队尾值晚过期，所以此时的队尾值不会再成为最大值了，直接弹出即可，重复此过程直到队列为空或队列末尾的值大于cur，将cur加入队尾。

# 7. 单调栈

找到左右两边离一个数最近的比他小（大）的那个数，下面的图是证明

![image-20220928162859802](image-20220928162859802.png)

# 8. Morris遍历

![image-20220928163102943](image-20220928163102943.png)

遍历的规律：有左子树的结点会经过两次，没有左子树的结点只会经过一次，下面是Morris遍历的代码

![image-20220928170702186](image-20220928170702186.png)

# 9. 有序表

## 9.1 有序表的时间复杂度

有序表的所有操作（增删改查）时间复杂度都是O(logN)。

## 9.2 实现有序表的数据结构

红黑树、AVL树、SizeBalanceTree（简称SB树）、SkipList（跳表）

## 9.3 导致平衡性失效的四种情况

（1）LL型：我的左孩子的左子树过长导致平衡性失效。头节点单次右旋就可以调整

（2）RR型：我的右孩子的右子树过长导致平衡性失效。头节点单次左旋就可以调整

（3）LR型：我的左孩子的右子树（左孩子的右子树的头节点记为X）过长导致平衡性失效。调整方法是让X节点作为头部

（4）RL型：我的右孩子的左子树（右孩子的左子树的头节点记为X）过长导致平衡性失效。调整方法是让X节点作为头部

# 10. 刷题技巧

## 10.1 预处理技巧

1. 生成前缀累加和数组作为预处理结构。

2. 某一个子数组可以累加生成的范围是1-range，对下一个数cur分情况讨论

   （1）cur>range+1,为了充分利用前面这个范围，需要补充range+1这个数，让范围扩大到

   1-（2*range+1）。

   （2）cur<=range+1，那么可以直接累加使范围变为1-range+cur。

## 10.2 根据数据量猜解法

根据输入参数范围看菜下饭，代码常数级别的操作在10的9次方以内。下面举一个例子，说明怎么根据数据范围选择不同的方法

---

**花最少钱通过所有怪兽**

int[] d，d[i]：i号怪兽的能力

int[] p，p[i]：i号怪兽要求的钱

开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。

如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。

返回通过所有的怪兽，需要花的最小钱数。

---

**分析**

如果你的能力大于等于怪兽的能力，有两种选择：

- 第一种：直接通过，也不花钱，能力也不增长
- 第二种：贿赂怪兽，花钱，能力提升

如果你的能力小于怪兽的能力，只能花钱贿赂怪兽，然后能力值提升

**方法一**：**暴力递归**，ability：当前你所具有的能力，index：当前来到第index个怪兽的面前，目前你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，请返回需要花的最少钱数。

**方法二**：**动态规划**，由暴力递归发现只有两个可变参数（ability，index），准备一张二维dp表，index号怪兽做行，ability能力做列，index的变化范围`0~N`，ability的变化范围`0~sum`，所有能力加起来为sum。

**方法三**：**动态规划**，如果能力范围变化很大，可能导致dp表过大，导致方法执行效率不高，重新定义dp，`dp[i][j]`含义：能经过0~i的怪兽，且花钱为j（花的钱严格等于j）时的武力值最大是多少？

分析可能性：

- 可能性一：为当前怪兽花钱
- 可能性二：不为当前怪兽花钱

**总结**：如果sum能力值变化范围不大，则方法二就可以，如果sum变化范围很大，则方法三是最优解，这道题属于**根据数据量猜解法**。

---

**实现**

暴力递归

```java
public static long func1(int[] d, int[] p) {
    return process(d, p, 0, 0);
}

// 当前你的能力是ability，来到index号怪兽面前，后续通过所有关需要花的最少的钱
public static long process(int[] d, int[] p, int ability, int index) {
    if (index == d.length) { // base case
        return 0;
    }
    // 当前的能力小于当前怪兽的能力，没得选，只能花钱贿赂，花了钱能力就增长
    if (ability < d[index]) { 
        return p[index] + process(d, p, ability + d[index], index + 1);
    } else { // 可以贿赂，也可以不贿赂，两者取最小值
        return Math.min(
            p[index] + process(d, p, ability + d[index], index + 1),
            process(d, p, ability, index + 1)
        );
    }
}
```

第一种动态规划

```java
public static long func2(int[] d, int[] p) {
    int sum = 0;
    for (int num : d) { // 累加所有能力值
        sum += num;
    }
    // 怪兽范围为0~N+1，能力范围为0~sum+1
    //dp[i][j]表示具有i能力的情况下通过[i...d.length-1]这些怪兽需要最少的钱
    long[][] dp = new long[d.length + 1][sum + 1];
    for (int index = d.length - 1; index >= 0; index--) { // 从下往上推
        for (int ability = 0; ability <= sum; ability++) {
            //如果这种情况发生，那么这个hp是递归过程中不会出现的状态
            //因为动态规划是对递归过程的优化，尝试过程碰不到的状态，直接跳过即可，不必计算
            if (ability + d[index] > sum) {
                continue;
            }
            // 当前具备的能力小于当前怪兽的能力，没得选，只能花钱贿赂怪兽，然后能力增长
            if (ability < d[index]) { 
                dp[index][ability] = p[index] + dp[index + 1][ability + d[index]];
            } else { // 当前具备的能力大于等于当前怪兽的能力：两种选择
                dp[index][ability] = Math.min(p[index] + dp[index + 1][ability + d[index]], dp[index + 1][ability]);
            }
        }
    }
    return dp[0][0];
}
```

第二种动态规划

```java
public static long func3(int[] d, int[] p) {
    int sum = 0;
    for (int num : p) {
        sum += num;
    }
    // dp[i][j]含义：
    // 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
    // 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
    int[][] dp = new int[d.length][sum + 1];
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j <= sum; j++) {
            dp[i][j] = -1;
        }
    }
    // 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
    dp[0][p[0]] = d[0];
    for (int i = 1; i < d.length; i++) {
        for (int j = 0; j <= sum; j++) {
            // 可能性一，为当前怪兽花钱
            // 存在条件：
            // j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
            if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
                dp[i][j] = dp[i - 1][j - p[i]] + d[i];
            }
            // 可能性二，不为当前怪兽花钱
            // 存在条件：
            // 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
            if (dp[i - 1][j] >= d[i]) {
                // 两种可能性中，选武力值最大的
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
            }
        }
    }
    int ans = 0;
    // dp表最后一行上，dp[N-1][j]代表：
    // 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
    // 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
    for (int j = 0; j <= sum; j++) {
        if (dp[d.length - 1][j] != -1) {
            ans = j;
            break;
        }
    }
    return ans;
}
```

