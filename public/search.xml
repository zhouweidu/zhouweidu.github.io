<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>the-missing-semester-in-cs</title>
      <link href="/2023/01/01/the-missing-semester-in-cs/"/>
      <url>/2023/01/01/the-missing-semester-in-cs/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Shell"><a href="#1-Shell" class="headerlink" title="1. Shell"></a>1. Shell</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM教程</title>
      <link href="/2022/12/19/SSM%E6%95%99%E7%A8%8B/"/>
      <url>/2022/12/19/SSM%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyBatis"><a href="#1-MyBatis" class="headerlink" title="1. MyBatis"></a>1. MyBatis</h1><h2 id="1-1-搭建MyBatis环境"><a href="#1-1-搭建MyBatis环境" class="headerlink" title="1.1 搭建MyBatis环境"></a>1.1 搭建MyBatis环境</h2><h1 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2. Spring"></a>2. Spring</h1><h2 id="2-1-IOC-控制反转，依赖注入"><a href="#2-1-IOC-控制反转，依赖注入" class="headerlink" title="2.1 IOC-控制反转，依赖注入"></a>2.1 IOC-控制反转，依赖注入</h2><h2 id="2-2-AOP-面向切面编程"><a href="#2-2-AOP-面向切面编程" class="headerlink" title="2.2 AOP-面向切面编程"></a>2.2 AOP-面向切面编程</h2><h2 id="2-3-声明式事务"><a href="#2-3-声明式事务" class="headerlink" title="2.3 声明式事务"></a>2.3 声明式事务</h2><p><a href="https://blog.csdn.net/soonfly/article/details/70305683">Spring事务属性之7种传播行为-CSDN博客</a></p><h1 id="3-SpringMVC"><a href="#3-SpringMVC" class="headerlink" title="3.SpringMVC"></a>3.SpringMVC</h1><h2 id="3-1-请求和响应"><a href="#3-1-请求和响应" class="headerlink" title="3.1 请求和响应"></a>3.1 请求和响应</h2><p>请求头和响应头的报文中的键是不区分大小写的，但是值区分大小写。</p><h2 id="3-2-转发和重定向"><a href="#3-2-转发和重定向" class="headerlink" title="3.2 转发和重定向"></a>3.2 转发和重定向</h2><p>业务处理成功一般使用重定向，失败则使用转发。</p><h1 id="4-一些额外的知识"><a href="#4-一些额外的知识" class="headerlink" title="4. 一些额外的知识"></a>4. 一些额外的知识</h1><h2 id="4-1-DTD文件"><a href="#4-1-DTD文件" class="headerlink" title="4.1 DTD文件"></a>4.1 DTD文件</h2><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><h2 id="4-2-注解"><a href="#4-2-注解" class="headerlink" title="4.2 注解"></a>4.2 注解</h2><p><a href="https://zhuanlan.zhihu.com/p/37701743">java注解-最通俗易懂的讲解 - 知乎 (zhihu.com)</a></p><h2 id="4-3-类加载器"><a href="#4-3-类加载器" class="headerlink" title="4.3 类加载器"></a>4.3 类加载器</h2><p><a href="https://blog.csdn.net/qq_34178598/article/details/78262302">CSDN博客-类加载器</a></p><h2 id="4-4-post和get请求方式"><a href="#4-4-post和get请求方式" class="headerlink" title="4.4 post和get请求方式"></a>4.4 post和get请求方式</h2><p>post有请求体，get没有请求体。</p><h2 id="4-5-Tomcat相关"><a href="#4-5-Tomcat相关" class="headerlink" title="4.5 Tomcat相关"></a>4.5 Tomcat相关</h2><p><a href="https://www.cnblogs.com/danyuzhu11/p/10469334.html">Tomcat处理HTTP请求原理&amp;线程池</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发教程</title>
      <link href="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
      <url>/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h1><h2 id="1-1-WXSS"><a href="#1-1-WXSS" class="headerlink" title="1.1 WXSS"></a>1.1 WXSS</h2><h3 id="1-1-1-尺寸单位"><a href="#1-1-1-尺寸单位" class="headerlink" title="1.1.1 尺寸单位"></a>1.1.1 尺寸单位</h3><p>rpx：可以根据屏幕宽度进行自适应。规定屏幕宽度为750rpx。</p><h3 id="1-1-2-样式的使用"><a href="#1-1-2-样式的使用" class="headerlink" title="1.1.2 样式的使用"></a>1.1.2 样式的使用</h3><p>静态的样式统一写到class中。style接受动态样式，在运行时进行解析，尽量避免将静态样式写到style中，以免影响渲染速度。</p><h3 id="1-1-3-页面布局"><a href="#1-1-3-页面布局" class="headerlink" title="1.1.3 页面布局"></a>1.1.3 页面布局</h3><p><a href="https://www.runoob.com/w3cnote/flex-grammar.html">Flex 布局语法教程 | 菜鸟教程 (runoob.com)</a>，在display属性中使用flex布局，<code>display:flex;</code></p><h3 id="1-1-4-button按钮的属性"><a href="#1-1-4-button按钮的属性" class="headerlink" title="1.1.4 button按钮的属性"></a>1.1.4 button按钮的属性</h3><p>button按钮会有一些默认的样式，要通过style内嵌css来设置样式。</p><span id="more"></span><h2 id="1-2-JS"><a href="#1-2-JS" class="headerlink" title="1.2 JS"></a>1.2 JS</h2><h3 id="1-2-1-小程序的生命周期和回调函数"><a href="#1-2-1-小程序的生命周期和回调函数" class="headerlink" title="1.2.1 小程序的生命周期和回调函数"></a>1.2.1 小程序的生命周期和回调函数</h3><ol><li>一般将实时更新页面数据的代码放在onShow回调函数中。</li><li>页面的基础内容相关数据一般放在onLoad函数中仅被加载一次。</li><li>小程序页面的生命周期在编写js代码时很重要，到时候写页面的时候要考虑到各个生命周期应该做什么事情，由此在回调函数中写相应的内容。</li></ol><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221027195545207.png" alt="image-20221027195545207"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221027195720710.png" alt="image-20221027195720710"></p><h3 id="1-2-2-事件响应"><a href="#1-2-2-事件响应" class="headerlink" title="1.2.2 事件响应"></a>1.2.2 事件响应</h3><p>target一般是触发事件的源组件，currentTarget是事件绑定的当前组件。一般使用currentTarget。</p><h3 id="1-2-3-页面间数据通信"><a href="#1-2-3-页面间数据通信" class="headerlink" title="1.2.3 页面间数据通信"></a>1.2.3 页面间数据通信</h3><p>一般使用url传递参数即可，需要两个页面互相传递数据时才使用EventChannel传递参数。<a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo中使用事件通信通道传递参数的方法</a>。</p><h3 id="1-2-4-setData函数调用"><a href="#1-2-4-setData函数调用" class="headerlink" title="1.2.4 setData函数调用"></a>1.2.4 setData函数调用</h3><p><a href="https://cloud.tencent.com/developer/article/1673414">微信小程序：setData方法详解和注意事项</a></p><h2 id="1-3-WXML"><a href="#1-3-WXML" class="headerlink" title="1.3 WXML"></a>1.3 WXML</h2><h3 id="1-3-1-image标签的属性"><a href="#1-3-1-image标签的属性" class="headerlink" title="1.3.1 image标签的属性"></a>1.3.1 image标签的属性</h3><p><a href="https://blog.csdn.net/qq_42339350/article/details/118489491">image的mode常用属性</a></p><h2 id="1-4-常用API"><a href="#1-4-常用API" class="headerlink" title="1.4 常用API"></a>1.4 常用API</h2><h3 id="1-4-1-界面交互API"><a href="#1-4-1-界面交互API" class="headerlink" title="1.4.1 界面交互API"></a>1.4.1 界面交互API</h3><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026222223725.png" alt="image-20221026222223725"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026222406788.png" alt="image-20221026222406788"></p><h3 id="1-4-2-页面路由API"><a href="#1-4-2-页面路由API" class="headerlink" title="1.4.2 页面路由API"></a>1.4.2 页面路由API</h3><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026222508319.png" alt="image-20221026222508319"></p><h2 id="1-5-调用云函数"><a href="#1-5-调用云函数" class="headerlink" title="1.5 调用云函数"></a>1.5 调用云函数</h2><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026223055691.png" alt="image-20221026223055691"></p><h3 id="1-5-1-上传图片（尽量不要有该功能比较难）"><a href="#1-5-1-上传图片（尽量不要有该功能比较难）" class="headerlink" title="1.5.1 上传图片（尽量不要有该功能比较难）"></a>1.5.1 上传图片（尽量不要有该功能比较难）</h3><p>视频中关于上传图片的实现有点小问题，不能每次选择图片后就立即上传到云端，这样会不断占用云端服务器的存储空间，最好在用户提交反馈的时候在将图片上传到云端。但上传图片功能比较麻烦，如果不是必要就不要开发该功能。</p><h3 id="1-5-2-订阅消息（更难了尽量不要开发该功能）"><a href="#1-5-2-订阅消息（更难了尽量不要开发该功能）" class="headerlink" title="1.5.2 订阅消息（更难了尽量不要开发该功能）"></a>1.5.2 订阅消息（更难了尽量不要开发该功能）</h3><h2 id="1-6-前端开发的一点小提醒"><a href="#1-6-前端开发的一点小提醒" class="headerlink" title="1.6 前端开发的一点小提醒"></a>1.6 前端开发的一点小提醒</h2><p>因为小程序最终都会前后端打通，所以在前端开发中逻辑可能会比较复杂，需要自己多思考多调试，就是多用<code>console.log()</code>函数在控制台打印一些信息帮助自己找出问题，最常用的就是打印json数据。微信小程序的api版本在更新，有一些api可能在调用的时候会出问题，这时只能自己查阅开发者文档进行检查，复制文档中的新版api进行使用。但今后使用小程序的时候手机上的微信版本就必须比较新，如果旧版本的api没有问题那么就继续用旧版本的api。</p><h1 id="2-后端"><a href="#2-后端" class="headerlink" title="2. 后端"></a>2. 后端</h1><h2 id="2-1-云函数"><a href="#2-1-云函数" class="headerlink" title="2.1 云函数"></a>2.1 云函数</h2><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026223603000.png" alt="image-20221026223603000"></p><h2 id="2-2-云函数操作数据库"><a href="#2-2-云函数操作数据库" class="headerlink" title="2.2 云函数操作数据库"></a>2.2 云函数操作数据库</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/query.html">查询指令(与或非大于小于等)-微信开放文档 </a></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026223709885.png" alt="image-20221026223709885"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026223741454.png" alt="image-20221026223741454"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224015002.png" alt="image-20221026224015002"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224038467.png" alt="image-20221026224038467"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224119388.png" alt="image-20221026224119388"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224135325.png" alt="image-20221026224135325"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224210022.png" alt="image-20221026224210022"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224232956.png" alt="image-20221026224232956"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224314459.png" alt="image-20221026224314459"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221026224355639.png" alt="image-20221026224355639"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221027160908376.png" alt="image-20221027160908376"></p><p><img src="/2022/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/image-20221027160955798.png" alt="image-20221027160955798"></p><h1 id="3-多人协同开发"><a href="#3-多人协同开发" class="headerlink" title="3. 多人协同开发"></a>3. 多人协同开发</h1><p><a href="https://blog.csdn.net/zmh3933/article/details/122280675">微信小程序多人开发的配置流程</a></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构（左程云）</title>
      <link href="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/"/>
      <url>/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-复杂度、二分法、与异或运算"><a href="#1-复杂度、二分法、与异或运算" class="headerlink" title="1. 复杂度、二分法、与异或运算"></a>1. 复杂度、二分法、与异或运算</h1><h2 id="1-1-二分法"><a href="#1-1-二分法" class="headerlink" title="1.1 二分法"></a>1.1 二分法</h2><p>只要能构建出排他性的逻辑就可以用二分，比如说我虽然不知道左边可不可以，但我知道右边一定不可以，那么就可以二分。</p><h2 id="1-2-异或运算"><a href="#1-2-异或运算" class="headerlink" title="1.2 异或运算"></a>1.2 异或运算</h2><h3 id="1-2-1-异或运算就是无进位的加法运算。"><a href="#1-2-1-异或运算就是无进位的加法运算。" class="headerlink" title="1.2.1 异或运算就是无进位的加法运算。"></a>1.2.1 异或运算就是<strong>无进位的加法运算</strong>。</h3><h3 id="1-2-2-异或运算的应用"><a href="#1-2-2-异或运算的应用" class="headerlink" title="1.2.2 异或运算的应用"></a>1.2.2 异或运算的应用</h3><p>怎么把一个数字（int）最右侧的1提取出来？（注意是最右侧的1）</p><p>答案为：<code>N&amp;((~N)+1)</code>，N取反首先会让最右侧1（记为1r）的右边的0变为1，让1r左边的1变0，0变1，然后加一会使1r右边的1依次进位变成0，直到进位到1r为止，此时1r变为1，最后与运算，因为1r左边取反了所以全为0，1r右边进位了全为0，得到结果</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20220919211646027.png" alt="image-20220919211646027"></p><span id="more"></span><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><h2 id="2-1-先序、中序、后序遍历（非递归实现）"><a href="#2-1-先序、中序、后序遍历（非递归实现）" class="headerlink" title="2.1 先序、中序、后序遍历（非递归实现）"></a>2.1 先序、中序、后序遍历（非递归实现）</h2><p><strong>先序</strong></p><p>（1）弹打印</p><p>（2）如有右，压入右</p><p>（3）如有左，压入左</p><p><strong>后序</strong></p><p>上面先序是中左右，那么改变压栈顺序为中右左，倒过来就是左右中。</p><p>（1）弹加入另外一个栈</p><p>（2）如有左，压入左</p><p>（3）如有右，压入右</p><p>（4）从另外那个栈弹出一个打印一个</p><p><strong>中序</strong></p><p>（1）整条左边界依次入栈</p><p>（2）条件（1）不成立时，弹出打印，来到弹出结点的右树上继续条件（1）</p><h2 id="2-2-二叉树递归套路"><a href="#2-2-二叉树递归套路" class="headerlink" title="2.2 二叉树递归套路"></a>2.2 二叉树递归套路</h2><p>（1）假设以x为头，假设可以问x左树和x右树要任何信息。</p><p>（2）在上一步的假设下，讨论以x为头节点的树，得到<strong>答案的可能性</strong>（最重要的一步，常见分类：这道题的答案跟x有关和跟x无关）。</p><p>（3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息。</p><p>（4）把左树信息和右树信息求全集，就是一棵子树都需要返回的信息S。</p><p>（5）递归函数都返回S，每一棵子树都这么要求。</p><p>（6）写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息。</p><h2 id="2-3-堆和排序是解决贪心问题的常用技巧"><a href="#2-3-堆和排序是解决贪心问题的常用技巧" class="headerlink" title="2.3 堆和排序是解决贪心问题的常用技巧"></a>2.3 堆和排序是解决贪心问题的常用技巧</h2><h2 id="2-4-二叉树的序列化（只能前序和后序）"><a href="#2-4-二叉树的序列化（只能前序和后序）" class="headerlink" title="2.4 二叉树的序列化（只能前序和后序）"></a>2.4 二叉树的序列化（只能前序和后序）</h2><p>要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>但对于中序遍历来说，<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h2 id="2-5-搜索二叉树（BST）的定义"><a href="#2-5-搜索二叉树（BST）的定义" class="headerlink" title="2.5 搜索二叉树（BST）的定义"></a>2.5 搜索二叉树（BST）的定义</h2><p>如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p><h1 id="3-图"><a href="#3-图" class="headerlink" title="3. 图"></a>3. 图</h1><h1 id="4-暴力递归"><a href="#4-暴力递归" class="headerlink" title="4. 暴力递归"></a>4. 暴力递归</h1><p>暴力递归就是尝试</p><ol><li>把问题转化为规模缩小了的同类问题的子问题</li><li>有明确的不需要继续进行递归的条件</li><li>有当得到了<strong>子问题结果</strong>之后的<strong>决策过程</strong></li><li>不记录每一子问题的解</li></ol><h1 id="5-动态规划"><a href="#5-动态规划" class="headerlink" title="5. 动态规划"></a>5. 动态规划</h1><h2 id="5-1-四种尝试模型"><a href="#5-1-四种尝试模型" class="headerlink" title="5.1 四种尝试模型"></a>5.1 四种尝试模型</h2><p>（1）从左往右尝试</p><p>（2）范围上尝试</p><p>（3）多样本位置全对应尝试（一个做行、一个做列，而且往往是根据结尾位置怎么样来划分可能性）</p><p>（4）寻找业务限制尝试</p><p>（5）外部信息变成有效几个参数往下推</p><h2 id="5-2-设计暴力递归过程的原则"><a href="#5-2-设计暴力递归过程的原则" class="headerlink" title="5.2 设计暴力递归过程的原则"></a>5.2 设计暴力递归过程的原则</h2><p>（1）每一个可变参数类型，一定不要比int类型更加复杂</p><p>（2）原则（1）可以违反，让类型突破到一维线性结构，那必须是唯一可变参数</p><p>（3）如果发现原则（1）被违反，但不违反原则（2），只需要做到记忆化搜索即可</p><p>（4）可变参数的个数，能少则少</p><h1 id="6-单调队列"><a href="#6-单调队列" class="headerlink" title="6. 单调队列"></a>6. 单调队列</h1><p>求窗口最大值<br>双端队列中的数据一定是严格从大到小的，双端队列维持的是在依次过期的情况下成为最大值的可能性，当有一个值cur需要从队尾加入队列时，如果比此时队尾的值大，将队尾值弹出，因为cur比队尾值大而且比队尾值晚过期，所以此时的队尾值不会再成为最大值了，直接弹出即可，重复此过程直到队列为空或队列末尾的值大于cur，将cur加入队尾。</p><h1 id="7-单调栈"><a href="#7-单调栈" class="headerlink" title="7. 单调栈"></a>7. 单调栈</h1><p>找到左右两边离一个数最近的比他小（大）的那个数，下面的图是证明</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20220928162859802.png" alt="image-20220928162859802"></p><h1 id="8-Morris遍历"><a href="#8-Morris遍历" class="headerlink" title="8. Morris遍历"></a>8. Morris遍历</h1><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20220928163102943.png" alt="image-20220928163102943"></p><p>遍历的规律：有左子树的结点会经过两次，没有左子树的结点只会经过一次，下面是Morris遍历的代码</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20220928170702186.png" alt="image-20220928170702186"></p><h1 id="9-有序表"><a href="#9-有序表" class="headerlink" title="9. 有序表"></a>9. 有序表</h1><h2 id="9-1-有序表的时间复杂度"><a href="#9-1-有序表的时间复杂度" class="headerlink" title="9.1 有序表的时间复杂度"></a>9.1 有序表的时间复杂度</h2><p>有序表的所有操作（增删改查）时间复杂度都是O(logN)。</p><h2 id="9-2-实现有序表的数据结构"><a href="#9-2-实现有序表的数据结构" class="headerlink" title="9.2 实现有序表的数据结构"></a>9.2 实现有序表的数据结构</h2><p>红黑树、AVL树、SizeBalanceTree（简称SB树）、SkipList（跳表）</p><h2 id="9-3-导致平衡性失效的四种情况"><a href="#9-3-导致平衡性失效的四种情况" class="headerlink" title="9.3 导致平衡性失效的四种情况"></a>9.3 导致平衡性失效的四种情况</h2><p>（1）LL型：我的左孩子的左子树过长导致平衡性失效。头节点单次右旋就可以调整</p><p>（2）RR型：我的右孩子的右子树过长导致平衡性失效。头节点单次左旋就可以调整</p><p>（3）LR型：我的左孩子的右子树（左孩子的右子树的头节点记为X）过长导致平衡性失效。调整方法是让X节点作为头部</p><p>（4）RL型：我的右孩子的左子树（右孩子的左子树的头节点记为X）过长导致平衡性失效。调整方法是让X节点作为头部</p><h1 id="10-刷题技巧"><a href="#10-刷题技巧" class="headerlink" title="10. 刷题技巧"></a>10. 刷题技巧</h1><h2 id="10-1-预处理技巧（预处理结构）"><a href="#10-1-预处理技巧（预处理结构）" class="headerlink" title="10.1 预处理技巧（预处理结构）"></a>10.1 预处理技巧（预处理结构）</h2><ol><li><p>生成前缀累加和数组作为预处理结构。</p></li><li><p>某一个子数组可以累加生成的范围是1-range，对下一个数cur分情况讨论</p><p>（1）cur&gt;range+1,为了充分利用前面这个范围，需要补充range+1这个数，让范围扩大到</p><p>1-（2*range+1）。</p><p>（2）cur&lt;&#x3D;range+1，那么可以直接累加使范围变为1-range+cur。</p></li></ol><h2 id="10-2-根据数据量猜解法"><a href="#10-2-根据数据量猜解法" class="headerlink" title="10.2 根据数据量猜解法"></a>10.2 根据数据量猜解法</h2><p>根据输入参数范围看菜下饭，代码常数级别的操作在10的8次方以内。下面举一个例子，说明怎么根据数据范围选择不同的方法。</p><hr><p><strong>花最少钱通过所有怪兽</strong></p><p>int[] d，d[i]：i号怪兽的能力</p><p>int[] p，p[i]：i号怪兽要求的钱</p><p>开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。</p><p>如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。</p><p>返回通过所有的怪兽，需要花的最小钱数。</p><hr><p><strong>分析</strong></p><p>如果你的能力大于等于怪兽的能力，有两种选择：</p><ul><li>第一种：直接通过，也不花钱，能力也不增长</li><li>第二种：贿赂怪兽，花钱，能力提升</li></ul><p>如果你的能力小于怪兽的能力，只能花钱贿赂怪兽，然后能力值提升</p><p><strong>方法一</strong>：<strong>暴力递归</strong>，ability：当前你所具有的能力，index：当前来到第index个怪兽的面前，目前你的能力是ability，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，请返回需要花的最少钱数。</p><p><strong>方法二</strong>：<strong>动态规划</strong>，由暴力递归发现只有两个可变参数（ability，index），准备一张二维dp表，index号怪兽做行，ability能力做列，index的变化范围<code>0~N</code>，ability的变化范围<code>0~sum</code>，所有能力加起来为sum。</p><p><strong>方法三</strong>：<strong>动态规划</strong>，如果能力范围变化很大，可能导致dp表过大，导致方法执行效率不高，重新定义dp，<code>dp[i][j]</code>含义：能经过0~i的怪兽，且花钱为j（花的钱严格等于j）时的武力值最大是多少？</p><p>分析可能性：</p><ul><li>可能性一：为当前怪兽花钱</li><li>可能性二：不为当前怪兽花钱</li></ul><p><strong>总结</strong>：如果sum能力值变化范围不大，则方法二就可以，如果sum变化范围很大，则方法三是最优解，这道题属于<strong>根据数据量猜解法</strong>。</p><hr><p><strong>实现</strong></p><p>暴力递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span>[] d, <span class="type">int</span>[] p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> process(d, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前你的能力是ability，来到index号怪兽面前，后续通过所有关需要花的最少的钱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] d, <span class="type">int</span>[] p, <span class="type">int</span> ability, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == d.length) &#123; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的能力小于当前怪兽的能力，没得选，只能花钱贿赂，花了钱能力就增长</span></span><br><span class="line">    <span class="keyword">if</span> (ability &lt; d[index]) &#123; </span><br><span class="line">        <span class="keyword">return</span> p[index] + process(d, p, ability + d[index], index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 可以贿赂，也可以不贿赂，两者取最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(</span><br><span class="line">            p[index] + process(d, p, ability + d[index], index + <span class="number">1</span>),</span><br><span class="line">            process(d, p, ability, index + <span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span>[] d, <span class="type">int</span>[] p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : d) &#123; <span class="comment">// 累加所有能力值</span></span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 怪兽范围为0~N+1，能力范围为0~sum+1</span></span><br><span class="line">    <span class="comment">//dp[i][j]表示具有i能力的情况下通过[i...d.length-1]这些怪兽需要最少的钱</span></span><br><span class="line">    <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[d.length + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> d.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123; <span class="comment">// 从下往上推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ability</span> <span class="operator">=</span> <span class="number">0</span>; ability &lt;= sum; ability++) &#123;</span><br><span class="line">            <span class="comment">//如果这种情况发生，那么这个hp是递归过程中不会出现的状态</span></span><br><span class="line">            <span class="comment">//因为动态规划是对递归过程的优化，尝试过程碰不到的状态，直接跳过即可，不必计算</span></span><br><span class="line">            <span class="keyword">if</span> (ability + d[index] &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前具备的能力小于当前怪兽的能力，没得选，只能花钱贿赂怪兽，然后能力增长</span></span><br><span class="line">            <span class="keyword">if</span> (ability &lt; d[index]) &#123; </span><br><span class="line">                dp[index][ability] = p[index] + dp[index + <span class="number">1</span>][ability + d[index]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前具备的能力大于等于当前怪兽的能力：两种选择</span></span><br><span class="line">                dp[index][ability] = Math.min(p[index] + dp[index + <span class="number">1</span>][ability + d[index]], dp[index + <span class="number">1</span>][ability]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span>[] d, <span class="type">int</span>[] p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : p) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]含义：</span></span><br><span class="line">    <span class="comment">// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？</span></span><br><span class="line">    <span class="comment">// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[d.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的</span></span><br><span class="line">    dp[<span class="number">0</span>][p[<span class="number">0</span>]] = d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; d.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="comment">// 可能性一，为当前怪兽花钱</span></span><br><span class="line">            <span class="comment">// 存在条件：</span></span><br><span class="line">            <span class="comment">// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= p[i] &amp;&amp; dp[i - <span class="number">1</span>][j - p[i]] != -<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - p[i]] + d[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可能性二，不为当前怪兽花钱</span></span><br><span class="line">            <span class="comment">// 存在条件：</span></span><br><span class="line">            <span class="comment">// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= d[i]) &#123;</span><br><span class="line">                <span class="comment">// 两种可能性中，选武力值最大的</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp表最后一行上，dp[N-1][j]代表：</span></span><br><span class="line">    <span class="comment">// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？</span></span><br><span class="line">    <span class="comment">// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[d.length - <span class="number">1</span>][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            ans = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-用递归函数解决字符串嵌套问题"><a href="#10-3-用递归函数解决字符串嵌套问题" class="headerlink" title="10.3 用递归函数解决字符串嵌套问题"></a>10.3 用递归函数解决字符串嵌套问题</h2><p>定义函数<code>f(String str, int i)</code>，代表从str的i位置出发一直往后延申，直到遇到字符串的终止位置或者遇到’}’（大括号可根据题目要求定义）停，返回从i出发到停这段的处理结果和停的位置。上级函数遇到’{‘就去递归调用该函数进行求解得到结果，再接着往下进行处理。</p><h2 id="10-4-找到无序数组中未出现的最小正整数"><a href="#10-4-找到无序数组中未出现的最小正整数" class="headerlink" title="10.4 找到无序数组中未出现的最小正整数"></a>10.4 找到无序数组中未出现的最小正整数</h2><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20221002172405971.png" alt="image-20221002172405971"></p><p>上图的算法可以做到时间复杂度O(N)，空间复杂度O(1)。</p><h2 id="10-5-数组中的连续递增子数组"><a href="#10-5-数组中的连续递增子数组" class="headerlink" title="10.5 数组中的连续递增子数组"></a>10.5 数组中的连续递增子数组</h2><p>长度为n的数组中最多有n&#x2F;2个连续上坡，如下图所示。</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20221007222330464.png" alt="image-20221007222330464"></p><h2 id="10-6-四边形不等式优化动态规划"><a href="#10-6-四边形不等式优化动态规划" class="headerlink" title="10.6 四边形不等式优化动态规划"></a>10.6 四边形不等式优化动态规划</h2><p>题目需要满足三个特征，在填dp表是可以根据所填格子的上班一个格子和右边一个格子确定枚举的上下限</p><p>（1）数据情况特殊（比如都是正数，题目中的两个指标（问题）存在单调性）。</p><p>（2）是区间划分问题（给你一个范围让你用给定的东西（给定多少个数）去搞定）。</p><p>（3）有枚举行为。</p><p>（4）每一个格子不同时依赖本行和本列。如果一个格子只依赖自己本行的值，列从左到右枚举，每一行从下到上，每个格子左边和下边给你提供下界和上界；如果一个格子只依赖本行的值，行从上往下枚举，每一列从右往左算，每个格子的上边和右边给你提供下界和上界。</p><h2 id="10-7-二分答案法"><a href="#10-7-二分答案法" class="headerlink" title="10.7 二分答案法"></a>10.7 二分答案法</h2><p>根据题目问题分析出答案所在的范围（粗略一点也无所谓），然后在答案范围上二分去验证。</p><h2 id="10-8-子串、子数组相关的问题解法"><a href="#10-8-子串、子数组相关的问题解法" class="headerlink" title="10.8 子串、子数组相关的问题解法"></a>10.8 子串、子数组相关的问题解法</h2><p>首先想以0位置结尾（或开头）该问题答案是什么，以1位置结尾（或开头）答案是什么，以2位置结尾（或开头）答案是什么。。。</p><h2 id="10-9-最长递增子序列（子序列可以不连续）"><a href="#10-9-最长递增子序列（子序列可以不连续）" class="headerlink" title="10.9 最长递增子序列（子序列可以不连续）"></a>10.9 最长递增子序列（子序列可以不连续）</h2><p>算法原型：动态规划+贪心+二分查找</p><p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p><p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]。</p><p>同时我们可以注意到 d[i] 是关于 i 单调递增的。因为如果 d[j]≥d[i] 且 j&lt;i，我们考虑从长度为 i 的最长上升子序列的末尾删除 i-j个元素，那么这个序列长度变为 j ，且第 j 个元素 x（末尾元素）必然小于 d[i]（因为从第j个元素到第i个元素是单调递增的），也就小于 d[j]。那么我们就找到了一个长度为 j 的最长上升子序列，并且末尾元素比 d[j] 小，从而产生了矛盾。因此数组 d 的单调性得证。</p><p>我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。</p><p>如果 nums[i]&gt;d[len] 则更新len&#x3D;len+1，否则在 d[1…len]中找满足 d[i−1]&lt;nums[j]&lt;d[i] 的下标 i，并更新 d[i]&#x3D;nums[j]。</p><p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p><p>最后<strong>整个算法流程</strong>为：</p><p>设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到 nums[i] 时：</p><ul><li><p>如果 nums[i]&gt;d[len] ，则直接加入到 d 数组末尾，并更新 len&#x3D;len+1；</p></li><li><p>否则，在 d 数组中二分查找，找到最后一个比 nums[i] 小的数 d[k]，并更新 d[k+1]&#x3D;nums[i]。（也就是长度为k的递增子序列末尾元素的最小值为d[k]，因为这是最后一个比nums[i]小的数，所以d[k+1]一定大于nums[i]，所以长度为k+1的递增子序列末尾元素的最小值可以更新）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，</span></span><br><span class="line">                <span class="comment">//此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-10-假设答案法"><a href="#10-10-假设答案法" class="headerlink" title="10.10 假设答案法"></a>10.10 假设答案法</h2><p>先假设出该题的答案，然后<strong>分析答案的一些性质</strong>，设计一个复杂度尽量低的流程把答案找出来。</p><h2 id="10-11-压缩数组技巧"><a href="#10-11-压缩数组技巧" class="headerlink" title="10.11 压缩数组技巧"></a>10.11 压缩数组技巧</h2><p>将矩阵每一行加起来成为一个数组，看到子矩阵的问题可以先想子数组是怎么处理的。</p><h2 id="10-12-通过平凡解剪枝"><a href="#10-12-通过平凡解剪枝" class="headerlink" title="10.12 通过平凡解剪枝"></a>10.12 通过平凡解剪枝</h2><p>如果某一个递归跑不完，那么可以通过找一个平凡解，当递归得到的解比平凡解还差的时候就提前退出了。</p><h1 id="11-线段树（区间修改树）"><a href="#11-线段树（区间修改树）" class="headerlink" title="11. 线段树（区间修改树）"></a>11. 线段树（区间修改树）</h1><p>更快速的、区间的更改、查询一些东西。实现一种数据结构使得以下三种计算的时间复杂度为O(logN)<br>void add(arr, L, R, V); ：将arr数组中的第L到R的数都增加V<br>void update(arr, L, R, V);：将arr数组中的第L到R的数都修改为V<br>int getSum(arr, L, R);：将arr数组中的第L到R的数相加返回累加和</p><p>需要多少空间：假设数据量为N，N如果不是2的某次方也补齐为2的某次方，最多需要4*N的空间，线段树的左右节点都是根据父节点依次二分得出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MAXN;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sum;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] lazy;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] change;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] update;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] origin)</span> &#123;</span><br><span class="line">        MAXN = origin.length + <span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            arr[i] = origin[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        change = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        update = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> rt)</span> &#123;</span><br><span class="line">        sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将任务下发</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rt 当前的目标节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ln 目标节点左子树的节点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rn 目标节点柚子树节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> ln, <span class="type">int</span> rn)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[rt]) &#123;</span><br><span class="line">            update[rt &lt;&lt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            update[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            change[rt &lt;&lt; <span class="number">1</span>] = change[rt];</span><br><span class="line">            change[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt];</span><br><span class="line">            lazy[rt &lt;&lt; <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            sum[rt &lt;&lt; <span class="number">1</span>] = change[rt] * ln;</span><br><span class="line">            sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = change[rt] * rn;</span><br><span class="line">            update[rt] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下发上次更新后执行的add操作</span></span><br><span class="line">        <span class="keyword">if</span> (lazy[rt] != <span class="number">0</span>) &#123;</span><br><span class="line">            lazy[rt &lt;&lt; <span class="number">1</span>] += lazy[rt];</span><br><span class="line">            lazy[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt];</span><br><span class="line">            sum[rt &lt;&lt; <span class="number">1</span>] += lazy[rt] * ln;</span><br><span class="line">            sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[rt] * rn;</span><br><span class="line">            lazy[rt] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[rt] = arr[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        build(mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        pushUp(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">        <span class="comment">// 全包了,只懒更新根节点</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            update[rt] = <span class="literal">true</span>;</span><br><span class="line">            change[rt] = C;</span><br><span class="line">            sum[rt] = C * (r - l + <span class="number">1</span>);</span><br><span class="line">            lazy[rt] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要下发</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">            update(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">            update(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒添加</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> L  任务左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R  任务右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C  加的数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l  收到任务的数组左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r  收到任务的数组右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rt 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="comment">// 任务将当前的数组全包了,不用下传了</span></span><br><span class="line">            sum[rt] += C * (r - l + <span class="number">1</span>);</span><br><span class="line">            lazy[rt] += C;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下发任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 下发之前的lazy add任务</span></span><br><span class="line">        pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">            add(L, R, C, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">            add(L, R, C, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushUp(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[rt];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        pushDown(rt, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= mid) &#123;</span><br><span class="line">            ans += query(L, R, l, mid, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; mid) &#123;</span><br><span class="line">            ans += query(L, R, mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-设计数据结构的题目（一般是根据老结构改）"><a href="#12-设计数据结构的题目（一般是根据老结构改）" class="headerlink" title="12. 设计数据结构的题目（一般是根据老结构改）"></a>12. 设计数据结构的题目（一般是根据老结构改）</h1><h2 id="12-1-带有setAll功能的哈希表"><a href="#12-1-带有setAll功能的哈希表" class="headerlink" title="12.1 带有setAll功能的哈希表"></a>12.1 带有setAll功能的哈希表</h2><p><strong>要求</strong>：使setAll、get、put方法的时间复杂度仍然是O(1)</p><p><strong>解答</strong>：加入三个变量，long类型的time变量记录时间戳，一开始初始化为0，每次调用setAll方法，put方法都让时间戳加一，哈希表的value封装为数据和时间戳的值；long类型的setAllTime记录最近一次调用setAll方法的时间戳，每次调用setAll方法就更新；int类型的all变量记录当前的all，调用setAll就更新。调用get方法时先将得到的value的时间戳和setAllTime比较一下来决定返回值。</p><h1 id="13-字符串问题"><a href="#13-字符串问题" class="headerlink" title="13. 字符串问题"></a>13. 字符串问题</h1><h2 id="13-1-返回字符串中有多少个字面值不同的子序列"><a href="#13-1-返回字符串中有多少个字面值不同的子序列" class="headerlink" title="13.1 返回字符串中有多少个字面值不同的子序列"></a>13.1 返回字符串中有多少个字面值不同的子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以每个字符结尾的集合数目</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合数目，初始空集</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        <span class="comment">// 集合数目扩大一倍，减去重复</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> all - dp[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        all += add;</span><br><span class="line">        dp[c - <span class="string">&#x27;a&#x27;</span>] += add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果不含空集</span></span><br><span class="line">    <span class="keyword">return</span> all - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-一些小结论"><a href="#14-一些小结论" class="headerlink" title="14. 一些小结论"></a>14. 一些小结论</h1><h2 id="14-1-合并相邻数字"><a href="#14-1-合并相邻数字" class="headerlink" title="14.1 合并相邻数字"></a>14.1 合并相邻数字</h2><p>n个数每次只能相邻k个数合并，最终能不能合成一个数：如果(n-1)%(k-1)&#x3D;&#x3D;0，就能合并成一个数，如果大于0就不能合并。</p><h2 id="14-2-有单调性的问题就要想到滑动窗口"><a href="#14-2-有单调性的问题就要想到滑动窗口" class="headerlink" title="14.2 有单调性的问题就要想到滑动窗口"></a>14.2 有单调性的问题就要想到滑动窗口</h2><h2 id="14-3-答案流程的优化"><a href="#14-3-答案流程的优化" class="headerlink" title="14.3 答案流程的优化"></a>14.3 答案流程的优化</h2><p>从两方面入手，自己的数据状况，所要求解的标准。</p><h1 id="15-index-tree"><a href="#15-index-tree" class="headerlink" title="15. index tree"></a>15. index tree</h1><h2 id="15-1-使用场景"><a href="#15-1-使用场景" class="headerlink" title="15.1 使用场景"></a>15.1 使用场景</h2><p>在对一个数据集进行一些例如区间 [L,R] 求和的问题的时候（可以更改数据集中某一个元素的值，并且能查询任意范围上的累加和），想通过一个比较快的数据结构来完成，可以使用indexTree，它可以达到 O(logN) 的时间复杂度。</p><h2 id="15-2-算法思想"><a href="#15-2-算法思想" class="headerlink" title="15.2 算法思想"></a>15.2 算法思想</h2><p>构建一个help数组，如下图</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20221023221250903.png" alt="image-20221023221250903"></p><p>作为一个help数组，有如下特点：</p><ul><li>help数组的有效位置从1位置开始</li><li>采用“配对”的方式在位置上存放值，因此以图上为例，我们来描述一个这个过程：</li></ul><p>1：1位置上只有自己，因此只存放1位置的值<br>2：之前有一个1位置，所以与2位置配对，组成一对，所以此位置存放1,2位置的值<br>3:   3位置往前看，忽视已经配对的位置，因此只有它自己，因此只存放3位置的值<br>4：之前有一个3位置，所以可以配对3,4； 但3,4配对之后又可以和之前配对的1,2进行组配对，因此此处位置就存放1,2,3,4的值<br>5：5位置往前看，忽视已经配对的位置，因此只有它自己，因此只存放5位置的值<br>6：之前有一个5位置，所以可以配对5,6，组成一对，所以此位置存放5,6位置的值<br>7：7位置往前看，忽视已经配对的位置，因此只有它自己，因此只存放7位置的值<br>8：8位置之前有一个7位置，所以可以配对7,8,，但因此和之前的5,6又可以配在一起形成5,6,7,8，此时又可以和之前形成的1,2,3,4配对，形成1,2,3,4,5,6,7,8，因此8位置存放1-8</p><p>此后的变换过程不再赘述，以这种规律进行数值的存放。</p><p><strong>求help数组任意位置的所管辖的数值和</strong></p><p>如果给定help数组的一个二进制形式的位置索引，想要得到这个位置存放了哪些值的累加和怎么办？<br>其中存在这样一个规律， 把该位置的二进制形式最右侧的1去掉，再+1得到的数，就是这个累加和范围的起始索引，结束索引就是它位置自身，我们不妨进行举例说明：</p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20221023221558996.png" alt="image-20221023221558996"></p><p>针对图上的位置：<br>1、假如我想知道位置4上管辖了哪些数的累加和怎么求？<br>4的二进制形式是：0100，我们去掉最右侧的1，变成：0000，再+1，得到0001， 这个的十进制就是1，因此我们可以确定累加和的范围起始索引是1，即，4位置存放的是1~4的累加和</p><p>2、假如我想知道位置5上管辖了哪些数的累加和怎么求？<br>5的二进制形式是：0101，我们去掉最右侧的1，变成：0100，再+1，得到0101， 这个的十进制就是5，因此我们可以确定累加和的范围起始索引是5，即，5位置存放的是5~5的累加和</p><p><strong>利用help数组的机制，求1-N的累加和</strong></p><p><img src="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/image-20221023221641416.png" alt="image-20221023221641416"></p><p>我们通过上面，已经知道help数组的机制，那如何通过它来实现1-N的累加和问题呢？还是通过上图来举例：<br>如果我要求1~7位置的累加和，怎么求？</p><p>准备一个累加值</p><p>7的位置索引二进制表示为0111，通过上面获得指定位置所管辖的范围值的累加和，可以得到的7位置管辖的就是7~7的累加值，把此位置的值加入累加值</p><p>接着，对7的二进制移除最右侧的1，得到0110，也就是位置6（存放5,6的累加值），把此位置的值加入累加值，</p><p>接着，对位置6的位置的二进制移除最右侧的1，得到0100，也就是位置4（存放1-4的累加值），把此位置的值加入累加值，</p><p>接着，对位置4的二进制移除最右侧的1，得到0000，此时发现得到的值已经是0，不进行任何操作，并终止操作</p><h2 id="15-3-代码实现"><a href="#15-3-代码实现" class="headerlink" title="15.3 代码实现"></a>15.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标从1开始！</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">IndexTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0位置弃而不用！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IndexTree</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        N = size;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1~index 累加和是多少？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret += tree[index];</span><br><span class="line">            index -= index &amp; -index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index &amp; -index : 提取出index最右侧的1出来</span></span><br><span class="line">    <span class="comment">// index :           0011001000</span></span><br><span class="line">    <span class="comment">// index &amp; -index :  0000001000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="comment">//当添加到当前位置时，哪些位置会收到影响？依次对它们也进行累加此值</span></span><br><span class="line">        <span class="comment">//可以自己举个例子推导一下 index+index最右侧的1 的结果就是下一个会被影响的位置</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= N) &#123;</span><br><span class="line">            tree[index] += d;</span><br><span class="line">            index += index &amp; -index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-一些经典问题"><a href="#16-一些经典问题" class="headerlink" title="16. 一些经典问题"></a>16. 一些经典问题</h1><h2 id="16-1-Nim博弈问题"><a href="#16-1-Nim博弈问题" class="headerlink" title="16.1 Nim博弈问题"></a>16.1 Nim博弈问题</h2><p>原题意：先手后手从数组中拿数字，每次只能从数组的一个位置拿，可以拿任意数量x（0&lt;x&lt;&#x3D;数组当前值），谁最先让数组全为0就赢了。</p><p>解答：先手一直让数组的异或和为0，那么最后赢的状态也是异或和为0，如果初始状态异或和不为0，先手总可以拿一定数量使得异或和为0，所以先手赢；如果初始异或和为0，先手不管怎么拿都会让异或和不为0，后手可以一直让异或和为0，后手赢。</p><p><a href="https://www.bilibili.com/video/BV1NU4y1M7rF/?p=33&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=11f05fe045fa3c91c1ef5352a4bed6a8">33.高级进阶班-5_哔哩哔哩_bilibili</a></p><h2 id="16-2-求有向图的强连通分量"><a href="#16-2-求有向图的强连通分量" class="headerlink" title="16.2 求有向图的强连通分量"></a>16.2 求有向图的强连通分量</h2><p><a href="https://blog.csdn.net/weixin_44668898/article/details/105531790">【图论】Tarjan算法详解-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++</title>
      <link href="/2022/09/18/Effective-C/"/>
      <url>/2022/09/18/Effective-C/</url>
      
        <content type="html"><![CDATA[<h2 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01:  视C++ 为一个语言联邦"></a>条款01:  视C++ 为一个语言联邦</h2><p><img src="/2022/09/18/Effective-C/image-20220918165735085.png" alt="image-20220918165735085"></p><h2 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02: 尽量以 const, enum, inline 替换 #define"></a>条款02: 尽量以 const, enum, inline 替换 #define</h2><span id="more"></span><h2 id="条款03-尽可能使用-const"><a href="#条款03-尽可能使用-const" class="headerlink" title="条款03: 尽可能使用 const"></a>条款03: 尽可能使用 const</h2><ul><li><p>将某些东西声明为 const 可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。 </p></li><li><p>编译器强制实施 bitwise constness ，但你编写程序时应该使用”概念上的常量性” (conceptual constness) </p></li><li><p>当 const  non-const 成员函数有着实质等价的实现时，令 non-const 版本调 const 版本可避免代码重复。</p></li></ul><h2 id="条款-04-确定对象被使用前已先被初始化"><a href="#条款-04-确定对象被使用前已先被初始化" class="headerlink" title="条款 04: 确定对象被使用前已先被初始化"></a>条款 04: 确定对象被使用前已先被初始化</h2><ul><li>为内置型对象进行手工初始化，因为 C++不保证初始化它们。 </li><li>构造函数最好使用成员初值列 (member initialization list) ，而不要在构造函数 本体内使用赋值操作(assignment) 。初值列列出的成员变量，其排列次序应该 和它们在 class 中的声明次序相同。 </li><li>为免除”跨编译单元之初始化次序”问题，请以local static 对象（函数内的static对象）替换 non-local static 对象</li></ul><h2 id="条款-05-了解-C-默默编写并调用哪些函数"><a href="#条款-05-了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 05: 了解 C++ 默默编写并调用哪些函数"></a>条款 05: 了解 C++ 默默编写并调用哪些函数</h2><p>编译器可以暗自为 class 创建 default 构造函数、 copy 构造函数、 copy assignment 操作符，以及析构函数。</p><h2 id="条款-06-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06: 若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06: 若不想使用编译器自动生成的函数，就该明确拒绝</h2><h2 id="条款-07-为多态基类声明-virtual-析构函数"><a href="#条款-07-为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07: 为多态基类声明 virtual 析构函数"></a>条款 07: 为多态基类声明 virtual 析构函数</h2><ul><li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。 </li><li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性 (polymorphically) ，就不该声明 virtual 析构函数。（会多出虚函数指针的空间）</li></ul><h2 id="条款-08-别让异常逃离析构函数"><a href="#条款-08-别让异常逃离析构函数" class="headerlink" title="条款 08: 别让异常逃离析构函数"></a>条款 08: 别让异常逃离析构函数</h2><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提 供一个普通函数(而非在析构函数中)执行该操作。</li></ul><h2 id="条款-09-绝不在构造和析构过程中调用-virtual-函数"><a href="#条款-09-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款 09: 绝不在构造和析构过程中调用 virtual 函数"></a>条款 09: 绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class (比起当前执行构造函数和析构函数的那层)。</p><h2 id="条款-10-令operator-x3D-返回一个-reference-to-this"><a href="#条款-10-令operator-x3D-返回一个-reference-to-this" class="headerlink" title="条款 10: 令operator&#x3D; 返回一个 reference to *this"></a>条款 10: 令operator&#x3D; 返回一个 reference to *this</h2><h2 id="条款-11-在operator-x3D-中处理”自我赋值”"><a href="#条款-11-在operator-x3D-中处理”自我赋值”" class="headerlink" title="条款 11: 在operator&#x3D; 中处理”自我赋值”"></a>条款 11: 在operator&#x3D; 中处理”自我赋值”</h2><p><strong>copy and swap 技术</strong></p><p><img src="/2022/09/18/Effective-C/image-20220918195311593.png" alt="image-20220918195311593"></p><h2 id="条款-12-复制对象时勿忘其每一个成分"><a href="#条款-12-复制对象时勿忘其每一个成分" class="headerlink" title="条款 12: 复制对象时勿忘其每一个成分"></a>条款 12: 复制对象时勿忘其每一个成分</h2><ul><li>Copying 函数应该确保复制”对象内的所有成员变量”及”所有 base class 成分”。</li><li>不要尝试以某个 copying 函数实现另一个 copying 函数。应该将共同机能放进第三个函数中，并由两个 coping 函数共同调用。</li></ul><h2 id="条款-13-以对象管理资源"><a href="#条款-13-以对象管理资源" class="headerlink" title="条款 13: 以对象管理资源"></a>条款 13: 以对象管理资源</h2><h2 id="条款-14-在资源管理类中小心coping-行为"><a href="#条款-14-在资源管理类中小心coping-行为" class="headerlink" title="条款 14: 在资源管理类中小心coping 行为"></a>条款 14: 在资源管理类中小心coping 行为</h2><h2 id="条款-15-在资源管理类中提供对原始资源的访问"><a href="#条款-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15: 在资源管理类中提供对原始资源的访问"></a>条款 15: 在资源管理类中提供对原始资源的访问</h2><h2 id="条款-16-成对使用-new-delete-时要采取相同形式"><a href="#条款-16-成对使用-new-delete-时要采取相同形式" class="headerlink" title="条款 16: 成对使用 new delete 时要采取相同形式"></a>条款 16: 成对使用 new delete 时要采取相同形式</h2><h2 id="条款-17-以独立语句将-new-创建的对象置入智能指针"><a href="#条款-17-以独立语句将-new-创建的对象置入智能指针" class="headerlink" title="条款 17: 以独立语句将 new 创建的对象置入智能指针"></a>条款 17: 以独立语句将 new 创建的对象置入智能指针</h2><p>以独立语句将 new 创建的对象存储于(置入)智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏</p><h2 id="条款-18-让接口容易被正确使用，不易被误用"><a href="#条款-18-让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18: 让接口容易被正确使用，不易被误用"></a>条款 18: 让接口容易被正确使用，不易被误用</h2><h2 id="条款-19-设计-class-犹如设计-type"><a href="#条款-19-设计-class-犹如设计-type" class="headerlink" title="条款 19: 设计 class 犹如设计 type"></a>条款 19: 设计 class 犹如设计 type</h2><h2 id="条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款 20: 宁以 pass-by -reference-to-const 替换 pass-by-value"></a>条款 20: 宁以 pass-by -reference-to-const 替换 pass-by-value</h2><ul><li>尽量以 pass-by-reference-to-const 替换 pass-by-value 前者通常比较高效，并可避免切割问题 (slicing problem) </li><li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言， pass-by-value 往往比较适当。</li></ul><h2 id="条款-21-必须返回对象时，别妄想返回其-reference"><a href="#条款-21-必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21: 必须返回对象时，别妄想返回其 reference"></a>条款 21: 必须返回对象时，别妄想返回其 reference</h2><h2 id="条款-22-将成员变量声明为private（封装）"><a href="#条款-22-将成员变量声明为private（封装）" class="headerlink" title="条款 22: 将成员变量声明为private（封装）"></a>条款 22: 将成员变量声明为private（封装）</h2><h2 id="条款-23-宁以-non-member-non-friend-替换-member-函数"><a href="#条款-23-宁以-non-member-non-friend-替换-member-函数" class="headerlink" title="条款 23: 宁以 non-member non- friend 替换 member 函数"></a>条款 23: 宁以 non-member non- friend 替换 member 函数</h2><p>宁可拿 non-member non- friend 函数替换 member 函数。这样做可以增加封装性、包裹弹性 (packaging flexibility )和机能扩充性。</p><h2 id="条款-24-若所育参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款-24-若所育参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款 24 :若所育参数皆需类型转换，请为此采用 non-member 函数"></a>条款 24 :若所育参数皆需类型转换，请为此采用 non-member 函数</h2><h2 id="条款-25-考虑写出一个不抛异常的-swap-函数"><a href="#条款-25-考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25: 考虑写出一个不抛异常的 swap 函数"></a>条款 25: 考虑写出一个不抛异常的 swap 函数</h2><p>普通class写法如下：</p><p><img src="/2022/09/18/Effective-C/image-20220918213759699.png" alt="image-20220918213759699"></p><p>template class写法如下：</p><p><img src="/2022/09/18/Effective-C/image-20220918214019413.png" alt="image-20220918214019413"></p><ul><li>std: :swap 对你的类型效率不高时，提供一个swap 成员函数，并确定这个函数 不抛出异常。</li><li>如果你提供一个member swap，也该提供一个non-member swap 用来调用前者。对 classes (而非 templates) ，也请特化 std: :swap。</li><li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何”命 名空间资格修饰”。</li><li>为”用户定义类型”进行std templates 全特化是好的，但千万不要尝试在std 内加 入某些对 std 而言全新的东西。</li></ul><h2 id="条款-26-尽可能延后变量定义式的出现时间"><a href="#条款-26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26: 尽可能延后变量定义式的出现时间"></a>条款 26: 尽可能延后变量定义式的出现时间</h2><h2 id="条款-27-尽量少做转型动作"><a href="#条款-27-尽量少做转型动作" class="headerlink" title="条款 27: 尽量少做转型动作"></a>条款 27: 尽量少做转型动作</h2><h2 id="条款-28-避免返回-handles-指向对象内部成分"><a href="#条款-28-避免返回-handles-指向对象内部成分" class="headerlink" title="条款 28: 避免返回 handles 指向对象内部成分"></a>条款 28: 避免返回 handles 指向对象内部成分</h2><p>避免返回 handles (包括 references 、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const ，并将发生”虚吊号码牌” (dangling handles) 的可能性降至最低。</p><h2 id="条款-29-为”异常安全”而努力是值得的"><a href="#条款-29-为”异常安全”而努力是值得的" class="headerlink" title="条款 29: 为”异常安全”而努力是值得的"></a>条款 29: 为”异常安全”而努力是值得的</h2><ul><li>异常安全函数 (Exception-safe functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。</li><li>“强烈保证”往往能够以 copy-and-swap 实现出来，但”强烈保证”并非对所有函数都可实现或具备现实意义。</li><li>函数提供的”异常安全保证”通常最高只等于其所调用之各个函数的”异常安全保证”中的最弱者</li></ul><h2 id="条款-30-透彻了解-inlining-的里里外外"><a href="#条款-30-透彻了解-inlining-的里里外外" class="headerlink" title="条款 30: 透彻了解 inlining 的里里外外"></a>条款 30: 透彻了解 inlining 的里里外外</h2><ul><li>将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 (binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li><li>不要只因为 function templates 出现在头文件，就将它们声明为 inline。</li></ul><h2 id="条款-31-将文件间的编译依存关系降至最低（解耦合）"><a href="#条款-31-将文件间的编译依存关系降至最低（解耦合）" class="headerlink" title="条款 31: 将文件间的编译依存关系降至最低（解耦合）"></a>条款 31: 将文件间的编译依存关系降至最低（解耦合）</h2><h2 id="条款-32-确定你的-public-继承塑模出-is-a-关系"><a href="#条款-32-确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款 32: 确定你的 public 继承塑模出 is-a 关系"></a>条款 32: 确定你的 public 继承塑模出 is-a 关系</h2><h2 id="条款-33-避免遮掩继承而来的名称"><a href="#条款-33-避免遮掩继承而来的名称" class="headerlink" title="条款 33: 避免遮掩继承而来的名称"></a>条款 33: 避免遮掩继承而来的名称</h2><ul><li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有 人希望如此。</li><li>为了让被遮掩的名称再见天日，可使用 using 声明式或转变函数(forwarding functions)</li></ul><h2 id="条款-34-区分接口继承和实现继承"><a href="#条款-34-区分接口继承和实现继承" class="headerlink" title="条款 34: 区分接口继承和实现继承"></a>条款 34: 区分接口继承和实现继承</h2><ul><li>接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。</li><li>virtual 函数只具体指定接口继承。</li><li>简朴的(非纯) impure virtual 函数具体指定接口继承及缺省实现继承。</li><li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li></ul><h2 id="条款-35-考虑-virtual-函数以外的其他选择（涉及到设计模式）"><a href="#条款-35-考虑-virtual-函数以外的其他选择（涉及到设计模式）" class="headerlink" title="条款 35: 考虑 virtual 函数以外的其他选择（涉及到设计模式）"></a>条款 35: 考虑 virtual 函数以外的其他选择（涉及到设计模式）</h2><ul><li>virtual 函数的替代方案包括 NYl 手法及 Strategy 设计模式的多种形式。 NYI 手法（non-virtual interface) ）自身是一个特殊形式的 Template Method 设计模式。</li><li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访 class non-public 成员。 </li><li>trl::function 对象的行为就像一般函数指针。这样的对象可接纳”与给定之目标签名式 (target signature) 兼容”的所有可调用物 (callable entities)</li></ul><h2 id="条款-36-绝不重新定义继承而来的-non-virtual-函数"><a href="#条款-36-绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款 36: 绝不重新定义继承而来的 non-virtual 函数"></a>条款 36: 绝不重新定义继承而来的 non-virtual 函数</h2><h2 id="条款-37-绝不重新定义继承而来的缺省参数值"><a href="#条款-37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37: 绝不重新定义继承而来的缺省参数值"></a>条款 37: 绝不重新定义继承而来的缺省参数值</h2><p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数一一你唯一应该覆写的东西一一却是动态绑定。</p><h2 id="关于私有虚函数的相关问题"><a href="#关于私有虚函数的相关问题" class="headerlink" title="关于私有虚函数的相关问题"></a>关于私有虚函数的相关问题</h2><ol><li>编译器不检查虚函数的各类属性。</li><li>编译器在编译子类成员函数时，会先查询父类，如果存在非虚函数，则隐藏父类函数。如果存在虚函数，则重写该位置的虚函数。此时你又可以赋予该函数在该类中的各种属性（例如public）。</li><li>私有只是让子类不能访问父类，仅此而已，对其他规则没限制，也就是说可以重写（覆盖）。</li></ol><h2 id="条款-38-通过复合塑模出-has-a-或”根据某物实现出”"><a href="#条款-38-通过复合塑模出-has-a-或”根据某物实现出”" class="headerlink" title="条款 38: 通过复合塑模出 has-a 或”根据某物实现出”"></a>条款 38: 通过复合塑模出 has-a 或”根据某物实现出”</h2><ul><li>复合(composition，也称为聚合) 的意义和 public 继承完全不同。</li><li>在应用域 (application domain) ，复含意味 has-a (有一个)。在实现域 (implementation domain) ，复合意味is-implemented-in-terms-of(根据某物实现出)。</li></ul><h2 id="条款-39-明智而审慎地使用-private-继承"><a href="#条款-39-明智而审慎地使用-private-继承" class="headerlink" title="条款 39: 明智而审慎地使用 private 继承"></a>条款 39: 明智而审慎地使用 private 继承</h2><ul><li>尽可能使用public继承加复合，必要时才使用 private 继承</li><li>Private 继承意味 is-implemented-in-terms of (根据某物实现出)。它通常比复合 (composition) 的级别低。但是当 derived class 需要访问 prot ted base class 成员，或需要重新定义继承而来的virtual 函数时，这么设计是合理的。</li><li>和复合(composition) 不同， private 继承可以造成 empty base 最优化。这对致 力于”对象只寸最小化”的程序库开发者而言，可能很重要。</li></ul><h2 id="条款-40-明智而审慎地使用多重继承"><a href="#条款-40-明智而审慎地使用多重继承" class="headerlink" title="条款 40: 明智而审慎地使用多重继承"></a>条款 40: 明智而审慎地使用多重继承</h2><ul><li><strong>C++ 用来解析 (resolving) 重载函数调用的规则</strong>：看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。 找出最佳匹配函数后才检验其可取用性。</li><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li><li>virtual 继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及”public 继承某个 Interface class”和 “private 继承某个协助实现的class” 的两相组合。</li></ul><h2 id="条款-41-了解隐式接口和编译期多态"><a href="#条款-41-了解隐式接口和编译期多态" class="headerlink" title="条款 41: 了解隐式接口和编译期多态"></a>条款 41: 了解隐式接口和编译期多态</h2><ul><li>classes templates 都支持接口(interfaces) 和多态 (polymorphism)</li><li>对 classes 而言接口是显式的 (explicit) .以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li><li>对 template 参数而言，接口是隐式的(implicit) .奠基于有效表达式。多态则是通过 template 具现化和函数重载解析( function overloading resolution) 发生于编译期</li></ul><h2 id="条款-42-了解-typename-的双重意义"><a href="#条款-42-了解-typename-的双重意义" class="headerlink" title="条款 42: 了解 typename 的双重意义"></a>条款 42: 了解 typename 的双重意义</h2><ul><li>声明 template 参数时，前缀关键字class typenarne可互换。</li><li>请使用关键字typenarne标识嵌套从属类型名称:但不得在base class lists (基类列，继承时出现在<code>:</code>后面的基类列表）或 member initialization list (成员初始化列表）内以它作为 base class 修饰符。</li></ul><h2 id="条款-43-学习处理模板化基类内的名称"><a href="#条款-43-学习处理模板化基类内的名称" class="headerlink" title="条款 43: 学习处理模板化基类内的名称"></a>条款 43: 学习处理模板化基类内的名称</h2><p>可在 derived class templates 内通过” this-&gt;” 指涉 base class templates 内的成员 名称，或藉由一个明白写出的 “base class 资格修饰符”完成，前一种方法更好，如果调用的是虚函数后一种方法丢失了多态性</p><h2 id="条款-44-将与参数无关的代码抽离templates"><a href="#条款-44-将与参数无关的代码抽离templates" class="headerlink" title="条款 44: 将与参数无关的代码抽离templates"></a>条款 44: 将与参数无关的代码抽离templates</h2><h2 id="条款-45-运用成员函数模板接受所有兼容类型"><a href="#条款-45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45: 运用成员函数模板接受所有兼容类型"></a>条款 45: 运用成员函数模板接受所有兼容类型</h2><ul><li>请使用 member function templates (成员函数模板）生成”可接受所有兼容类型”的函数。</li><li>如果你声明 member templates 用于”泛化 copy 构造”或”泛化 assignment操作” 你还是需要声明正常的copy构造函数和 copy assignment 操作符。</li></ul><h2 id="条款-46-需要类型转换时请为模板定义非成员函数"><a href="#条款-46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46: 需要类型转换时请为模板定义非成员函数"></a>条款 46: 需要类型转换时请为模板定义非成员函数</h2><p>当我们编写一个 class template，而它所提供之”与此 template 相关的”函数支持”所有参数之隐式类型转换”时，请将那些函数定义为” class template 内部的friend 函数”。</p><h2 id="条款-47-请使用-traits-classes-表现类型信息（个人感觉有点像反射）"><a href="#条款-47-请使用-traits-classes-表现类型信息（个人感觉有点像反射）" class="headerlink" title="条款 47: 请使用 traits classes 表现类型信息（个人感觉有点像反射）"></a>条款 47: 请使用 traits classes 表现类型信息（个人感觉有点像反射）</h2><ul><li>Traits classes 使得”类型相关信息”在编译期可用。它们以templates 和 “templates 特化”完成实现。</li><li>整合重载技术(overloading) 后， traits classes 有可能在编译期对类型执行 if…else 测试。</li></ul><h2 id="条款-48-认识-template-元编程"><a href="#条款-48-认识-template-元编程" class="headerlink" title="条款 48: 认识 template 元编程"></a>条款 48: 认识 template 元编程</h2><ul><li>Template metaprogramming (TMP，模板元编程)可将工作由运行期移往编译期， 因而得以实现早期错误侦测和更高的执行效率。</li><li>TMP 可被用来生成”基于政策选择组合” (based on combinations of policy choices) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><h2 id="条款-49-了解new-handler的行为"><a href="#条款-49-了解new-handler的行为" class="headerlink" title="条款 49:了解new-handler的行为"></a>条款 49:了解new-handler的行为</h2><h2 id="条款-50-了解-new-和-delete-的合理替换时机"><a href="#条款-50-了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50: 了解 new 和 delete 的合理替换时机"></a>条款 50: 了解 new 和 delete 的合理替换时机</h2><h2 id="条款-51-编写-new-delete-时需固守常规"><a href="#条款-51-编写-new-delete-时需固守常规" class="headerlink" title="条款 51: 编写 new delete 时需固守常规"></a>条款 51: 编写 new delete 时需固守常规</h2><h2 id="条款-52-写了-placement-new-也要写-placement-delete"><a href="#条款-52-写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52: 写了 placement new 也要写 placement delete"></a>条款 52: 写了 placement new 也要写 placement delete</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++高级程序设计</title>
      <link href="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20220913112451688.png" alt="image-20220913112451688"></p><h1 id="1-结构化程序设计部分"><a href="#1-结构化程序设计部分" class="headerlink" title="1. 结构化程序设计部分"></a>1. 结构化程序设计部分</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><p><code>int x=8;</code> x的取值范围被称为值集</p><p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20220915121433553.png" alt="image-20220915121433553"></p><span id="more"></span><h1 id="2-作业部分"><a href="#2-作业部分" class="headerlink" title="2. 作业部分"></a>2. 作业部分</h1><h2 id="2-1-判断int是否溢出"><a href="#2-1-判断int是否溢出" class="headerlink" title="2.1 判断int是否溢出"></a>2.1 判断int是否溢出</h2><h3 id="2-1-1-用INT-MAX"><a href="#2-1-1-用INT-MAX" class="headerlink" title="2.1.1 用INT_MAX"></a>2.1.1 用INT_MAX</h3><p>INT_MAX这个宏定义了int的最大值，用long long来定义结果变量，如果得到的结果大于INT_MAX则发生了溢出，不能用int定义结果变量，因为是int类型，就算发生了溢出也会截断一些位来使变量保持在int范围内（溢出会发生未定义的行为），所以int类型的变量永远不可能超过INT_MAX。</p><h3 id="2-1-2-用数学方法"><a href="#2-1-2-用数学方法" class="headerlink" title="2.1.2 用数学方法"></a>2.1.2 用数学方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">964632435</span>;</span><br><span class="line">a = a * <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;<span class="comment">//1056389758</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不能通过这样的简单的判断逻辑来进行，发生了溢出，数据已经改变了，不能用改变后的数据（改变后的数据一定是通过了一些丢位操作，使得数值在Int类型的范围内，其实这是未定义的行为）去判断该数值是否溢出。</p><p>思想：相加的结果与其中一个数相减，与另一个数比较看是否相等；相乘除的结果和乘除的因子相反操作，和原来的数值进行比较看是否相等。</p><h2 id="2-2-最小公倍数和最大公约数"><a href="#2-2-最小公倍数和最大公约数" class="headerlink" title="2.2 最小公倍数和最大公约数"></a>2.2 最小公倍数和最大公约数</h2><p><strong>两个数的乘积等于这两个数的最大公约数与最小公倍数的积</strong>，可以用欧几里得算法求出最大公约数进而得出最小公倍数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a%b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    <span class="keyword">while</span>(a%b != <span class="number">0</span>)&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp%b;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-C-的类"><a href="#2-3-C-的类" class="headerlink" title="2.3 C++的类"></a>2.3 C++的类</h2><h3 id="2-3-1-拷贝控制"><a href="#2-3-1-拷贝控制" class="headerlink" title="2.3.1 拷贝控制"></a>2.3.1 拷贝控制</h3><p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221029162402898.png" alt="image-20221029162402898"></p><h1 id="3-机考复习"><a href="#3-机考复习" class="headerlink" title="3. 机考复习"></a>3. 机考复习</h1><h2 id="3-1-输入"><a href="#3-1-输入" class="headerlink" title="3.1 输入"></a>3.1 输入</h2><p>split函数的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string str, <span class="type">char</span> delimiter)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; strVec;</span><br><span class="line">    <span class="comment">// show,,me,,</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != delimiter) &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; str.<span class="built_in">size</span>() &amp;&amp; str[j] != delimiter; ++j) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            string temp=str.<span class="built_in">substr</span>(i,j-i);</span><br><span class="line">            strVec.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string 头文件中有stoi、stod、stof等函数，可以方便的将字符串转为数字类型。</p><h2 id="3-2-STL的使用"><a href="#3-2-STL的使用" class="headerlink" title="3.2 STL的使用"></a>3.2 STL的使用</h2><p>std::priority_queue 优先队列的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******** 定义类时同时定义操作符重载函数 ********/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 要比较的元素</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Node1</span>(<span class="type">int</span> x) &#123; <span class="keyword">this</span>-&gt;x = x; &#125;</span><br><span class="line">    <span class="comment">// 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node1 &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现less中需要的&lt;,大顶堆</span></span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******** 自定义类，自定义比较函数 ********/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 要比较的元素</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Node2</span>(<span class="type">int</span> x) &#123; <span class="keyword">this</span>-&gt;x = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载函数，必须是具体的操作符&lt;之类的，写()报错</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node2 &amp;a, <span class="type">const</span> Node2 &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// less,大顶堆</span></span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******** 自定义类，自定义包含比较函数的结构体 ********/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node3</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 要比较的元素</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Node3</span>(<span class="type">int</span> x) &#123; <span class="keyword">this</span>-&gt;x = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmpClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 操作符重载函数，必须是写()</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node3 &amp;a, <span class="type">const</span> Node3 &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// less,大顶堆</span></span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/******** 初始化优先级队列的对象p ********/</span></span><br><span class="line">    <span class="comment">// Node1类型，默认使用vector，大顶堆，同 priority_queue&lt;Node1, vector&lt;Node1&gt;, less&lt;Node1&gt; &gt; p;</span></span><br><span class="line">    priority_queue&lt;Node1&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序入队</span></span><br><span class="line">    p.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">    p.<span class="built_in">emplace</span>(<span class="number">3</span>);</span><br><span class="line">    p.<span class="built_in">emplace</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队首</span></span><br><span class="line">    <span class="keyword">while</span> (!p.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******** 初始化优先级队列的对象q ********/</span></span><br><span class="line">    <span class="comment">// 同 priority_queue&lt;Node2&gt; q;</span></span><br><span class="line">    priority_queue&lt;Node2, vector&lt;Node2&gt;, less&lt;Node2&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序入队</span></span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队首</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******** 初始化优先级队列的对象r ********/</span></span><br><span class="line">    priority_queue&lt;Node3, vector&lt;Node3&gt;, cmpClass&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱序入队</span></span><br><span class="line">    r.<span class="built_in">emplace</span>(<span class="number">1</span>);</span><br><span class="line">    r.<span class="built_in">emplace</span>(<span class="number">3</span>);</span><br><span class="line">    r.<span class="built_in">emplace</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出队首</span></span><br><span class="line">    <span class="keyword">while</span> (!r.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; r.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        r.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/image-20221109145041019.png" alt="image-20221109145041019"></p><p><img src="/image-20221109145051045.png" alt="image-20221109145051045"></p><h2 id="3-3-sort算法的使用"><a href="#3-3-sort算法的使用" class="headerlink" title="3.3 sort算法的使用"></a>3.3 sort算法的使用</h2><p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221203203558831.png" alt="image-20221203203558831"></p><p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221203203614506.png" alt="image-20221203203614506"></p><p><img src="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20221204121728590.png" alt="image-20221204121728590"></p><h1 id="4-面向对象部分"><a href="#4-面向对象部分" class="headerlink" title="4. 面向对象部分"></a>4. 面向对象部分</h1><p><img src="/image-20221220112402021.png" alt="image-20221220112402021"></p><p><img src="/image-20221220112817218.png" alt="image-20221220112817218"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记2</title>
      <link href="/2022/09/11/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/09/11/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><p><strong>方法一</strong>：递归</p><p>其实就是交换一下左右节点，然后再递归的交换左节点，右节点我们可以总结出递归的两个条件如下：</p><p>终止条件：当前节点为 null 时返回<br>交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp;</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：迭代</p><p>递归实现也就是深度优先遍历的方式，迭代使用广度优先遍历，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：</p><p>判断其左子树是否为空，不为空就放入队列<br>判断其右子树是否为空，不为空就放入队列</p><p>这样其实也是实现了二叉树的<strong>层序遍历</strong></p><span id="more"></span><h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h1><p><strong>思路</strong></p><ol><li>复制链表值到数组列表中。</li><li>使用双指针法判断是否为回文。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    <span class="keyword">while</span> (head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vals.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这里是i&lt;j，当i=j时一定是回文（都能使i和j重合证明前面的字母都是回文，</span></span><br><span class="line">    <span class="comment">//最后剩中间一个字母一定是回文的），如果i&gt;j那么就是偶数，此前的判断已经证明是回文了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j=(<span class="type">int</span>)vals.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; j; ++i,--j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals[i]!=vals[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><p><strong>方法一</strong>：递归</p><p><strong>思路</strong></p><p>若 root 是 p, q的 最近公共祖先 ，则只可能为以下情况之一：</p><ol><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p&#x3D;root ，且 q 在 root 的左或右子树中；</li><li>q&#x3D;root ，且 p 在 root 的左或右子树中；</li></ol><p>定义fx 表示 x 节点的子树中是否包含 p 节点或 q 节点，如果包含为 true，否则为 false。那么符合条件的最近公共祖先 x 一定满足如下条件（下面这个式子也可对应上面说的三种情况）：</p><p><code>(lson &amp;&amp; rson) || ((root==p||root==q)&amp;&amp;(lson||rson))</code></p><p>其中 lson 和 rson 分别代表 x 节点的左孩子和右孩子。初看可能会感觉条件判断有点复杂，我们来一条条看，(lson &amp;&amp; rson) 说明左子树和右子树均包含 p 节点或 q 节点，如果左子树包含的是 p 节点，那么右子树只能包含 q 节点，反之亦然，因为 p 节点和 q 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 x 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 x 恰好是 p 节点或 q 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 x 就是我们要找的最近公共祖先。</p><p>你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为<strong>我们是自底向上从叶子节点开始更新的</strong>，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到，且由于 fx 本身的定义很巧妙，在找到最近公共祖先 x 以后，按定义被设置为 true ，在向上回溯的过程中，其他结点一定不会满足最近公共祖先的条件了，因此其他公共祖先不会再被判断为符合条件。</p><p>dfs成立的条件比较容易想到，就不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *ans;</span><br><span class="line"><span class="comment">// dfs 表示以 root 节点为根结点的树中是否包含 p 节点或 q 节点，如果包含为 true，否则为 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="type">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">//这是最近公共祖先的条件</span></span><br><span class="line">    <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root==p||root==q)&amp;&amp;(lson||rson)))&#123;</span><br><span class="line">        ans=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是dfs成立的条件</span></span><br><span class="line">    <span class="keyword">return</span> lson||rson||root-&gt;val==p-&gt;val||root-&gt;val==q-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root,p,q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：存储父节点</p><p><strong>思路</strong></p><p>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p  结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</p><p><strong>算法</strong></p><ol><li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li><li>从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li><li>同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, TreeNode *&gt; father;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; visited;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        father[root-&gt;left-&gt;val] = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        father[root-&gt;right-&gt;val] = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里把根结点的父节点设为nullptr</span></span><br><span class="line">    father[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        visited[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">        p = father[p-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[q-&gt;val])&#123;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        q=father[q-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法分析</title>
      <link href="/2022/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第一课"><a href="#1-第一课" class="headerlink" title="1. 第一课"></a>1. 第一课</h1><p>面向对象：封装、继承、多态。模块与模块之间尽量解耦合</p><h1 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h1><p>约瑟夫环问题（<strong>递归解法</strong>）</p><p>假设：</p><p>初始情况： 0, 1, 2 ……n-2, n-1 (共n个人)</p><p> 第一个人(编号一定是(m-1)%n,设之为(k-1) ) 出列之后，</p><p>剩下的n-1个人组成了一个新的约瑟夫环（以编号为k&#x3D;&#x3D;m%n的人开始）:</p><p> k  k+1  k+2  … n-2, n-1, 0, 1, 2, …,k-3, k-2 </p><p>现在我们把他们的编号做一下转换：</p><p>x -&gt; x’   （x‘代表新编号，x代表原编号  k&#x3D;&#x3D;m%n）</p><p>k   –&gt; 0<br>k+1  –&gt; 1<br>k+2  –&gt; 2<br>…<br>…</p><p>k-3  –&gt; n-3</p><p>k-2  –&gt; n-2</p><p>变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x’是最终的胜利者，那么根据上面这个表把这个x’变回去不刚好就是n个人情况的解吗！<br>x’ -&gt;ｘ？(这正是从n-1时的结果反过来推n个人时的编号！)<br>0 -&gt; k</p><p>1 -&gt; k+1</p><p>2 -&gt; k+2</p><p>…</p><p>…</p><p>n-3 -&gt; k-3</p><p>n-2 -&gt; k-2</p><p>变回去的公式　x&#x3D;(x’+k)%n</p><p>那么，如何知道(n-1)个人报数的问题的解？只要知道(n-2)个人的解就行了。(n-2)个人的解呢？只要知道(n-3)的情况就可以了 —- 这显然就是一个递归问题：</p><p>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果就是f[n]</p><p>递推公式</p><p>f[1]&#x3D;0;</p><p>f[n]&#x3D;(f[n-1]+k)%n &#x3D; (f[n-1] +m%n) % n &#x3D; (f[n-1] + m) % n ;  (n&gt;1)</p><p>当然，当n&#x3D;&#x3D;1时，直接返回0即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h1><h1 id="4-栈、队列"><a href="#4-栈、队列" class="headerlink" title="4.栈、队列"></a>4.栈、队列</h1><h2 id="4-1-数组循环左移"><a href="#4-1-数组循环左移" class="headerlink" title="4.1 数组循环左移"></a>4.1 数组循环左移</h2><p>假设数组a[7]&#x3D;{1,2,3,4,5,6,7}，向左移3个元素，输出结果为：4 5 6 7 1 2 3</p><p><strong>对前3个元素逆序，变为{3,2,1,4,5,6,7}</strong></p><p><strong>对后4个元素逆序，变为{ 3,2,1,7,6,5,4 }</strong></p><p><strong>对所有元素逆序，变为{ 4,5,6,7,1,2,3 }</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ster...end)，左边包含右边不包含</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> ster, <span class="type">int</span> end)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s = end - <span class="number">1</span>;        <span class="comment">//起始位置下标不变，终止位置-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ster &lt; s)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        temp = a[ster];</span><br><span class="line"></span><br><span class="line">        a[ster] = a[s];</span><br><span class="line"></span><br><span class="line">        a[s] = temp;</span><br><span class="line"></span><br><span class="line">        ster++;</span><br><span class="line"></span><br><span class="line">        s--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, k, a[<span class="number">7</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;先输入左移个数：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">    reverse(a, <span class="number">0</span>, k);</span><br><span class="line"></span><br><span class="line">    reverse(a, k, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    reverse(a, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-表达式树"><a href="#4-2-表达式树" class="headerlink" title="4.2 表达式树"></a>4.2 表达式树</h2><p><a href="https://blog.csdn.net/Amentos/article/details/127182926">《数据结构》：中缀表达式转后缀表达式 后缀表达式的计算</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组织与体系结构</title>
      <link href="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20220906193405111.png" alt="image-20220906193405111"></p><h1 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="1. 整数除法"></a>1. 整数除法</h1><p>关于整数除法<strong>固有bug的一些解释</strong>。</p><p>固有bug就是结果的余数和除数相等或互为相反数。</p><p>对于这个不恢复余数的除法，我其实是有点困惑它的正确性如何成立的。经过一些思考，得出了一些或许可以增进一些理解的解释。首先我们考虑被除数和除数都是正数的情况，按照不恢复余数除法的上商规则，不难得出其实每一位商都会是正确的，因为上商判断时依据的也是新算出来的余数，也就是是否够减。但是最后的余数可能会有偏差，如果最后一步是不够减的，上商为0之后本来应该要在下一步实现恢复的，但是没有下一步了，因此我们要将余数加上一个被除数。两个负数相除的情形是类似的。但是需要注意的是一个负数除以它本身的情形，比如-8&#x2F;（-8），算的时候我们得到-8 - 1*（-8）&#x3D; 0，这时候如果看位串的符号位来说是变号了的，应该上商是0，然后余数现在也是0，但是在修正余数的时候由于0和-8符号位不同，要加上一个-8，余数变成-8，这显然是不合理的。对于这种情况需要加一个修正，即如果余数等于除数，那么余数减去除数，商加1。</p><p>再考虑不同符号的数的除法，比如 -8&#x2F;3, 在这里要清楚其实不恢复余数的除法本质上还是恢复了余数，只不过和下一步的试商合在一起了。注意到<strong>上商的时候的判断标准和恢复余数的除法是不同的</strong>，不恢复余数的除法看的是<strong>是否和除数同号</strong>，这导致了本来该上 1 的地方现在上了 0，本来该上 0 的地方现在上了 1，相当于取反的效果，因此最后需要修正商，加一，合起来达到了取补码的效果。对于这种情况下余数修正的判断，如果最后余数符号和被除数相同，那么不需要修正，如果变了号，说明最后加过头了，但是没有下一轮来恢复了，这时需要减去一个除数。</p><p>但是在不同符号数相除的情形当中仍然有一个 bug，那就是正数除以负数且能整除的情况。比如 -8&#x2F;2 ，我们会得到结果商为 -3,余数为 -2。试了一下，<strong>当被除数为负数，除数为正数，且可以整除的时候</strong>会出现这种情况。这时需要加一个特判修正，如果余数加上除数为0，那么商减一余数置0 。</p><h1 id="2-一些单位"><a href="#2-一些单位" class="headerlink" title="2. 一些单位"></a>2. 一些单位</h1><p>我们目前所用的K、M、G、T等都是英文表示方法，分别是Kilo（10^3 )、Mega（10^6 ）、Giga（10^9 ）、Tera（10^12 ）的简写，更大的还有Peta（10^15 ）、Exa（10^18 ）、Bronto（10^21 ）等。</p><h1 id="3-机考注意点"><a href="#3-机考注意点" class="headerlink" title="3. 机考注意点"></a>3. 机考注意点</h1><h2 id="3-1-整数除法固有bug"><a href="#3-1-整数除法固有bug" class="headerlink" title="3.1 整数除法固有bug"></a>3.1 整数除法固有bug</h2><p>如果余数等于除数，那么余数减去除数，商加1。如果余数加上除数为0，那么商减一余数置0 。</p><h2 id="3-2-原码整数乘法"><a href="#3-2-原码整数乘法" class="headerlink" title="3.2 原码整数乘法"></a>3.2 原码整数乘法</h2><p>注意进位参与结果右移。</p><p><img src="/image-20221210223840600.png" alt="image-20221210223840600"></p><h2 id="3-2-浮点数相除"><a href="#3-2-浮点数相除" class="headerlink" title="3.2 浮点数相除"></a>3.2 浮点数相除</h2><p>尾数相除时，用被除数加上除数的补码来判断是否够减，如果结果最高位是1就不够减，是0就够减。</p>]]></content>
      
      
      <categories>
          
          <category> 计组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SE-1 Review</title>
      <link href="/2022/09/06/SE-1-Review/"/>
      <url>/2022/09/06/SE-1-Review/</url>
      
        <content type="html"><![CDATA[<h1 id="Python部分"><a href="#Python部分" class="headerlink" title="Python部分"></a>Python部分</h1><ol><li><p>parameter是形参，argument是实参。</p></li><li><p>title() 方法返回一个字符串，其中每个单词的第一个字符均为大写。如果单词包含数字或符号，则其后的第一个字母将转换为大写字母。</p></li><li><p>换零钱问题（递归、动态规划）：给定半美元、25美分、10美分、5美分、1美分 5种硬币，将 1 美元换成硬币，有多少种硬币组合？<br>给定任意数量的现金 和 任意组合的硬币种类，计算换零钱所有方式的种数。</p><p>10 美分能够用到的硬币种类只有<code>[10, 5, 1]</code>三种。我们用 <code>10$[10, 5, 1]</code>这种记法来标记问题。先按币值为10的硬币来分类，将问题化为：</p><ol><li><p>第一组，不使用 10 美分的硬币来表示，只用5美分和1美分来表示 即 <code>10$[5, 1]</code></p></li><li><p>第二组，使用了 10 美分的硬币，剩下的金额 0 使用全部的硬币种类表示，即 <code>0$[10, 5, 1]</code></p><p><code>10$[10, 5, 1] = 10$[5, 1] + 0$[10, 5, 1]           = 10$[1] + 5$[5, 1] + 0$[10, 5, 1]           = 10$[1] + 5$[1] + 0$[5, 1] + 0$[10, 5, 1]</code></p></li></ol><p>分成两组后，这两个问题新问题相对于原问题的范围缩小了，第一组现金没有变，但可选的硬币种类少了一种；第二组硬币种类没有变，但是现金减少了第一种硬币的币值。</p><p>边界问题如下：</p><ul><li>当现金数 <code>a</code> 为 0 时，应该算作是有 1 种换零钱的方法</li><li>当现金数 <code>a</code> 小于 0 时，应该算作是有 0 种换零钱的方法</li><li>当换零钱可选的硬币种类为 0 时，应该算作是有 0 种换零钱的方法</li></ul><p>按边界规则，可以直观看出，当金额为 0 或可选币种只有 1 种时，组合数都为 1。</p><p>一定要<strong>小心边界出口</strong>，仔细考虑设计边界条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- coding = utf-8 --</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_change</span>(<span class="params">amount, coins_list</span>):</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> amount &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> coins_list: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        part1 = count_change(amount, coins_list[<span class="number">1</span>:])</span><br><span class="line">        part2 = count_change(amount-coins_list[<span class="number">0</span>], coins_list[:])</span><br><span class="line">    <span class="keyword">return</span> part1 + part2</span><br><span class="line"></span><br><span class="line">us_coins = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">50</span>]</span><br><span class="line"><span class="built_in">print</span>(count_change(<span class="number">100</span>, us_coins)</span><br></pre></td></tr></table></figure><p>没有硬币种类换就返回0，amount&lt;0防止</p><p>50$[20,10,5,1]-&gt;30$[20,10,5,1] - &gt;10$[20,10,5,1]-&gt;10$[20,10,5,1]</p></li><li><p>思考递归问题时，先将其分解为几个子问题，然后分别判断这几个子问题在哪些方面缩减了问题的规模，以此来考虑边界情况。</p></li><li><p>在 <a href="http://c.biancheng.net/python/">Python</a> 中，有一个特殊的常量 None（N 必须大写）。和 False 不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。这里的空值并不代表空对象，即 None 和 []、“” 不同。</p><span id="more"></span></li><li><p><strong>sort()</strong> 函数用于对原列表进行排序，会改变原列表中数据的顺序，sorted 可以对所有可迭代的对象进行排序操作， sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p></li><li><p>对字符串的操作方法都不会改变原来字符串的值，下面是一些常用的字符串方法：</p><p>1.去掉空格和特殊符号<br>name.strip() 去掉空格和换行符<br>name.strip(‘xx’) 去掉某个字符串<br>name.lstrip() 去掉左边的空格和换行符<br>name.rstrip() 去掉右边的空格和换行符<br>2.字符串的搜索和替换<br>name.count(‘x’) 查找某个字符在字符串里面出现的次数<br>name.capitalize() 首字母大写<br>name.center(n,’-’) 把字符串放中间，两边用- 补齐<br>name.find(‘x’) 找到这个字符返回下标，多个时返回第一个；不存在的字符返回-1<br>name.index(‘x’) 找到这个字符返回下标，多个时返回第一个；不存在的字符报错<br>name.replace(oldstr, newstr) 字符串替换<br>name.format（） 字符串格式化<br>name.format_map(d) 字符串格式化，传进去的是一个字典<br>3.字符串的分割<br>name.split() 默认是按照空格分割<br>name.split(’,’) 按照逗号分割</p><p>str.upper()用法：将字符串全部变成大写<br>str.lower()用法：将字符串全部变成小写<br>string.split(text)#字符串分割?<br>string.join(string.split(text), “+”)#字符串连接?<br>string.replace(text, “Python”, “Java”)#字符串替换?<br>string.count(text, “n”)#字符串计数?<br>string.find(text, “Python”), string.find(text,“Java”)#字符串查找</p></li><li><p>要学会从题目中抽象出一些东西来，而不是按照题目给的要求来模拟，不要被题目说的那些方法步骤所局限，要跳出题目给的方法和步骤，想一想能不能从另一个角度来思考这个问题，或者说用另一种方式来模拟这个题目，有时候可以直接根据题目文字来模拟，有时候要抽象一下题目给的条件，用另一种方式来模拟或者是计算，解题两种路径<strong>模拟</strong>和<strong>计算</strong></p></li><li><p>比较两个列表：</p><ol><li><p>“&#x3D;&#x3D;”只有成员、成员位置都相同时才返回True，但有时候我们希望只要成员相同、即使成员位置不同也能返回True，可以使用列表sort()方法进行排序后比较，注意sort()会改变原列表。sorted()不改变列表原本顺序而是新生成一个排序后的列表并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(list1)==<span class="built_in">sorted</span>(list2)</span><br></pre></td></tr></table></figure></li><li><p>包含比较</p><p>直接用列表本身进行包含类比较，只能用遍历的方法这是比较麻烦的，使用set()转成集合进行包含比较就简单多了。</p><ul><li>判断列表是否包含另一列表</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;four&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list1).issubset(<span class="built_in">set</span>(list2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list2).issuperset(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure><ul><li>求交集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;five&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;four&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list1).intersection(<span class="built_in">set</span>(list2))</span><br></pre></td></tr></table></figure><ul><li>获取两个列表不同成员</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;five&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;four&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list1).symmetric_difference(<span class="built_in">set</span>(list2))</span><br></pre></td></tr></table></figure><ul><li>获取一个列表中不是另一个列表成员的成员（差集）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;five&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;four&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list1).difference(<span class="built_in">set</span>(list2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list2).difference(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure><ul><li>求并集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;five&quot;</span>]</span><br><span class="line"></span><br><span class="line">list2= [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;four&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(list1).union(<span class="built_in">set</span>(list2))</span><br></pre></td></tr></table></figure></li></ol></li><li><p>string.format方法，<code>print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))</code></p></li></ol><p>   {:.2f} 保留小数点后两位</p><p>   {:+.2f} 带符号保留小数点后两位</p><p>   {:0&gt;2d} 数字补零 (填充左边, 宽度为2)</p><p>   {:x&lt;4d} 数字补x (填充右边, 宽度为4)</p><h1 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h1><ol><li>一道我没做起的Java简单题</li></ol><h5 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h5><p>​写一个程序来检测一个整数是不是丑数。</p><p>​丑数的定义是，只包含质因子 2, 3, 5 的正整数。比如 6, 8 就是丑数，但是 14 不是丑数因为他包含了质因子 7。</p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>​可以认为 1 是一个特殊的丑数。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>​给出 num &#x3D; 8，返回 true。 给出 num &#x3D; 14，返回 false。</p><p>​<strong>思路</strong>：只包含质因子2 3 5意味着该数可以被分解为2<sup>x</sup> * 3<sup> y</sup> * 5<sup>z</sup>,使 sum 依次对 2, 3, 5 相除，直到与 2, 3, 5 的余数不为 0，最终 sum 为 1，则代表该数只能被 2, 3, 5整除，返回 <code>true</code>，反之返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">//0也需要特殊判断，但题目说了是正整数</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num=num/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num=num/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num=num/<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>手动实现Java的trim函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="comment">//String abc = &quot;   a b c ddsa    &quot;;</span></span><br><span class="line">    <span class="comment">//在遍历中其实我们只需要获得第一个和最后一个不为空格的字符的下标</span></span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(start,end+<span class="number">1</span>);<span class="comment">//substring不包含后一个参数，所以需要+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正则表达式：*表示匹配前面的字符0次或多次，+表示1次或多次，？表示0次或1次，{n}匹配确定的n次，{n，}匹配至少n次，{n，m}匹配n到m次两边都包含</p></li></ol><h1 id="转专业考试复习"><a href="#转专业考试复习" class="headerlink" title="转专业考试复习"></a>转专业考试复习</h1><ol><li><p>高阶函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighOrderFunction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cube</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*x*x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算a到b的立方和（包含b）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fCube</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cube(a)+fCube(a+<span class="number">1</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">piTerm</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>/(x*(x+<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">piNext</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算1/(1*3)+1/(5*7)+1/(9*11)……序列和，从a到b（包含b）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sumPi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> piTerm(a)+sumPi(piNext(a),b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fCube(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(sumPi(<span class="number">1</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="VJAM实验报告"><a href="#VJAM实验报告" class="headerlink" title="VJAM实验报告"></a>VJAM实验报告</h1>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软工 </tag>
            
            <tag> Python </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>review on java</title>
      <link href="/2022/09/06/review-on-java/"/>
      <url>/2022/09/06/review-on-java/</url>
      
        <content type="html"><![CDATA[<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><ol><li><p>静态方法不能访问某一对象的实例域，因为它不能操作对象，但静态的方法可以访问自身类中的静态域</p></li><li><p>在下面两种情况下使用静态方法：一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow（)）；一个方法只需要访问类的静态域</p></li><li><p><strong>Scanner类的一些知识点</strong>：next()方法如果没有扫描读入非空格或非回车字符是不会创建String对象并返回的，并且next()遇到空格或者说\t或者是回车都会结束扫描；nextLine():读取输入，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行（会忽略掉末尾的回车进入下一行开始扫描）。所以它和next()的区别就是它没有分隔符，直接扫描全部的键盘输入内容，并创建对象进行将其引用返回。</p><p>Scanner类还可以用来<strong>读取文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(fileName));<span class="comment">//注意传入的是File</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Scanner对象中hasNext()方法来判断文件是否读取完毕，另外一个就是用来获取控制台输入的nextLine(),nextInt()等方法来获取文本的信息，<strong>非常类似于自己在控制台输入的数据变成了文本内容，给Scanner对象获取</strong>。</p><p>nextInt:<strong>Scanner中的nextInt()只会读取数值，剩下”\n”还没有读取</strong></p><p>next()与nextLine()区别</p><p>next():</p><ul><li>1、一定要读取到有效字符后才可以结束输入。</li><li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>4、next() 不能得到带有空格的字符串。</li></ul><p>nextLine()：</p><ul><li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符，并且将光标定位在下一行（会忽略掉末尾的回车进入下一行开始扫描）。</li><li>2、可以获得空白。</li></ul></li><li><p>Java控制台输入输出</p><ul><li>使用Scanner</li></ul><p><code>Scanner scanner=new Scanner(System.in)</code>,然后使用Scanner相关的方法，比如scanner.nextInt() scanner.nextLine() scanner.next()等</p><ul><li>使用BufferReader</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bufferedReader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String str1=bufferedReader.readLine();</span><br><span class="line">    String str2=bufferedReader.readLine();</span><br><span class="line">    System.out.print(str1);</span><br><span class="line">    System.out.print(str2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li><p>通过<strong>后期绑定</strong>（也叫动态绑定）来确定一个引用所调用的方法是哪一个， private 方法、 static 方法或 final 方法不会动态绑定，在运行时， 调用 e.getSalary（） 的解析过程为（e是Employee类的一个对象）：</p><p>在 Employee 的方法表中， 列出了这个类定义的所有方法（实际上没列出超类Object的方法）：</p><p> <img src="/2022/09/06/review-on-java/Java-method-table1.png" alt="Java-method-table1"></p><p>在Manager的方法表中，有三个方法是继承而来的，一个方法是重新定义的， 还有一个方法是新增加的：</p><p><img src="/2022/09/06/review-on-java/Java-method-table2.png" alt="Java-method-table2"></p><p>1 ) 首先，虚拟机提取 e 的实际类型的方法表。既可能是 Employee、 Manager 的方法表， 也可能是 Employee 类的其他子类的方法表（有可能e的实际类型是Employee的子类但赋值给employee引用）。 </p><p>2 ) 接下来， 虚拟机搜索定义 getSalary 签名的类（方法的名字和参数列表称为方法的签名）。此时，虚拟机已经知道应该调用哪个 方法。 </p><p>3 ) 最后，虚拟机调用方法。动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。 假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象， 我们不需要对包含调用 e.getSalary() 的代码进行重新编译。如果 e 恰好引用一个 Executive 类的对象，就会自动地调用 Executive.getSalary（）方法。</p></li></ol><h2 id="静态方法和静态变量"><a href="#静态方法和静态变量" class="headerlink" title="静态方法和静态变量"></a>静态方法和静态变量</h2><ol><li><p>在同一个类中：<br>对于静态方法，其他的静态或非静态方法都可以直接调用它。<br>而对于非静态方法，其他的非静态方法是可以直接调用它的。但是其他静态方法只有通过对象才能调用它。</p><p>静态方法不能被非静态方法覆盖。</p></li><li><p>不同的类之间，无论调用方法是非静态还是静态，如果被调用的方法是：<br>静态方法，则通过类名与对象都可以调（但通过对象的方式不建议使用，通过对象来调用静态的方法静态方法还是不知道它是被哪个对象所调用的，这会产生误解）。<br>非静态方法，则只能通过对象才可以调用它。</p></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol><li>接口中的所有方法自动地属于 public，接口中所有的域被自动的设为public static final，但实现接口时要显式的指出方法是public的，接口中可能包含多个方法，在接口中可以定义常量，但接口绝对不能含有实例域，接口最好没有实现方法，虽然Java8可以在接口中提供简单方法</li><li>不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象</li><li>在方法中定义的局部类不能用public或private访问说明符进行说明，它的作用域被限定在声明这个局部类的块中</li><li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据</li><li>内部类没太看懂，不知道重不重要</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol><li><p>如果出现RuntimeException（非受查异常）异常，那么就一定是你的问题，有可能是因为程序的逻辑错误导致的，这些运行时错误完全在我们的控制之下，但已检查异常需要提供异常处理器</p></li><li><p>方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受査异常。</p></li><li><p>运行时异常：编译时不会报错，但程序运行起来如果有错误就会报异常。下面是几种常见的运行时异常</p><p>ArithmeticException  算数运算异常，由于除数为0引起的异常；<br>ClassCastException  类型转换异常，当把一个对象归为某个类，但实际上此对象并不是由这个类创建的，也不是其子类创建的，则会引起异常；<br>ArrayStoreException  由于数组存储空间不够引起的异常；<br>NullPointerException  空指针异常，程序试图访问一个空的数组中的元素或访问空的对象中的方法或变量时产生异常；<br>IndexOutOfBoundsExcention  索引越界异常，由于数组下标越界或字符串访问越界引起异常；<br>ConcurrentModificationException  并发修改异常；<br>NoSuchElementException  找不到元素异常；<br>UnsupportedOperationException  不支持请求异常；（使用Arrays工具类的asList将数组转成集合增加元素时，会报此异常）</p></li></ol><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><ol><li><p>一个泛型类（ generic class) 就是具有一个或多个类型变量的类。</p></li><li><p>下面的这个Pair就是一个泛型类，类定义中的类型变量指定方法的返回类型以及域和局部变量的类型</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123; first = <span class="literal">null</span> ; second = <span class="literal">null</span> ; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> </span><br><span class="line">    &#123; <span class="built_in">this</span>.first = first; <span class="built_in">this</span>.second = second; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newValue)</span> &#123; first = newValue; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newValue)</span> &#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对类型变量 T 设置<strong>限定</strong>：<code>public static &lt;T extends Comparable&gt; T min(T[] a) </code>,一个类型变量或通配符可以有多个限定， 例如： <code>T extends Comparable &amp; Serializable</code> 限定类型用“ &amp;” 分隔，而逗号用来分隔类型变量。</li><li><strong>泛型的一些东西没搞清楚</strong>，但基本上应该使用泛型没什么问题</li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol><li><p>Java 迭代器指向两个元素之间的位置</p></li><li><p>树集是一个有序集合 ( sorted collection) o，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p></li><li><p>Java 集合类型分为 Collection 和 Map，它们是 Java 集合的根接口，这两个接口又包含了一些子接口或实现类</p><p><img src="/2022/09/06/review-on-java/5-1912051036333V.png" alt="Collection接口结构"></p><p><img src="/2022/09/06/review-on-java/5-191205103G5960.png" alt="Map接口结构"></p></li><li><p>Java集合接口的作用</p><table><thead><tr><th>接口名称</th><th>作  用</th></tr></thead><tbody><tr><td>Iterator 接口</td><td>集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。</td></tr><tr><td>Collection 接口</td><td>是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。</td></tr><tr><td>Queue 接口</td><td>Queue 是 Java 提供的队列实现，有点类似于 List。</td></tr><tr><td>Dueue 接口</td><td>是 Queue 的一个子接口，为双向队列。</td></tr><tr><td>List 接口</td><td>是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。</td></tr><tr><td>Set 接口</td><td>不能包含重复的元素。</td></tr><tr><td>Map 接口</td><td>是存放一对值的最大接口，即接口中的每个元素都是一对，以 key→value 的形式保存。</td></tr></tbody></table></li><li><p>Java集合实现类的作用</p><table><thead><tr><th>类名称</th><th>作用</th></tr></thead><tbody><tr><td>HashSet</td><td>为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单</td></tr><tr><td>TreeSet</td><td>实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列</td></tr><tr><td>ArrayList</td><td>一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组</td></tr><tr><td>ArrayDueue</td><td>是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素</td></tr><tr><td>LinkedList</td><td>对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用</td></tr><tr><td>HsahMap</td><td>按哈希算法来存取键对象</td></tr><tr><td>TreeMap</td><td>可以对键对象进行排序</td></tr></tbody></table></li><li><p>comparable和comparator：</p><p><code>Comparable &amp; Comparator</code>都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，<code>Comparator</code> 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义<code>Comparator</code>接口的方法或在集合内实现 <code>Comparable</code>接口的方法</p><p>Java中有两种方式来提供比较功能。第一种是实现java.lang.Comparable接口，使你的类天生具有比较的能力，此接口很简单，只有一个<code>compareTo</code>一个方法。此方法接收另一个Object为参数，如果当前对象小于参数则返回负值，如果相等则返回零，否则返回正值，也就是：<br> <strong>x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。</strong></p><p>使用Comparable比较的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.compareTo(person.name);</span><br><span class="line">        <span class="comment">//return this.name - person.name;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"><span class="comment">// 添加对象到ArrayList中</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>));</span><br><span class="line">Collections.sort(list); <span class="comment">//这里会自动调用Person中重写的compareTo方法。</span></span><br></pre></td></tr></table></figure><p>使用Comparator比较的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhouweidu.se1codetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person2&gt; person2s = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        person2s.add(<span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="number">1</span> ,<span class="number">2</span>));</span><br><span class="line">        person2s.add(<span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="number">2</span> ,<span class="number">1</span>));</span><br><span class="line">        person2s.add(<span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="number">4</span> ,<span class="number">6</span>));</span><br><span class="line">        person2s.add(<span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="number">6</span> ,<span class="number">4</span>));</span><br><span class="line">        person2s.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person2&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person2 o1, Person2 o2)</span> &#123;</span><br><span class="line">                <span class="comment">//return Integer.compare(o1.getAge(),o2.getAge());</span></span><br><span class="line">                <span class="keyword">return</span> o2.getAge() - o1.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(person2s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person2</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age+<span class="string">&quot; &quot;</span>+<span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol><li>反射的特征：动态性（编译时无法确定，在运行时确定下来）</li><li>在一个类中最好提供一个public的空参构造器，便于通过反射去创建运行时类的对象，便于子类继承此运行时类时，默认调用super()时保证父类有此构造器</li><li>框架&#x3D;注解+反射+设计模式</li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol><li>内部类的分类：成员内部类，局部内部类</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol><li>同步监视器，俗称锁。任何一个类的对象都可以充当锁。要求：多个线程必须要共用同一把锁，即充当锁的对象只有一个</li><li>同步方法synchronized默认的锁，对于非静态方法是this，静态方法是<code>当前类.class</code></li><li>线程通信涉及到三个方法：<ul><li>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li><li>notify()：一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，我们就唤醒优先级高的那个</li><li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li></ul></li><li>线程通信的注意点：<ul><li>wait()、notify()、notifyAll()这三个方法必须使用在同步代码块或同步方法中。</li><li>wait()、notify()、notifyAll()这三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现异常。</li></ul></li></ol><h2 id="一些零散知识点"><a href="#一些零散知识点" class="headerlink" title="一些零散知识点"></a>一些零散知识点</h2><ol><li><p>块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句</p></li><li><p>不能在嵌套的两个块中声明同名的变量</p></li><li><p>instanceof（）方法左边是对象，右边是类，当对象是右边类或子类所创建的对象时，返回true，否则返回false</p></li><li><p>设计方法的第一步是<strong>先对数据的合理性进行校验</strong></p></li><li><p>类之间的关系：依赖（“uses-a”）：一个类的方法操纵另一个类的对象；聚合（”has-a“）：类A对象包含类B对象；继承（”is-a“）：特殊与一般的关系</p></li><li><p>单引号是用来写字符型的，例如<code>char str=&#39;a&#39;</code>，而双引号是用来写字符串的</p></li><li><p>开发类时的经验：</p><p>（1）找出类应该做的事情</p><p>（2）列出实例变量和方法</p><p>（3）编写方法的伪码</p><p>（4）编写方法的测试用程序</p><p>（5）实现类</p><p>（6）测试方法</p><p>（7）除错或重新设计</p></li><li><p>logo用面向对象的思想重写一遍：有两个类一个是Turtle一个是Chessboard，当乌龟移动时，就在Chessboard上留下痕迹，这部分是在main方法里面实现的，感觉这部分做的不是很好，乌龟和棋盘的关系是棋盘上有只乌龟，或许应该在棋盘类中创建乌龟的实例？（“has-a”关系？），继续学习用<strong>面向对象的观点和方法</strong>来思考</p></li><li><p>方法签名是指方法的名称（即函数名）和方法的参数</p></li><li><p>在定义方法时，在最后一个形参后加上三点 <strong>…</strong>，就表示该形参可以接受多个参数值，多个参数值被当成数组传入。上述定义有几个要点需要注意：</p></li></ol><ul><li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li><li>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</li><li>Java的可变参数，会被编译器转型为一个数组</li><li>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String...varargs)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述过程和下面的调用是等价的</span></span><br><span class="line">foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="11"><li><p>Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必 须与 y.hashCode( ) 具有相同的值。</p></li><li><p>正则表达式：</p><table><thead><tr><th align="left">代码</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配任意1个字符（除了\n）</td></tr><tr><td align="left">[ ]</td><td align="left">匹配[ ]中列举的字符</td></tr><tr><td align="left">\d</td><td align="left">匹配数字，即0-9</td></tr><tr><td align="left">\D</td><td align="left">匹配非数字，即不是数字</td></tr><tr><td align="left">\s</td><td align="left">匹配空白，即 空格，tab键</td></tr><tr><td align="left">\S</td><td align="left">匹配非空白</td></tr><tr><td align="left">\w</td><td align="left">匹配非特殊字符，即a-z、A-Z、0-9、_、汉字</td></tr><tr><td align="left">\W</td><td align="left">匹配特殊字符，即非字母、非数字、非汉字、非_</td></tr></tbody></table></li><li><p>对<strong>递归</strong>的理解：倒着想问题，正着写代码，先想问题的前一步，也就是再走一步就可以解决问题的这个点，然后看从这一点到解决问题有多少种方法，一般而言这几种方法就是从起点走到解决问题的这些方法，但也有可能不是，可能起点开始的时候方法选择会更多，所以要综合第一步来考虑，综合后这就是递归的路径，然后根据不同的路径判断<strong>递归的边界条件</strong>（边界条件非常重要），首先看问题规模是朝着什么方向缩减的，这可以写成if，然后再看看会不会有走向死路（死循环）的情况，这个边界条件也要加上去，这个地方的边界条件可能有点难找，多考虑几个样例来试试，切记分析问题时可以从正向和反向两个方面来分析，反向：假设这样可以会怎么怎么样。</p></li></ol><h2 id="Java高级特性反射、代理（等到今后需要用到时再了解吧）"><a href="#Java高级特性反射、代理（等到今后需要用到时再了解吧）" class="headerlink" title="Java高级特性反射、代理（等到今后需要用到时再了解吧）"></a>Java高级特性反射、代理（等到今后需要用到时再了解吧）</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库教程</title>
      <link href="/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/06/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL初级篇"><a href="#MySQL初级篇" class="headerlink" title="MySQL初级篇"></a>MySQL初级篇</h1><h2 id="1-基本的select语句"><a href="#1-基本的select语句" class="headerlink" title="1. 基本的select语句"></a>1. 基本的select语句</h2><p><strong>SQL的分类</strong></p><ul><li><p>DDL<strong>（Data Definition Languages、数据定义语言）</strong> ，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>、<code>RENAME</code>、<code>TRUNCATE</code>等。</p></li><li><p>DML:<strong>（Data Manipulation Language、数据操作语言）</strong> ，用于添加、删除、更新和查询数据库记录(增删改查)，并检查数据完整性。主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。SELECT是SQL语言的基础，最为重要。</p></li><li><p>DCL:<strong>（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</p></li></ul><blockquote><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p></blockquote><span id="more"></span><h2 id="2-多表查询"><a href="#2-多表查询" class="headerlink" title="2. 多表查询"></a>2. 多表查询</h2><ol><li><p>自然连接(NATURAL JOIN)</p><p>它会帮你自动查询两张连接表中所有相同字段,然后进行等值连接.</p></li><li><p><strong>时间戳</strong>:是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p></li><li><p><code>SELECT</code>语句的完整结构:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#SQL92语法</span><br><span class="line">SELECT (DISTINCT)..., ...,...(存在聚合函数)</span><br><span class="line">FROM ...,...</span><br><span class="line">WHERE 多表的连接条件 AND 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ...,...(ASC / DESC)</span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#SQL99语法</span><br><span class="line">SELECT (DISTINCT)..., ...,...(存在聚合函数)</span><br><span class="line">FROM ... </span><br><span class="line">(LEFT / RIGHT)JOIN ... ON 多表的连接条件</span><br><span class="line">JOIN ... ON ...</span><br><span class="line">WHERE 不包含聚合函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含聚合函数的过滤条件</span><br><span class="line">ORDER BY ...,...(ASC / DESC)</span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure><ol start="4"><li>SQL语句的执行过程:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ...,... -&gt; ON -&gt; (LEFT / RIGHT JOIN) -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; </span><br><span class="line">SELECT -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</span><br></pre></td></tr></table></figure><ol start="5"><li>内连接和外连接<ul><li>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 </li><li>外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 </li><li>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。 如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</li></ul></li></ol><h2 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3. 聚合函数"></a>3. 聚合函数</h2><ol><li><code>SELECT</code>中出现的非组函数(非聚合函数)的字段必须声明在<code>GROUP BY</code>中,反之,<code>GROUP BY</code>中声明的字段可以不出现在<code>SELECT</code>中</li><li>如果过滤条件中使用了聚合函数,则必须使用<code>HAVING</code>来替换<code>WHERE</code>,且<code>HAVING</code>必须声明在<code>GROUP BY</code>后面,开发中使用<code>HAVING</code>的前提是SQL中使用了<code>GROUP BY</code></li><li>当过滤条件中有聚合函数时,此过滤条件必须声明在<code>HAVING</code>中,当过滤条件中没有聚合函数时,则此过滤条件声明在<code>WHERE</code>中或<code>HAVING</code>中都可以,但建议声明在<code>WHERE</code>中</li></ol><h2 id="4-子查询"><a href="#4-子查询" class="headerlink" title="4. 子查询"></a>4. 子查询</h2><ol><li><p>子查询的分类</p><p>角度1:从内查询返回的结果的条目数</p><ul><li>单行子查询:子查询只计算出一个结果</li><li>多行子查询:子查询计算出多个结果</li></ul><p>角度2:内查询是否被执行多次</p><ul><li>相关子查询(内查询执行多次,里外有相关性)</li><li>不相关子查询</li></ul></li><li><p>子查询的编写技巧（或步骤）：</p><ul><li>从里往外写</li><li>从外往里写</li><li>选择经验:<ol><li>如果子查询相对简单,建议从外往里写.一旦子查询结构较为复杂,建议从里往外写</li><li>如果是相关子查询,通常从外往里写</li></ol></li></ul></li><li><p>结论：在SELECT中除GROUP BY和LIMIT之外，其他位置都可以声明子查询</p></li><li><p>可以先排序（升序）再取第一条记录就是最小的数据</p></li></ol><h2 id="5-创建和管理表"><a href="#5-创建和管理表" class="headerlink" title="5. 创建和管理表"></a>5. 创建和管理表</h2><ol><li><code>TRUNCATE TABLE</code> 一旦执行此操作,表数据全部清除,数据不可以回滚.<code>DELETE FROM</code> 一旦执行此操作,表数据可以全部清除(可以用WHERE过滤出需要清除的数据,不带WHERE全部清除),数据可以回滚(默认情况下不能回滚,执行了<code>SET autocommit=FALSE</code>,则之后执行的DML操作可以回滚 ),执行完DDL之后会自动执行一次COMMIT,此COMMIT操作不受<code>SET autocommit=FALSE</code>的影响</li><li>字符和日期类型数据应该包含在单引号中，给字段或表取别名包含在双引号中</li></ol><h2 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h2><ol><li>简短和固定长度的字符串用CHAR，其他情况都用VARCHAR</li><li>在定义数据类型时，如果确定是整数，就用<code>INT</code>；如果是小数，就用<code>DECIMAL(M,D)</code>，M表示一共多少位，D表示小数部分有多少位；如如果是日期与时间，就用<code>DATETIME</code></li></ol><h2 id="7-约束"><a href="#7-约束" class="headerlink" title="7. 约束"></a>7. 约束</h2><ol><li>唯一性约束允许出现多个NULL，可以向声明为unique的字段上添加NULL值</li><li>主键约束的特征：非空且唯一，用于唯一的标识表中的一条记录。MySQL的主键名总是PRIMARY，自己取名也没用</li><li>对于外键约束，最好采用：<code>ON UPDATE CASCADE ON DELETE RESTRICT</code> (CASCADE表示主表与从表同步操作，RESTRICT是严格模式，从表中还有主表关联的数据，主表就不能删除该数据)</li></ol><h1 id="MySQL高级篇"><a href="#MySQL高级篇" class="headerlink" title="MySQL高级篇"></a>MySQL高级篇</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux教程（简明版）</title>
      <link href="/2022/09/06/Linux%E6%95%99%E7%A8%8B%EF%BC%88%E7%AE%80%E6%98%8E%E7%89%88%EF%BC%89/"/>
      <url>/2022/09/06/Linux%E6%95%99%E7%A8%8B%EF%BC%88%E7%AE%80%E6%98%8E%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ol><li><p>在Linux下隐藏文件是以 <code>.</code> 开头的</p></li><li><p>man或help +{待查询的指令}获取帮助信息</p></li></ol><h3 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h3><ol><li>蓝色代表是一个目录，白色代表是一个文件</li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ol><li>r&#x3D;4,w&#x3D;2,x&#x3D;1  可以通过数字赋予权限</li><li>对于文件夹的权限：r表示可以查看文件列表（即ls命令）；w表示可以在将该目录下的文件重命名，创建子文件，删除；x表示可以进入该文件夹（即cd）</li></ol><h3 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 刷题笔记</title>
      <link href="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>注意：一道题目<strong>先思考20-30分钟</strong>如果实在做不出来再看看题解和思路，然后自己试试能不能自己写出代码，题目后面是在LeetCode网站上的题号，前面那个是自动生成的有序列表。</p><ul><li>2022&#x2F;4&#x2F;24 基本上一天四道题</li></ul><ol><li><p>两数之和(1)：太简单没什么说的。</p></li><li><p>两数相加(2)：应该根据题目现有的条件来做，从题目本身出发，不要一开始就考虑转换为常用的按顺序的十进制加法，<strong>类比二进制加法计算（二进制全加法器）</strong>，直接用两个链表的结点从前往后相加即可。</p></li><li><p>无重复字符的最长子串(3)：</p><p>用<strong>滑动窗口</strong>思想，两个指针left和right，如果left和right之间没有重复就让right++，因为之前left和right之间无重复，所有如果right++后出现重复一定是现在的right和之前的left到right之间有一个值重复了，以<code>string.charAt(right)</code>为标准从left开始遍历，分三种情况（前部、中部、后部）</p><p>（1）a b c a</p><p>（2）a b c b</p><p>（3）a b c c</p><p>从j&#x3D;left开始遍历（j++），如果遇到这两种重复的情况，让left&#x3D;j+1即左指针指向重复位置的下一个位置。</p></li><li><p>寻找两个正序数组的中位数(4)：</p><p>归并排序，将<strong>两个有序数组合并为一个</strong>，for循环遍历合并后的数组，然后分别设置两个指针指向需要排序的两个数组，取两个数组中小的数放入新数组，并且让该数组指针后移，<strong>边界情况</strong>若一个数组指针已经指向末尾，则另外判断次情况，将另一个数组的数全部放入即可。</p><p>算法时间复杂度为O（m+n），只用遍历一次新数组即可。</p><span id="more"></span></li><li><p>最长回文子串(5)：</p><p>（1）扩展中心：回文子串分两种，奇数长度：abcba可以从中间的a开始向两边扩展，偶数长度：abcabbabb，从[1]和[2]中间开始向两边扩展，下面是扩展的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">return</span> end-start-<span class="number">1</span>;<span class="comment">//注意这里的减一，比如abcba，到两边a的时候还会start--和end++,所以要减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历字符串，从每个点开始扩展，有两种扩展方式，分别为<code>expand(s,i,i);//abcba</code>（从c开始扩展）和<code>len2=expand(s,i,i+1);//abba</code>（从[1]b和[2]b开始扩展），然后找出最长的那个扩展方式，<code>start=i-(len-1)/2;end=i+len/2;</code>,注意这里的start和end。</p><p>（2）动态规划：p（i，j）&#x3D;p(i+1,j-1)&amp;&amp;s[i]&#x3D;&#x3D;s[j]所以如果我们想知道 P（i , j）的情况，只需要知道 P（i + 1，j - 1）的情况就可以了，然后向两边扩展即可，这样时间复杂度就少了 O(n)。因此我们可以用动态规划的方法，空间换时间，把已经求出的 P（i，j）存储起来，求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，例如求p（1，2），带入会出现p（2，1），长度为1和2的回文串需要单独判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= length; len++) <span class="comment">//遍历所有的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; length; start++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= length) <span class="comment">//下标已经越界，结束本次循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            P[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || P[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end); <span class="comment">//长度为 1 和 2 的单独判断下</span></span><br><span class="line">            <span class="keyword">if</span> (P[start][end] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                maxLen=len;</span><br><span class="line">                maxPal = s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：两层循环 O(n²）</p><p>空间复杂度：用二维数组 P<em>P</em> 保存每个子串的情况 O(n²)</p></li><li><p>Z字形变换(6)：是一个找规律的题目，可以找出规律来用二维数组模拟</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220328225949259.png" alt="image-20220328225949259"></p></li><li><p>正则表达式匹配(10)：</p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>使用动态规划，对匹配的方案进行枚举。我们用 f [i] [j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配.</p><p>如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s中匹配一个相同的小写字母，即</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/1-166246313667549.png" alt="image-20220407223143316"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/2.png" alt="image-20220407223216513"></p><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</p></li><li><p>不匹配字符，将该组合扔掉，不再进行匹配。</p></li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/3.png" alt="image-20220407223308404"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/4.png" alt="image-20220407223334274"></p><p>其中 matches(x,y) 判断两个字符是否匹配的辅助函数。只有当 y 是 . 或者 x 和 y 本身相同时，这两个字符才会匹配。</p><ol start="8"><li>盛最多水的容器(11)：</li></ol><p>  <strong>双指针</strong>解决，第一次做这题可能不会想到双指针。下面解释双指针算法的过程，并证明其正确性。给定一个数组height[1, 8, 6, 2, 5, 4, 8, 3, 7]，初始时分别有一左一右两个指针位于边界，容纳的水量&#x3D;两个指针指向的数字中较小值∗指针之间的距离，假设左指针为left右指针为right，不妨设此时height[left]&lt;height[right]，如果移动右指针，那么两个指针的距离一定变小，并且min{height[left],height[right’]}&lt;&#x3D;之前的高度，因为如果此时新的高度比原来的高度大，取height[left]和height[right]的最小值还是之前的height[left]，高度没变但距离变小，所以容器的容积变小，如果新的高度比原来的高度小，则导致高度变小且距离变小，容积也会变小，即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量，也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。综上，可以得出每次移动指针的时候移动高度较小的那个指针是正确答案，边界条件是left&lt;right。</p><ol start="9"><li><p>整数转罗马数字(12)：</p><p>按照题目所给规则可能出现的罗马数字如下</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220410224312579.png" alt="image-20220410224312579"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220410225427004.png" alt="image-20220410225427004"></p><p>根据上图求140的罗马数字，我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为C&#x3D;100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL&#x3D;40。因此，140 的对应的罗马数字为 C+XL&#x3D;CXL。</p><p>采取模拟的思路，根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。</p><p>编程时，可以建立一个数值-符号对的列表valueSymbols，按数值从大到小排列。遍历 valueSymbols 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。valueSymbols对应表和代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">        <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> symbols[i];</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">            num -= value;</span><br><span class="line">            roman.append(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三数之和(15)：</p></li></ol><p>   刚开始做这题直接三重循环遍历，会超出时间限制，需要改进算法，看来LeetCode上的题目有些<strong>不能直接模拟</strong>，要想想降低复杂度的做法。「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><p>   第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p><p>   第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p><p>   也就是说，我们枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有(a,b,c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>   同时，<strong>对于每一重循环而言，相邻两次枚举的元素不能相同</strong>，否则也会造成重复。举个例子，如果排完序的数组为</p><p>   [0, 1, 2, 2, 2, 3]<br>    ^  ^  ^<br>   我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。</p><p>   <img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220411225207697.png" alt="image-20220411225207697"></p><p>   这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2) 减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。</p><p>   双指针看似容易理解，但不同题目下的<strong>边界条件</strong>都不尽相同，边界条件应该是一个难点，需要仔细考虑。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;<span class="comment">//对于每一重循环相邻两个元素不能相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果指针重合，一种情况是上一次j&lt;k时（j和k相邻），nums[j] + nums[k] &gt; target</span></span><br><span class="line">                    <span class="comment">// 另一种情况时j不断增加但nums[j]+nums[k]&lt;target，随着 j 后续的增加</span></span><br><span class="line">                    <span class="comment">// 就不会有满足 nums[j] + nums[k] = target 并且 j&lt;k 的值了，可以退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] + nums[k] == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        integerList.add(nums[i]);</span><br><span class="line">                        integerList.add(nums[j]);</span><br><span class="line">                        integerList.add(nums[k]);</span><br><span class="line">                        list.add(integerList);</span><br><span class="line">                        <span class="comment">// 这里不要写k--，要让k--交由上面的while循环来判断执行</span></span><br><span class="line">                        <span class="comment">// 如果写了k--，在j和k相邻的情况下，下一次循环j会大于k（j比k大1），</span></span><br><span class="line">                        <span class="comment">// while循环和if失效，所以k--要交由while循环来执行</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br></pre></td></tr></table></figure><ol start="11"><li>电话号码的字母组合(17)：</li></ol><p>   这道题其实<del>直接模拟</del>也能做，因为最多只有四位电话号码，直接根据不同的位数电话号码采取一层for，二层for，三层for，四层for遍历也可AC。</p><p>   首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>   回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><p>   回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。下面贴上带有回溯的递归函数的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个回溯的递归函数借鉴了赫夫曼编码的向左为0向右为1的那个递归函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(List&lt;String&gt; res, HashMap&lt;Character, String&gt; stringHashMap, String digits, StringBuilder stringBuilder, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//用index遍历电话号码，for循环遍历每一个电话号码对应的所有字符</span></span><br><span class="line">    <span class="comment">//  2   3</span></span><br><span class="line">    <span class="comment">// abc def</span></span><br><span class="line">    <span class="keyword">if</span> (digits.length() != index) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">digitString</span> <span class="operator">=</span> stringHashMap.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digitString.length(); i++) &#123;</span><br><span class="line">            stringBuilder.append(digitString.charAt(i));</span><br><span class="line">            f(res, stringHashMap, digits, stringBuilder, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当该递归函数返回进入下一行时，说明已经遍历完电话号码的所有数字，</span></span><br><span class="line">            <span class="comment">// 下一步应该取最后一个电话号码的下一个字符（也就是i++），需要删掉stringBuilder2的末尾一位，</span></span><br><span class="line">            <span class="comment">// 让最后一个电话号码的下一个字符填入进来</span></span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li><p>删除链表的倒数第N个结点(19)：</p><p>我的想法是从头节点开始遍历，用于遍历的结点记为indexNode，如果indexNode向后遍历n次为null的话，证明此时indexNode结点即为要删除的结点，看下面这个图可以轻松证明</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220414201955313.png" alt="image-20220414201955313"></p><p>​还需要设置一个preNode作为indexNode的前一个结点，这样才能做到删除操作，除此以外需要注意一个特殊情况即删除的结点是头结点，直接返回head.next即可。</p><p>​一个小tips：处理链表是可以在头结点前面加上一个哑节点dummy，dummy不保存任何信息只是指向原链表的头结点，这样可以有效解决删除链表头相关的特殊情况，可以把有关链表头的特殊情况统一到普通情况的代码中。（不是下面贴的那段代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//该链表只有一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode indexNode=head;</span><br><span class="line">    ListNode preNode=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode temp=indexNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (preNode==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//删除的是头节点的情况</span></span><br><span class="line">                <span class="keyword">return</span> head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode.next=preNode.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里的保存preNode是一个保存链表前一个结点的经典操作</span></span><br><span class="line">        preNode=indexNode;</span><br><span class="line">        indexNode=indexNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li>有效的括号(20)：</li></ol><p>​典型的<strong>栈的应用</strong>，我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合（<strong>后进先出</strong>），因此我们可以将这个左括号放入栈顶。当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。<strong>如果不是相同的类型，或者栈中并没有左括号</strong>，那么字符串 s 无效，返回 False。在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>​注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><ol start="14"><li><p>合并k个升序列表(23):</p><p>前置知识：合并两个有序链表</p><ul><li>首先我们需要一个变量 head 来保存合并之后链表的头部，你可以把 head 设置为一个虚拟的头（也就是 head 的 val 属性不保存任何值），这是为了方便代码的书写，在整个链表合并完之后，返回它的下一位置即可。<strong>设置哑结点方便链表操作的代码书写</strong></li><li>我们需要一个指针 tail 来记录下一个插入位置的前一个位置，以及两个指针 aPtr 和 bPtr 来记录 a 和 b 未合并部分的第一位。注意这里的描述，tail 不是下一个插入的位置，aPtr 和 bPtr 所指向的元素处于「待合并」的状态，也就是说它们还没有合并入最终的链表。 当然你也可以给他们赋予其他的定义，但是定义不同实现就会不同。</li><li>当 aPtr 和 bPtr 都不为空的时候，取 val 熟悉较小的合并；如果 aPtr 为空，则把整个 bPtr 以及后面的元素全部合并；bPtr 为空时同理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//这里的head就是哑结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b;</span><br><span class="line">    <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">            tail.next = aPtr;</span><br><span class="line">            aPtr = aPtr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = bPtr;</span><br><span class="line">            bPtr = bPtr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：顺序合并</p><p>我们可以想到一种最朴素的方法：用一个变量 ans 来维护以及合并的链表，第 i 次循环把第 i个链表和 ans 合并，答案保存到 ans 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">    ListNode ans=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        ans=mergeTwoLists(ans,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分治合并</p><p>考虑优化方法一，用分治的方法进行合并。</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220416111324477.png" alt="image-20220416111324477"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//本题中其实并不会出现l&gt;r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="literal">null</span>||lists.length==<span class="number">0</span>)&#123;<span class="comment">//注意这两个特殊情况的判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>长度为0的数组 int[] arr &#x3D; new int[0]，也称为空数组，虽然arr长度为0，但是依然是一个<strong>对象</strong></p></li><li><p>null数组，int[] arr &#x3D; null；arr是一个数组类型的<strong>空引用</strong>。</p></li></ul><p>​方法三：使用优先队列合并</p><p>这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用<strong>优先队列</strong>来优化这个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Status&gt; &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Status</span><span class="params">(<span class="type">int</span> val, ListNode ptr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Status o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val - o.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Status&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode node :</span><br><span class="line">         lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(node.val, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Status</span> <span class="variable">f</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        tail.next = f.ptr;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="keyword">if</span> (f.ptr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(f.ptr.next.val, f.ptr.next));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li><p>下一个排列(31)：</p><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个<strong>字典序更大的排列</strong>，注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p><p>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p><p>以排列 [4,5,2,6,3,1] 为例：</p><p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</p><p>当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</p><p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p><ul><li><p>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</p></li><li><p>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从后向前找到第一个不满足从后向前为升序的位置，该位置为index-1（如果index！=0）</span></span><br><span class="line">    <span class="comment">//从后向前为升序意味着该子序列是最大的序列，无法通过交换该子序列的内部获得下一个排列</span></span><br><span class="line">    <span class="comment">//所以需要一直找到一个不满足该条件的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span>&amp;&amp;nums[index]&lt;=nums[index-<span class="number">1</span>])&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;<span class="comment">//如果index!=0意味着该数列不是递减数列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minTemp</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line">        index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</span></span><br><span class="line">        <span class="keyword">while</span> (nums[index] &lt;= nums[minTemp]) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序，交换后该序列一定比原序列大，但要保证**变大的幅度尽可能小**，所以需要把后面的子序列从小到大排列，这样就是下一个排列</span></span><br><span class="line">        swap(nums, minTemp, index);</span><br><span class="line">        left = minTemp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="16"><li><p>最长有效括号(32)：</p><ul><li><p>方法一：动态规划</p><p>首先要找到转移方程，怎么想转移方程？首先想的时候从已经求出了 <code>dp[i-1][j-1]</code> 入手，再加上已知 <code>s[i]</code>、<code>p[j]</code>，要想的问题就是怎么去求 <code>dp[i][j]</code>。</p><p>结合题目，有最长这个字眼，可以考虑尝试使用 动态规划 进行分析。这是一个 最值型 动态规划的题目。</p><p>动态规划题目分析的 4 个步骤：</p><ul><li><p>确定状态</p><p>​研究<strong>最优策略的最后一步</strong></p><p>​化为子问题</p></li><li><p>转移方程</p><p>​根据子问题定义得到</p></li><li><p>初始条件和边界情况</p></li><li><p>计算顺序</p></li></ul><p>首先，我们定义一个 int[] dp 数组，其中第 i 个元素表示<strong>以下标为 i 的字符结尾</strong>的最长有效子字符串的长度。注意：如果第i个元素为 <code>(</code> 那么s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] &#x3D; 0，以 <code>(</code> 结尾的子串对应的dp值都为零。下面来推导状态转移方程</p><p>s[i]&#x3D;&#x3D; ‘(‘</p><p>这时，s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] &#x3D; 0</p><p>s[i] &#x3D;&#x3D; ‘)’</p><p>这时，需要看其前面对元素来判断是否有有效括号对。</p><p><strong>情况1:</strong></p><p>s[i - 1] &#x3D;&#x3D; ‘(‘</p><p>即 s[i] 和 s[i - 1] 组成一对有效括号，有效括号长度新增长度2，i位置对最长有效括号长度为 其之前2个位置的最长括号长度加上当前位置新增的2，我们无需知道i-2位置对字符是否可以组成有效括号对。</p><p>那么有：<code>dp[i] = dp[i - 2] + 2</code></p><p><strong>情况2:</strong></p><p>s[i - 1] &#x3D;&#x3D; ‘)’</p><p>这种情况下，如果前面有和s[i]组成有效括号对的字符，即形如( (….) )，这样的话，就要求s[i - 1]位置必然是有效的括号对，否则s[i]无法和前面对字符组成有效括号对。这时，我们只需要找到和s[i]配对对位置，并判断其是否是 <code>(</code> 即可。</p><p>和其配对对位置为：<code>i - dp[i - 1] - 1</code></p><p>如果：<code>s[i - dp[i - 1] - 1] == &#39;(&#39;</code>,有效括号长度新增长度2，i位置对最长有效括号长度为 i-1位置的最长括号长度加上当前位置新增的2，那么有：</p><p><code>dp[i] = dp[i - 1] + 2</code></p><p>值得注意的是，<code>i - dp[i - 1] - 1</code>和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (…)这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code></p></li></ul></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220416165854222.png" alt="image-20220416165854222"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">    dp[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="comment">#要保证i - 2 &gt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span> </span><br><span class="line">        <span class="comment">#要保证i - dp[i - 1] - 2 &gt;= 0</span></span><br></pre></td></tr></table></figure><p>​下面贴上Java的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i]=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]=dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//s[i-1]=&#x27;)&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i]&gt;maxLen)&#123;</span><br><span class="line">            maxLen=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法二：使用<strong>栈</strong></p><p>​栈里存的是括号对应的<strong>下标</strong>，具体做法是我们始终保持<strong>栈底元素</strong>为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><p>​对于遇到的每个 ‘(’ ，我们将它的下标放入栈中<br>​对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：</p><p>​如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」<br>​如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」<br>​我们从前往后遍历字符串并更新答案即可。需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为-1 的元素。</p><p>​总结：两种索引会入栈</p><ol><li>等待被匹配的左括号索引。</li><li>充当「参照物」的右括号索引。因为：当左括号匹配光时，栈需要留一个垫底的参照物，用于计算一段连续的有效长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//s[i]==&#x27;)&#x27;</span></span><br><span class="line">            stack.pop();<span class="comment">//先出栈，再相减计算有多少个匹配的括号</span></span><br><span class="line">            <span class="comment">//举个例子 ()(()))</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> curLen=i-stack.peek();</span><br><span class="line">                maxLen=Math.max(maxLen,curLen);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法三：</p><p>​在此方法中，我们利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加 left 计数器，对于遇到的每个 ‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比left 计数器大时，我们将left 和 right 计数器同时变回 0。</p><p>​这样的做法<strong>贪心</strong>地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p><p>​解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：</p><ul><li>当 left 计数器比right 计数器大时，我们将 left 和right 计数器同时变回 0。</li><li>当 left 计数器与right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。</li></ul><p>​这样我们就能涵盖所有情况从而求解出答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;<span class="comment">//从左向右遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxLen = Math.max(left + right, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left=<span class="number">0</span>;</span><br><span class="line">    right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从右向左遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxLen = Math.max(left + right, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="17"><li><p>搜索旋转排序数组(33)：</p><ul><li><p>方法一：</p><p>比如<code>nums = [4,5,6,7,0,1,2], target = 0</code>，可以将该数组分为两部分看待，从4到7，从0到2，首先比较target与nums[0]的大小，如果target&lt;nums[0]，则在后半部分从后往前搜索，如果target&gt;nums[0]，则在前半部分从前往后搜索</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//[4,5,6,7,0,1,2], target = 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInFront</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">        index = nums.length - <span class="number">1</span>;</span><br><span class="line">        isInFront = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInFront) &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[index] &lt; nums[index + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; nums[index] &gt; nums[index - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：</p><p>对于旋转数组 nums &#x3D; [4,5,6,7,0,1,2]，首先根据 nums[0] 与 target 的关系判断 target 是在左段还是右段。</p><p>例如 target &#x3D; 5, 目标值在左半段，因此在 [4, 5, 6, 7, inf, inf, inf] 这个有序数组里找就行了；<br>例如 target &#x3D; 1, 目标值在右半段，因此在 [-inf, -inf, -inf, -inf, 0, 1, 2] 这个有序数组里找就行了。<br>如此，我们又将「旋转数组中找目标值」 转化成了 「有序数组中找目标值」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先根据 nums[0] 与 target 的关系判断目标值是在左半段还是右半段</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// 目标值在左半段时，若 mid 在右半段，则将 mid 索引的值改成 inf</span></span><br><span class="line">            <span class="comment">// 注意这里的&gt;=，如果target在最左端，就需要&gt;=，比如</span></span><br><span class="line">            <span class="comment">// nums=[5,1,2,3] target=5</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[mid] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 目标值在右半段时，若 mid 在左半段，则将 mid 索引的值改成 -inf</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[mid] = Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在排序数组中查找元素的第一个和最后一个位置(34)：</p><ul><li><p>方法一：</p><p>先用二分查找找到该元素的位置，然后从该位置不断向前遍历和向后遍历，以此来找到第一个和最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexA</span> <span class="operator">=</span> index, indexB = index;</span><br><span class="line">    <span class="keyword">while</span> (indexA &gt; <span class="number">0</span> &amp;&amp; nums[indexA] == nums[indexA - <span class="number">1</span>]) &#123;</span><br><span class="line">        indexA--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (indexB &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[indexB] == nums[indexB + <span class="number">1</span>]) &#123;</span><br><span class="line">        indexB++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;indexA, indexB&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找主要用于在有序的列表中查找目标值，注意二分查找的前提条件必须是有序或者部分有序的列表，当列表中目标值存在多个时，我们可以利用二分查找目标值的左边界和右边界，即<strong>左值二分查找</strong>和<strong>右值二分查找</strong>。需要特别注意目标值在列表中找不到的几种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 左值二分模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出，如果left和right都很大直接相加会溢出，</span></span><br><span class="line">        <span class="comment">// 最好不要直接相加除以二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// 继续往左边找</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续往右边找</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑目标值不在数组中的两种情况,目标值小于最小值left等于0，</span></span><br><span class="line">    <span class="comment">// 目标值大于最大值left等于num.length</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length || nums[left] != target) left = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 右值二分模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &lt;= target) &#123;</span><br><span class="line">            <span class="comment">// 继续往右边找</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续往左边找</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑目标值不在数组中的两种情况，目标值小于最小值right会等于-1，</span></span><br><span class="line">    <span class="comment">// 目标值大于最大值right会等于nums.length-1</span></span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span> || nums[right] != target) right = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组数总和(39)：</p></li></ol><p>  思路分析：根据示例 1：输入: candidates &#x3D; [2, 3, 6, 7]，target &#x3D; 7。</p><p>  候选数组里有 2，如果找到了组合总和为 7 - 2 &#x3D; 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；<br>  同理考虑 3，如果找到了组合总和为 7 - 3 &#x3D; 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。<br>  基于以上的想法，可以画出如下的树形图。建议大家自己在纸上画出这棵树，这一类问题都需要先画出树形图，然后编码实现。</p><p>  <img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220418221514841.png" alt="image-20220418221514841"></p><p>  编码通过 <strong>深度优先遍历</strong> 实现，使用一个列表，在 深度优先遍历 变化的过程中，遍历所有可能的列表并判断当前列表是否符合题目的要求，成为「回溯算法」。</p><p>  说明上图：</p><p>  以 target &#x3D; 7 为 根结点 ，创建一个分支的时 做减法 ；<br>  每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 candidate 数组的每个元素的值；<br>  减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；<br>  所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。<br>  这棵树有 4 个叶子结点的值 0，对应的路径列表是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中给出的输出只有 [[7], [2, 2, 3]]。即：题目中要求每一个符合要求的解是 不计算顺序 的。下面我们分析为什么会产生重复。</p><p>  产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说 <strong>每一个元素可以重复使用</strong>，我们考虑了 <strong>所有的</strong> 候选数，因此出现了重复的列表。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起点</strong> <code>index</code>，请看下图。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220418221816511.png" alt="image-20220418221816511"></p><p>​即：从每一层的第 2 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。</p><p>​<strong>剪枝提速</strong></p><p>​根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的数依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序（从小到大），添加相关逻辑达到进一步剪枝的目的，下面贴上剪枝提速后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; integerList, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//[2, 3, 6, 7]  4</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//添加的时候拷贝比每次传进来就拷贝效率高</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(integerList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//在这里剪枝效率很高</span></span><br><span class="line">        &#125;</span><br><span class="line">        integerList.add(candidates[i]);</span><br><span class="line">        f(res,integerList,candidates,target-candidates[i],i);</span><br><span class="line">        integerList.remove(integerList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；</p></li><li><p>组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量（就是上面用的index）。</p></li></ul><p>下面详细介绍一下<strong>回溯算法与深度优先遍历</strong></p><ul><li>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将<strong>取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</li></ul><p>​找到一个可能存在的正确的答案；<br>​在尝试了所有可能的分步方法后宣告该问题没有答案。</p><ul><li>深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 <strong>尽可能深</strong> 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将<strong>回溯到发现结点 v 的那条边的起始结点</strong>。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</li></ul><ol start="20"><li><p>全排列（46）：</p><p>用这道题来与上面那道组数总和的回溯算法进行对比，再次深刻理解一下回溯算法和深度优先遍历（DFS）</p><p>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p><p>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422115357752.png" alt="image-20220422115357752"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; integerList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] isUsed, <span class="type">int</span> countNum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (countNum == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(integerList));<span class="comment">//每次添加到结果列表中进行拷贝会节省时间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsed[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        integerList.add(nums[i]);</span><br><span class="line">        isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">        dfs(res, integerList, nums, isUsed, countNum + <span class="number">1</span>);</span><br><span class="line">        isUsed[i] = <span class="literal">false</span>;<span class="comment">//回溯之前清除这一次操作的影响</span></span><br><span class="line">        integerList.remove(integerList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>说明</strong>：</p><p>​每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>​使用深度优先遍历有「回头」的过程，<strong>在「回头」以后， 状态变量需要设置成为和先前一样</strong> ，因此在回到上一层结点的过程中，需要<strong>撤销上一次的选择</strong>，这个操作称之为「状态重置」；<br>​深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：<strong>往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；</strong><br>​深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>​使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><p>​<strong>设计状态变量</strong></p><p>​首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；<br>​递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们<strong>需要一个变量来表示当前程序递归到第几层</strong>，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；<br>​布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。<br>​这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><p>​<strong>每一次尝试都「复制」，则不需要回溯</strong></p><p>​如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么在回到上一层结点的时候不需要「回溯」；在递归终止的时候也不需要做拷贝。<br>​这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p><p>​<strong>剪枝</strong></p><p>​回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>​提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。</p><p>​<strong>总结</strong></p><p>​做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>​在画图的过程中思考清楚：</p><p>​分支如何产生；题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p><ol start="21"><li><p>接雨水(42):</p><p>方法一：</p><p>按行求，先求出数组的最大的高度，然后遍历数组，从最高的一层开始，计算每一层的积水量，思路比较简单，下面贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="comment">//一层一层的计算，这样直接模拟会超时，这是按行求的做法</span></span><br><span class="line">    <span class="type">int</span> maxHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i]&gt;maxHeight)&#123;</span><br><span class="line">            maxHeight=height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tempMax=maxHeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxHeight; i++) &#123;</span><br><span class="line">        <span class="type">int</span> leftIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[j]==tempMax)&#123;</span><br><span class="line">                leftIndex=j;</span><br><span class="line">                height[j]--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> leftIndex+<span class="number">1</span>; k &lt; height.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (height[k]==tempMax)&#123;</span><br><span class="line">                        res+=k-leftIndex-<span class="number">1</span>;</span><br><span class="line">                        leftIndex=k;</span><br><span class="line">                        height[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tempMax--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>按列求，求每一列的水，我们只需要关注当前列，以及左边最高的墙，右边最高的墙就够了。装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以分为两种情况。</p><ul><li>较矮的墙的高度大于当前列的墙的高度，此时积水量就是较矮的墙的高度减去当前列的墙的高度</li><li>较矮的墙的高度小于或等于当前列的墙的高度，此时无法积水</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indexHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//直接按列计算也会超时，但可以用动态规划进行优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexHeight=height[i];</span><br><span class="line">        <span class="type">int</span> leftHeightMax=<span class="number">0</span>,rightHeightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;leftHeightMax)&#123;</span><br><span class="line">                    leftHeightMax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;rightHeightMax)&#123;</span><br><span class="line">                    rightHeightMax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minHeight=Math.min(leftHeightMax,rightHeightMax);</span><br><span class="line">        <span class="keyword">if</span> (minHeight&gt;indexHeight)&#123;</span><br><span class="line">            res+=minHeight-indexHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><p>使用动态规划对方法二按列求的方法进行优化</p><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p><p>对于 max_left我们其实可以这样求。</p><p>max_left [i] &#x3D; Max(max_left [i-1],height[i-1])。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p><p>对于 max_right我们可以这样求。</p><p>max_right[i] &#x3D; Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="comment">//dp做法</span></span><br><span class="line">    <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];<span class="comment">//初始化都是0</span></span><br><span class="line">    <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">    <span class="type">int</span> indexHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; maxLeft.length; i++) &#123;<span class="comment">//从左往右求</span></span><br><span class="line">        maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> maxLeft.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从右往左求</span></span><br><span class="line">        maxRight[i]=Math.max(maxRight[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexHeight=height[i];</span><br><span class="line">        <span class="type">int</span> minHeight=Math.min(maxLeft[i],maxRight[i]);<span class="comment">//直接查表得出两边较矮的高度</span></span><br><span class="line">        <span class="keyword">if</span> (minHeight&gt;indexHeight)&#123;</span><br><span class="line">            res+=minHeight-indexHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：</p><p><strong>双指针优化动态规划</strong></p><p>我们先明确几个变量的意思：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left_max：左边的最大值，它是从左往右遍历找到的</span><br><span class="line">right_max：右边的最大值，它是从右往左遍历找到的</span><br><span class="line"><span class="attribute">left</span>：从左往右处理的当前下标</span><br><span class="line"><span class="attribute">right</span>：从右往左处理的当前下标</span><br></pre></td></tr></table></figure><p>定理一：在某个位置<code>i</code>处，它能存的水，取决于它左右两边的最大值中较小的一个。</p><p>定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）</p><p>定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                                   right_max</span><br><span class="line"> left_max                             __</span><br><span class="line">   __                                |  |</span><br><span class="line">  |  |__   __??????????????????????  |  |</span><br><span class="line">__|     |__|                       __|  |__</span><br><span class="line">        left                      right</span><br></pre></td></tr></table></figure><p>对于位置<code>left</code>而言，它左边最大值一定是left_max，右边最大值<strong>大于等于</strong>right_max，这时候，如果<code>left_max&lt;right_max</code>成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当<code>left_max&lt;right_max</code>时，我们就希望去处理left下标，反之，我们希望去处理right下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">1</span>, right = height.length - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> height[<span class="number">0</span>], rightMax = height[height.length - <span class="number">1</span>];<span class="comment">//初始化左边最大高度和右边最大高度</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//等于是保证最后一列也会被处理</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;<span class="comment">//先判断能不能积水再对左边最大高度进行更新</span></span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">            &#125;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//leftMax&gt;=rightMax</span></span><br><span class="line">            <span class="keyword">if</span> (rightMax&gt;height[right])&#123;</span><br><span class="line">                res+=rightMax-height[right];</span><br><span class="line">            &#125;</span><br><span class="line">            rightMax = Math.max(rightMax,height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：</p><p>使用<strong>栈</strong>，说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。我们用栈保存每堵墙。</p></li></ol><p>​当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>​如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>​总体的原则就是，当前高度小于等于栈顶高度，入栈，指针后移。当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p><p>​而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离。可以根据下面这个图自己推导（验证）一下计算方法即可</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422162412824.png" alt="image-20220422162412824"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> current=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current&lt;height.length)&#123;</span><br><span class="line">        <span class="comment">//当前高度大于栈顶的高度</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;height[current]&gt;height[stack.peek()])&#123;</span><br><span class="line">            <span class="type">int</span> h=height[stack.pop()];<span class="comment">//每次遍历的 height[i]</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果栈为空直接将此时的current入栈即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> distance=current-stack.peek()-<span class="number">1</span>;<span class="comment">//计算两堵墙之间的距离</span></span><br><span class="line">            <span class="type">int</span> min=Math.min(height[current],height[stack.peek()]);<span class="comment">//取两堵墙的较矮的一堵墙的高度</span></span><br><span class="line">            res+=distance*(min-h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current);</span><br><span class="line">        current++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="22"><li><p>旋转图像(48):</p><p>方法一：使用辅助数组</p><p>对于矩阵中第 i 行的第 j个元素，在旋转后，它出现在倒数第 i 列的第 j个位置，即第j行第n-i-1列。这样以来，我们使用一个与 matrix 大小相同的辅助数组 newMatrix 临时存储旋转后的结果。我们遍历 matrix 中的每一个元素，根据上述规则将该元素存放到 newMatrix 中对应的位置。在遍历完成之后，再将 newMatrix 中的结果复制到原数组中即可。代码比较简单就不放上来了</p><p>方法二：原地旋转</p><p><strong>想出方法一中的等式很重要</strong></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224637149.png" alt="image-20220422224637149"></p></li></ol><p>​不断重复此过程，就可以发现这四项处于一个循环中，并且每一项旋转后的位置就是下一项所在的位置</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224751882.png" alt="image-20220422224751882"></p><p>​当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224901047.png" alt="image-20220422224901047"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224918636.png" alt="image-20220422224918636"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n+<span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//如果n是奇数，(n-1)/2=n/2</span></span><br><span class="line">            <span class="comment">//如果n是偶数，(n+1)/2=n/2</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法三：用翻转代替旋转</p><p>​可以通过先进行水平翻转，再进行对角线翻转得到结果。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422225301778.png" alt="image-20220422225301778"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=matrix.length;</span><br><span class="line">    <span class="comment">//水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n-i-<span class="number">1</span>][j];</span><br><span class="line">            matrix[n-i-<span class="number">1</span>][j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="23"><li><p>字母异位词分组(49)：</p><p>两个字符串互为字母异位词，当且仅当<strong>两个字符串包含的字母相同</strong>。同一组字母异位词中的字符串具备相同特征，可以使用相同特征作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键，也就是用排序和计数两种方式求出的对应的字符串的特征来作为哈希表的键。代码可以很好的复习一下Java的集合的使用。</p><p>方法一：排序</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将<strong>排序之后的字符串</strong>作为哈希表的键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str :</span><br><span class="line">         strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        String key=<span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">        <span class="comment">//getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</span></span><br><span class="line">        <span class="comment">//hashmap.getOrDefault(Object key, V defaultValue)</span></span><br><span class="line">        List&lt;String&gt; list=map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：计数</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str :</span><br><span class="line">         strs) &#123;</span><br><span class="line">        <span class="type">int</span>[] counts=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            counts[str.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">        StringBuffer stringBuffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                stringBuffer.append((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i));</span><br><span class="line">                stringBuffer.append(counts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String key=stringBuffer.toString();</span><br><span class="line">        List&lt;String&gt; list=map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key,list);<span class="comment">//设置哈希表的键值对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大子数组和(53)：</p><p>方法一：动态规划</p><p>设计状态思路：<strong>把不确定的因素确定下来</strong>，进而<strong>把子问题定义清楚，把子问题定义得简单</strong>。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>编写动态规划解题的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><p>定义状态（定义子问题）</p><p><code>dp[i]</code>：表示以 <code>nums[i]</code> <strong>结尾</strong> 的 <strong>连续</strong> 子数组的最大和。</p><p><strong>说明</strong>：「结尾」和「连续」是关键字。</p><p>状态转移方程（描述子问题之间的联系）</p><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><ul><li>如果 <code>dp[i - 1] &gt; 0</code>，那么可以把 <code>nums[i]</code> 直接接在 <code>dp[i - 1]</code> 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 dp[i - 1] &lt;&#x3D; 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</li></ul><p>以上两种情况的最大值就是 <code>dp[i]</code> 的值，写出如下状态转移方程：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423152015663.png" alt="image-20220423152015663"></p><p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423152050928.png" alt="image-20220423152050928"></p><p>友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。</p><p>思考初始值</p><p><code>dp[0]</code> 根据定义，只有 1 个数，一定以 <code>nums[0]</code> 结尾，因此 <code>dp[0] = nums[0]</code>。</p><p>思考输出</p><p><strong>注意</strong>：这里状态的定义不是题目中的问题的定义，<strong>不能直接将最后一个状态返回回去</strong>，而要返回dp数组的最大值</p></li><li><p>跳跃游戏(55)：</p><p>方法一：</p><p>根据题目所给条件<code>0 &lt;= nums[i] &lt;= 105</code>，如果数组中的数字全大于0，那么每次跳一步一定可以到达终点，那么就只需判断等于0的位置，看在等于0的位置前面有没有位置可以跳过0，这样又能化归到全部大于0的情况，<del>偷鸡做法</del>。</p><blockquote><p>开始想用回溯法来做，会超时，思路是从起点开始遍历所有可能走的情况看最终能不能走到终点，类似dfs</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//[2,0,0]，这种情况需要特别判断</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp=i-<span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> canJumpZero=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//如果从temp位置可以直接跳到结尾当然也能跳过0，这是防止结尾的数是0导致算法不正确</span></span><br><span class="line">                <span class="keyword">if</span> (nums[temp]&gt;=i-temp+<span class="number">1</span>||nums[temp]&gt;=nums.length-<span class="number">1</span>-temp)&#123;</span><br><span class="line">                    canJumpZero=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!canJumpZero)&#123;<span class="comment">//不能跳过零就会卡在零的位置直接返回false即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：贪心</p><p>设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即x+nums[x]≥y，那么位置 y 也可以到达。</p><p>换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p><p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。</p><p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p><p>以题目中的示例一[2, 3, 1, 1, 4]为例：</p><p>我们一开始在位置 0，可以跳跃的最大长度为 2，因此最远可以到达的位置被更新为 2；</p><p>我们遍历到位置 1，由于1≤2，因此位置 1 可达。我们用 1 加上它可以跳跃的最大长度 3，将最远可以到达的位置更新为 1+3&#x3D;4。由于 4 大于等于最后一个位置 4，因此我们直接返回 True。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> canReach=cur+nums[cur];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canReach&gt;= nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//稍微优化一下，如果能够到达终点就直接返回true了不要继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canReach&gt;=i)&#123;</span><br><span class="line">            canReach=Math.max(canReach,i+nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并区间(56)：</p><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423194439426.png" alt="image-20220423194439426"></p><p>我们用数组 merged 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li><p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p></li><li><p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。举几个例子，<code>[1,3] 和 [3,6]</code>，<code>[1,3]和[2,6]</code>，但当前区间的左端点一定小于数组末尾的左端点，因为前面已经排过序了</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);<span class="comment">//按照数组的第一个元素升序排序</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> left=intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> right=intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//当前区间的左端点在数组 merged 中最后一个区间的右端点之后</span></span><br><span class="line">        <span class="keyword">if</span> (merged.size()==<span class="number">0</span>||merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>]&lt;left)&#123;</span><br><span class="line">            merged.add(intervals[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//重置数组末尾的右端点</span></span><br><span class="line">            merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>]=Math.max(merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>],right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同路径(62)：</p><p>方法一：递归，<del>虽然不能AC</del>还是贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] paths)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == m &amp;&amp; y == n) &#123;</span><br><span class="line">        paths[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; m || y &gt; n) &#123;</span><br><span class="line">        <span class="comment">//越界就直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    findPaths(m, n, x + <span class="number">1</span>, y, paths);<span class="comment">//向下走</span></span><br><span class="line">    findPaths(m, n, x, y + <span class="number">1</span>, paths);<span class="comment">//向右走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] paths = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];<span class="comment">//传数组进去是为了能在函数里面修改值</span></span><br><span class="line">    findPaths(m, n, <span class="number">1</span>, <span class="number">1</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> paths[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>用f（i，j）表示从左上角走到第i行第j列位置的路径总数，1&#x3D;&lt;i&lt;&#x3D;m，1&#x3D;&lt;j&lt;&#x3D;n</p><p>由于我们每一步只能从向下或者向右移动一步，因此要想走到 (i, j)，如果向下走一步，那么会从 (i-1, j) 走过来；如果向右走一步，那么会从 (i, j-1) 走过来。</p><p>因此我们可以写出动态规划转移方程：<code>f(i, j) = f(i-1, j) + f(i, j-1)</code><br>需要注意<strong>初始条件</strong>，dp [1] [1] &#x3D; 1，表示从（1，1）走到（1，1）有一种走法，这是为了保证m和n等于一时代码也是正确的，其次是第一行和第一列都是1，因为只能向右走和向下走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>动态规划的解题套路</strong></p><p>什么样的问题可以考虑使用动态规划解决呢？</p><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。比如一些求最值的场景，如<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等等，都是动态规划的经典应用场景。</p><p>动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里总结了一下我做动态规划的思路：</p><ul><li>穷举分析</li><li>确定边界</li><li>找出规律，确定最优子结构</li><li>写出状态转移方程</li></ul><p><strong>动态规划是自底向上解决问题，递归是自顶向下解决问题</strong></p></li><li><p>最小路径和(64)：</p><p>与62题的动态规划大同小异，由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p><p>创建二维数组 dp，与原始网格的大小相同，dp [i] [j] 表示从左上角出发到 (i,j) 位置的最小路径和。显然，dp[0] [0]&#x3D;grid[0] [0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。</p><p>当 i&gt;0 且 j&#x3D;0 时，<code>dp [i] [j]=dp [i-1] [0]+grid[i] [0]</code></p><p>当 i&#x3D;0 且 j&gt;0 时，<code>dp [i] [j]=dp[0] [j-1]+grid[0] [j]</code></p><p>当 i&gt;0 且 j&gt;0 时，<code>dp[i] [j]=Math.min(dp[i-1] [j],dp[i] [j-1])+grid[i] [j]</code></p><p>最后得到 dp[m-1] [n-1] 的值即为从网格左上角到网格右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>爬楼梯(70)：</p><p>方法一：动态规划</p><p>经典的动态规划和递归的问题，比较简单直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：矩阵快速幂</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423221916169.png" alt="image-20220423221916169"></p><p>快速幂算法求$M^n$可以使时间复杂度降为O(log n),下面简单介绍一下快速幂算法</p><p><strong>递归快速幂</strong></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423230325266.png" alt="image-20220423230325266"></p><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n&#x2F;2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> qpow(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> qpow(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把quickPow算出的结果记录下来，直接写成quickPow(a, n &#x2F;2)*quickPow(a, n &#x2F;2)，那会计算两次a^(n&#x2F;2)，整个算法就退化为了 O(n)。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><p>递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><p><strong>非递归快速幂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;       <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;<span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码可以作为非递归快速幂的模板代码，尽量记住</p><p>矩阵的快速幂只需要把上面代码中的乘法改成矩阵乘法，把ans初始化为单位矩阵即可，下面贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] matrixMultiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">    <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] quickPow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//初始化为单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = matrixMultiply(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a = matrixMultiply(a, a);<span class="comment">//a=a*a</span></span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] res = quickPow(matrix, n);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>][<span class="number">0</span>]+res[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑距离(72)：</p><p>动态规划问题，dp[i] [j]表示word1中长度为i的字符串（下标从 0 到 i-1 ）转换成word2中长度为j的字符串（下标从 0 到 j-1 ）所需要的最小步数。</p><p>状态转移方程：</p><p>当 <code>word1[i] == word2[j]，dp[i] [j] = dp[i-1] [j-1]</code>；</p><p>当 <code>word1[i] != word2[j]，dp[i] [j] = min(dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]) + 1</code></p><p>其中，<code>dp[i-1] [j-1]</code>表示<strong>替换</strong>word1[i-1]为word2[j-1]操作，<code>dp[i-1] [j]</code> 表示<strong>删除</strong>word1[i-1]操作，<code>dp[i] [j-1]</code> 表示在word1后<strong>插入</strong>word[j-1]操作。三种操作中取步骤数最小的然后加上本次操作。 </p><p>注意，针对第一行，第一列要单独考虑，我们引入 <code>&#39;&#39;</code> 下图所示：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220424201017152.png" alt="image-20220424201017152"></p><p>第一行，是 <code>word1</code> 为空变成 <code>word2</code> 最少步数，就是插入操作</p><p>第一列，是 <code>word2</code> 为空，需要的最少步数，就是删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="comment">//动态规划，dp数组里的i j分别表示word1和word2的长度</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word1.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word1.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; word2.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>颜色分类(75)：</p><p>方法一：<del>偷鸡做法</del></p><p>因为一共只有三种ya颜色分别是0，1，2，所以遍历一遍原数组找出每种颜色有多少，在按照题目要求的颜色的顺序填回到原数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] colors=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        colors[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> indexColors=<span class="number">0</span>,indexRes=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexColors&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (colors[indexColors]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[indexRes]=indexColors;</span><br><span class="line">            colors[indexColors]--;</span><br><span class="line">            indexRes++;</span><br><span class="line">        &#125;</span><br><span class="line">        indexColors++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>直接<del>调用排序AP</del>I来做就好，自己手写排序算法即可</p></li><li><p>最小覆盖子串(76)：<strong>滑动窗口</strong></p><p>本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<strong>我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。如果收缩后不满足条件，则让r指针不断扩张窗口，寻找新的满足条件的滑动窗口。</strong>一直重复此过程直到 j 超出了字符串 S 范围。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220425220202755.png" alt="image-20220425220202755"></p><p>这道题目的解题代码中就用了两个HashMap来实现并维护s中出现的需要的字符数量表（简称已有字符表），实现了一次遍历统计出t中每个字符的数量（简称所需字符表），可以好好领悟一下HashMap的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinWindow</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; ori = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="literal">null</span>|| s.equals(<span class="string">&quot;&quot;</span>) ||t==<span class="literal">null</span>||t.equals(<span class="string">&quot;&quot;</span>)||s.length()&lt;t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tLen=t.length();</span><br><span class="line">        <span class="comment">//利用HashMap的特点统计t中每个字符出现的次数，getOrDefault经典操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c=t.charAt(i);</span><br><span class="line">            ori.put(c, ori.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l窗口的左边界，r窗口的右边界,r初始化为-1是为了匹配下面while循环一开始就r++，len是窗口的最小长度</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len=Integer.MAX_VALUE,ansL=-<span class="number">1</span>,ansR=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sLen=s.length();</span><br><span class="line">        <span class="keyword">while</span> (r&lt;sLen)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//向右扩展一格窗口，如果此时右边界的字符是所需要的字符，则更新已有字符表</span></span><br><span class="line">            <span class="keyword">if</span> (r&lt;sLen&amp;&amp; ori.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                cnt.put(s.charAt(r),cnt.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check满足条件后才开始不断收缩左边界直到不满足包含t中所有字符</span></span><br><span class="line">            <span class="comment">//l&lt;=r,窗口会不断收缩l++但l不能超过r可以等于r</span></span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123;</span><br><span class="line">                <span class="keyword">if</span> (r-l+<span class="number">1</span>&lt;len)&#123;<span class="comment">//更新窗口的最小长度</span></span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩的过程中如果左边界的字符是t所需要的，l++后该字符就没有了，需要更新已有字符表</span></span><br><span class="line">                <span class="keyword">if</span> (ori.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    cnt.put(s.charAt(l),cnt.get(s.charAt(l))-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ansL==-<span class="number">1</span>&amp;&amp;ansR==-<span class="number">1</span>)?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry :</span><br><span class="line">             ori.entrySet()) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            Integer value= entry.getValue();</span><br><span class="line">            <span class="comment">//s的子串的某些字符的数量大于等于t中每一个字符的数量都是可以的，但如果某一个小于就不符合条件了</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(key,<span class="number">0</span>)&lt;value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子集(78)：</p><p>方法一：迭代法实现子集枚举</p><p>用01序列表示特征函数，1表示该位置的数在子集里，0表示该位置的数不在子集里，可以发现 01 序列对应的二进制数正好从 0 到 2^n - 1，这样我们可以吗，枚举完所有的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span>[] index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index.length; i++) &#123;<span class="comment">//枚举01序列的函数</span></span><br><span class="line">        <span class="keyword">if</span> (index[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//00 10 01 11</span></span><br><span class="line">    <span class="comment">//000 100 010 110 001 101 011 111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, nums.length);<span class="comment">//计算出需要枚举的次数</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; index.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        update(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归法实现子集枚举</p><p>对于集合中的每一个数，只有两种情况，选取该数字加入子集中，不选取该数字，和上面的01序列相似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp,<span class="type">int</span> cur,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur== nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.add(nums[cur]);<span class="comment">//取当前位置的数字</span></span><br><span class="line">    dfs(res, temp, cur+<span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size()-<span class="number">1</span>);<span class="comment">//不取当前位置的数字</span></span><br><span class="line">    dfs(res, temp, cur+<span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(res,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),<span class="number">0</span>,nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单词搜索(79)：</p><p>与递归走迷宫类似，从某一个起点出发，递归的向上走，向下走，向左走，向右走，看四个方向的哪个方向可以满足单词的字符，如果都不能满足直接返回false即可，还要注意不能走回头，走过的路不能重复再走一次，需要维护一个<code>boolean[] isVisited</code>，访问过就标记为已访问。如果此路不通则要回退为没用访问过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exist</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findWord</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> wordIndex, <span class="type">boolean</span>[][] isVisited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordIndex == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//搜索到单词的末尾返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt; board.length &amp;&amp; board[x + <span class="number">1</span>][y] == word.charAt(wordIndex) &amp;&amp; !isVisited[x + <span class="number">1</span>][y]) &#123;</span><br><span class="line">            isVisited[x + <span class="number">1</span>][y] = <span class="literal">true</span>;<span class="comment">//先标记为已访问再递归进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x + <span class="number">1</span>, y, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x + <span class="number">1</span>][y] = <span class="literal">false</span>;<span class="comment">//如果此路不通需要回退为没用访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x - <span class="number">1</span>][y] == word.charAt(wordIndex) &amp;&amp; !isVisited[x - <span class="number">1</span>][y]) &#123;</span><br><span class="line">            isVisited[x - <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x - <span class="number">1</span>, y, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x - <span class="number">1</span>][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt; board[<span class="number">0</span>].length &amp;&amp; board[x][y + <span class="number">1</span>] == word.charAt(wordIndex) &amp;&amp; !isVisited[x][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            isVisited[x][y + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x, y + <span class="number">1</span>, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x][y + <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x][y - <span class="number">1</span>] == word.charAt(wordIndex) &amp;&amp; !isVisited[x][y - <span class="number">1</span>]) &#123;</span><br><span class="line">            isVisited[x][y - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x, y - <span class="number">1</span>, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x][y - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length * board[<span class="number">0</span>].length &lt; word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断特殊情况直接返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Point&gt; points = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    points.add(<span class="keyword">new</span> <span class="title class_">Point</span>(i, j));<span class="comment">//找到满足第一个字符的所有位置，依次从这些位置开始搜索</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Point start :</span><br><span class="line">             points) &#123;</span><br><span class="line">            <span class="type">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">            isVisited[start.x][start.y] = <span class="literal">true</span>;<span class="comment">//将起始位置标记为已访问，这一步很重要!</span></span><br><span class="line">            <span class="comment">//防止后面递归搜索路径的时候又搜索到开始的位置</span></span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, start.x, start.y, <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//有一条路存在直接返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>柱状图中最大的矩形(84)：这道题可以好好的理解一下<strong>单调栈</strong></p><p>方法一：暴力模拟（超时）</p><p>依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。</p><p>为此，我们需要：</p><p>左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</p><p>右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。</p><p>对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= heights[i]) &#123;<span class="comment">//先判断前一位是否满足条件再left--</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right + <span class="number">1</span> &lt; len &amp;&amp; heights[right + <span class="number">1</span>] &gt;= heights[i]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heights[i] * (right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; res) &#123;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：<strong>单调栈</strong></p><p>先说明一下单调栈是什么</p><ul><li>单调递增栈：从<strong>栈底到栈顶</strong>，栈中的值单调递增</li><li>单调递减栈：从<strong>栈底到栈顶</strong>，栈中的值单调递减</li></ul><p>单调栈则主要用于解决<strong>NGE问题</strong>（Next Greater Element），也就是，对序列中每个元素，找到下一个比它大的元素。（当然，“下一个”可以换成“上一个”，“比它大”也可以换成“比他小”，原理不变。）</p><p>我们维护一个栈，表示“<strong>待确定NGE的元素</strong>”，然后遍历序列。当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的NGE，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p><p>我们归纳一下枚举「高」的方法：</p><p>首先我们枚举某一根柱子 i 作为高 h&#x3D;heights[i]；</p><p>随后我们需要进行向左右两边扩展，使得<strong>扩展到的柱子的高度均不小于 h</strong>。换句话说，我们需要<strong>找到左右两侧最近的高度小于 h 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 h，并且就是 i 能够扩展到的最远范围。</p><p>那么我们先来看看如何求出<strong>一根柱子的左侧且最近的小于其高度的柱子</strong>，可以用单调递增栈来实现，栈中存放的是每根柱子的下标</p><p>栈中存放了 j 值。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</p><p>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 height[j]≥height[i] 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 height[j]&lt;height[i]，此时 j 就是 i 左侧且最近的小于其高度的柱子，我们再将 i 放入栈顶。</p><p>这里会有一种特殊情况。如果我们移除了栈中所有的 j 值，那就说明 i 左侧所有柱子的高度都大于等于 height[i]，那么我们可以认为 i 左侧且最近的小于其高度的柱子在位置 j&#x3D;-1，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。相对应的最右侧也会有哨兵。</p><p>下面的代码是通过从左向右和从右向左两次遍历分别求出一根柱子的左侧且最近的小于其高度的柱子，一根柱子的右侧且最近的小于其高度的柱子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            left[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            right[i] = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.max(res, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了两次遍历之外，我们还可以对该方法进行优化，只用一次遍历就找出left和right数组.</p><p>在方法一中，我们在对位置 i 进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置 i 进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置 i 被弹出栈时，说明此时遍历到的位置的高度小于等于 height[i]，并且在 i0 与 i 之间没有其他高度小于等于 height[i] 的柱子。这是因为，如果在 i 和i0之间还有其它位置的高度小于等于 height[i] 的，那么在遍历到那个位置的时候，i 应该已经被弹出栈了。所以位置 i0就是位置 i的右边界。</p><p>等等，我们需要的是「一根柱子的左侧（或右侧）且最近的小于其高度的柱子」，但这里我们求的是小于等于，那么会造成什么影响呢？答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界</strong>的，而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。下面举一个例子来说明这一点</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220502225551702.png" alt="image-20220502225551702"></p><p>该算法有两个规则：</p><ul><li>当有柱子假设为柱子i入栈时，栈顶的柱子就是柱子i的左边界（因为是单调递增栈）</li><li>当有柱子（记为柱子i）出栈时，此时遍历到的柱子（记为index）的高度小于等于柱子i，柱子i的右边界为柱子index</li></ul><p>首先要明确当有柱子出栈和入栈时，可以确定柱子的左边界或右边，还要时刻记得栈中的数据从栈底到栈顶是严格递增的。如上图所示，当我们遍历到柱子4的时候，栈中只有柱子3（因为柱子4最近的小于其高度的柱子是柱子3，如果不明白可以从头开始推），我们将柱子4入栈，那么可以确定柱子4的左边界为柱子3，然后遍历到柱子5，此时柱子5的高度大于等于柱子4，柱子4将出栈，按照规则此时可以确定柱子4的右边界是柱子5（虽然柱子5不是右边最近的小于其高度的柱子，耐心接着往下看），然后柱子5比栈中的柱子3高，柱子5入栈，此时可以确定柱子5的左边界是柱子3，然后接着遍历到了柱子6，柱子6的高度小于此时栈顶柱子（为柱子5）的高度，柱子5出栈，可以确定柱子5的右边界为柱子6，所以柱子5的边界为柱子3和柱子6，虽然柱子4的右边界不正确。至此就可以理解如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界</strong>的.</p><p>在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 n 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=heights.length;</span><br><span class="line">    <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(right,n);<span class="comment">//初始化右边界哨兵为n</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;=heights[i])&#123;</span><br><span class="line">            right[stack.peek()]=i;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            left[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i]=stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res=Math.max(res,(right[i]-left[i]-<span class="number">1</span>)*heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大矩形(85)：</p><p>如果能发现这道题是上一题的一个变种就比较好做，题目要求的是在二维矩阵中找出最大矩形，可以<strong>一行一行的看</strong>，当作是<strong>在一维数组中找到最大的矩形</strong>，如下图所示</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507143621905.png" alt="image-20220507143621905"></p><p>需要注意的是，比如说以第四行为坐标轴的时候，第四行第二列的元素为0，那么这一行的高度就为0，而不要考虑上面有多高，不会出现悬浮的列，这样才能和84题统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=heights.length;</span><br><span class="line">    <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(right,n);<span class="comment">//记得初始化右哨兵为n</span></span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//依旧是单调栈解法找出第一个比他小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;=heights[i])&#123;</span><br><span class="line">            right[stack.pop()]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            left[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i]=stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res=Math.max(res,heights[i]*(right[i]-left[i]-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] heights=<span class="keyword">new</span> <span class="title class_">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                heights[j]+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                heights[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxArea=Math.max(maxArea,largestRectangleArea(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的中序遍历(94)：</p><p>简单题，一定要记得二叉树的三种递归遍历方式</p></li><li><p>不同的二叉搜索树(96)：</p><p>这道题是一个<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin">卡塔兰树</a>问题，<del>虽然我不知道卡塔兰树</del></p><p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)。</p><p>可见，G(n) 是我们求解需要的函数。稍后我们将看到，G(n) 可以从 F(i, n) 得到，而 F(i, n)又会递归地依赖于 G(n)。不同的二叉搜索树的总数 G(n)，是对遍历所有 i (1≤i≤n) 的 F(i, n) 之和。对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：G(0)&#x3D;1,G(1)&#x3D;1</p><p>给定序列 1 2 3 ⋯ n，我们选择数字 i 作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507211036783.png" alt="image-20220507211036783"></p><p>注意到 G(n)和序列的内容无关，只和序列的长度有关。 因此，我们可以得到以下公式：</p><p><code>F(i, n) = G(i-1)*G(n-i)</code><br>最终G(n)的递归表达式为：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507211414749.png" alt="image-20220507211414749"></p><p>至此，我们从小到大计算 G函数即可，因为 G(n)的值依赖于 G(0)⋯G(n−1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证二叉搜索树(98)：</p><p>方法一：递归</p><p>由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p><p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p><p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode node,<span class="type">long</span> low,<span class="type">long</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val&lt;=low||node.val&gt;=high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(node.left,low,node.val)&amp;&amp;helper(node.right,node.val,high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root,Long.MIN_VALUE,Long.MAX_VALUE);<span class="comment">//取为long防止数据过大达到int的最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种递归的方式，中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;<span class="comment">//初始化前驱结点的值为最小值保证根结点处的正确性</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;<span class="comment">//向右递归时，将此时的结点作为pre结点</span></span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>二叉搜索树中序遍历得到严格升序的序列，对给定的二叉树中序遍历，结果记录于res之中，检验res是否为严格的升序，若是则为true，反之false。因为中序遍历得到的序列（记为res）一定严格递增，所以如果有一处位置i不满足单调递增，一定有res[i]&gt;&#x3D;res[i+1]，换句话说就是不满足递增的位置一定是相邻的两个位置，假设位置不相邻，比如序列 i , j , k，res[i]&gt;&#x3D;res[k]，但是res[j]&gt;&#x3D;res[i]，所以res[j]&gt;&#x3D;res[k]，所以一定可以找到一个不满足递增的相邻位置。</p><p>这一点上有时候直觉（直接的感觉）挺有用的，可以先按照直觉写出代码跑一下，如果不正确根据错误用例来改就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inorderTraversal(root, res);</span><br><span class="line">    Integer[] seq = <span class="keyword">new</span> <span class="title class_">Integer</span>[res.size()];</span><br><span class="line">    res.toArray(seq);</span><br><span class="line">    <span class="comment">//遍历一次如果有相邻的两个数不满足单调递增直接返回false即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seq.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[i] &gt;= seq[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的层序遍历(102)：广度优先搜索</p><p>首先根元素入队<br>当队列不为空的时候</p><ul><li>求当前队列的长度 si </li><li>依次从队列中取 si个元素进行拓展，然后进入下一次迭代</li></ul><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里<strong>每次取 si个元素</strong>。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="keyword">while</span> (deque.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeCount</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodeCount; i++) &#123;<span class="comment">//每次取si个元素进行扩展</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;<span class="comment">//左子节点为空或右子节点为空就不要加入队列</span></span><br><span class="line">                deque.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的最大深度(104)：</p><p>方法一：深度优先搜索</p><p>如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为<code>max(l,r)+1</code></p><p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1)时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。<strong>这是求二叉树深度的经典算法最好背下来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从前序与中序遍历序列构造二叉树(105)：</p><p>方法一：递归</p><p>对于任意一颗树而言，前序遍历的形式总是 [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p><strong>细节</strong></p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)的时间对根节点进行定位了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;<span class="comment">//说明此时得到的是叶子结点，直接返回null就行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">    <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inorder_root</span> <span class="operator">=</span> indexMap.get(preorder[preorder_left]);</span><br><span class="line">    <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preorder_left]);</span><br><span class="line">    <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size_left_subtree</span> <span class="operator">=</span> inorder_root - inorder_left;</span><br><span class="line">    <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">    root.left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">    root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">    indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        indexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：迭代</p><p>了解一下，这个做法不一定能想得出来<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p></li><li><p>二叉树展开为链表(114)：</p><p>方法一：前序遍历</p><p>将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。可以通过递归或迭代的方式实现前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        preorder(node.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        preorder(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        cur.left = <span class="literal">null</span>;</span><br><span class="line">        cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(res.get(i));</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：前序遍历和展开同时进行</p><p>使用方法一的前序遍历，由于将节点展开之后会破坏二叉树的结构而丢失子节点的信息，因此前序遍历和展开为单链表分成了两步。能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？</p><p>之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。只要对前序遍历进行修改，<strong>在遍历左子树之前就获得左右子节点的信息</strong>，并存入栈内，子节点的信息就不会丢失，就可以将前序遍历和展开为单链表同时进行。</p><p>该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则<strong>依次将右子节点和左子节点压入栈内（注意入栈顺序）</strong>。</p><p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.left = <span class="literal">null</span>;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> cur.left, right = cur.right;</span><br><span class="line">        <span class="comment">//先压栈的是右节点，然后再压入左节点，出栈是就是先左再右的顺序</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次pre等于null的时候将pre写为cur，不能写成pre=pre.right，第一次pre为null</span></span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：寻找前驱结点</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。找前驱结点在<strong>线索化二叉树</strong>的时候做过，找到叶子结点 的前驱结点和后继结点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点（就是把后继结点挂上去），然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空，（向右展开）。对当前节点处理结束后，继续处理链表中的下一个节点（下一个右子节点），直到所有节点都处理结束。这个地方需要画图好好理解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录下当前结点的左子结点</span></span><br><span class="line">            TreeNode next=cur.left;</span><br><span class="line">            TreeNode pre=next;</span><br><span class="line">           <span class="comment">//对于当前节点cur，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点</span></span><br><span class="line">            <span class="keyword">while</span> (pre.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pre=pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前节点的右子节点赋给前驱节点的右子节点（就是把后继结点挂上去）</span></span><br><span class="line">            pre.right=cur.right;</span><br><span class="line">            <span class="comment">//将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空</span></span><br><span class="line">            cur.left=<span class="literal">null</span>;</span><br><span class="line">            cur.right=next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>买卖股票的最佳时机(121)：</p><p>一道简单题，翻译一下就是找到数组中后一个数与前一个数的最大差值（差值必须是真的，如果只能是负的就返回0），可以通过一次遍历来实现这个结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,buy=prices[<span class="number">0</span>];<span class="comment">//买入的价格初始化为第一天的价格，结果初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果某一天的价格大于买入的价格就尝试卖出，并且和之前卖出的收入进行比较，取收入高的那个</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i]&gt;buy)&#123;</span><br><span class="line">            res=Math.max(res,prices[i]-buy);</span><br><span class="line">        <span class="comment">//如果某天的价格比买入的价格低，那么就应该从这一天买入</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (prices[i]&lt;buy)&#123;</span><br><span class="line">            buy=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树中的最大路径和(124)：</p><p>这题目的难点在于理解题意和转化题意。</p><p><strong>思路</strong></p><ol><li><p>「可以从任意节点出发, 到达任意节点」 的路径,<br>一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点。当我们站在顶点的位置来看，就是向左子树走一条路径，向右子树走一条路径，在左子树中不能既向左走又向右走，这样就无法从左子树走回到右子树了（下面还会仔细说明这个地方）。我们可以通过枚举顶点的方式来枚举路径。</p></li><li><p>我们枚举顶点时, 可以把路径分拆成3部分： 左侧路径、右侧路径和顶点。<br>如下面的路径, 顶点为 20, 左侧路径为 6 -&gt; 15, 右侧为 6 -&gt; 7。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> -10</span><br><span class="line"> /  \</span><br><span class="line">9   20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br><span class="line"> /    / \</span><br><span class="line">6    4   6</span><br></pre></td></tr></table></figure><p>以当前节点为顶点的路径中, 最大和为 两侧路径的最大和 + 节点的值。需要注意的是, 两侧路径也可能不选, 此时取 0</p></li></ol><p><strong>实现细节</strong></p><p>首先，考虑实现一个简化的函数 maxGain(node)，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p><p>具体而言，该函数的计算如下。</p><ul><li><p>空节点的最大贡献值等于 0。</p></li><li><p>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</p></li></ul><p>例如，考虑如下二叉树。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  -10</span><br><span class="line"> /   \</span><br><span class="line">9    20</span><br><span class="line">    /  \</span><br><span class="line">  15    7</span><br></pre></td></tr></table></figure><p>叶节点 9、15、7 的最大贡献值分别为 9、15、7。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 20+max(15,7)&#x3D;35，节点 -10 的最大贡献值等于 −10+max(9,35)&#x3D;25。</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 maxGain，即可得到每个节点的最大贡献值。</p><p>再次说明一下这里的最大贡献值，某一个结点的最大贡献值只能取左子树的最大贡献值和右子树的最大贡献值中较大的一个并且和结点的值相加，然后会将该结果返回到递归的上一层，这样对于上一层来看，拿到的就是左子树的最大贡献值，并且可以从左子树走到这一层的顶点，然后再往右子树走</p><p>根据函数 maxGain 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，<strong>该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</strong>，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> res=Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//保证传入空结点时的正确性</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxGain(root);<span class="comment">//求出每个结点的最大贡献值，这是个递归的过程</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=Math.max(maxGain(node.left),<span class="number">0</span>);<span class="comment">//左结点的最大贡献值如果小于0就不要贡献了，越加越小肯定是不对的</span></span><br><span class="line">    <span class="type">int</span> right=Math.max(maxGain(node.right),<span class="number">0</span>);</span><br><span class="line">    res=Math.max(res,node.val+left+right);</span><br><span class="line">    <span class="keyword">return</span> node.val+Math.max(left,right);<span class="comment">//这里体现了这个递归的精髓</span></span><br><span class="line">    <span class="comment">//将该结点与左子树贡献和右子树贡献最大的一个向上返回（只返回左右子树的一边），对于父亲结点（大问题）来看，就是在父结点中找到了加起来的值最大的一条通路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复盘总结递归</strong><br>递归一个树，会对每个子树做同样的事（你写的处理逻辑），所以你需要思考要对每个子树做什么事，即思考子问题是什么，大问题怎么拆解成子问题。<br>通过求出每个子树对外提供的最大路径和（返回出来给父节点），从递归树底部向上，不断求出了每个子树内部的最大路径和，后者是求解的目标，它的求解需要前者，搞清楚二者的关系。<br>每个子树的内部最大路径和，都挑战一下最大纪录，递归结束时，最大纪录就有了。<br>思考递归问题，别纠结细节实现，内部细节是子递归帮你去做的，应结合求解的目标，自顶而下、屏蔽细节地思考，思考递归子问题的定义。随着递归出栈，子问题自下而上地解决，最后解决了整个问题。<br>要做的只是<strong>写好递归的处理逻辑，怎么处理当前子树？需要返回什么吗？怎么设置递归的出口？</strong><br>没有思路的时候，试着画画递归树找思路。就算做对了，画图也能加深对递归算法的理解。</p><p>画图的时候可以反过来自底向上的画，先画出最简单的情况，然后看得出简单情况的结果后，如果该情况是一个大问题的子问题，那么该子问题可以怎么运用到大问题的解决当中去</p></li><li><p>最长连续序列(128)：</p><p>这是一道很好的使用<strong>哈希表</strong>的题目（<del>虽然我想到了用哈希表但还是没做出来</del>），我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列 x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>那么怎么判断是否跳过呢？由于我们<strong>要枚举的数 x 一定是在数组中不存在前驱数 x−1 的</strong>，不然按照上面的分析我们会从 x-1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1 即能判断是否需要跳过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; numsSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//创建HashSet去重并且实现了HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         nums) &#123;</span><br><span class="line">        numsSet.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> longest=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         numsSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!numsSet.contains(num-<span class="number">1</span>))&#123;<span class="comment">//不存在前继才开始向后枚举</span></span><br><span class="line">            <span class="type">int</span> curLong=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> temp=num+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (numsSet.contains(temp))&#123;</span><br><span class="line">                curLong+=<span class="number">1</span>;</span><br><span class="line">                temp+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            longest=Math.max(longest,curLong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只出现一次的数字(136)：</p><p>方法一：利用HashSet，遍历数组，当该数字出现在HashSet中就将HashSet中的该数字删掉，如果不存在就将该数字加入到HashSet中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">            set.remove(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         set) &#123;</span><br><span class="line">        res=num;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：异或运算</p><p>经典的异或运算的题目，根据异或运算的交换律和结合律，以及下面两条性质<code>A^A=0, A^0=A</code>，对数组中的数字一次进行异或运算，最后得到的值就是结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res=res^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单词拆分(139)：</p><p>方法一：<strong>动态规划</strong></p><p>我们定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i−1] 是否能被空格拆分成若干个字典中出现的单词。从前往后计算考虑转移方程，每次转移的时候我们需要枚举包含位置 i−1 的最后一个单词，看它是否出现在字典中以及除去这部分的字符串是否合法即可。公式化来说，我们需要枚举 s[0..i−1] 中的分割点 j ，看 s[0..j−1] 组成的字符串s<del>1</del>（默认 j &#x3D; 0 时 s<del>1</del> 为空串）和  s[j..i−1] 组成的字符串 s<del>2</del> 是否都合法，如果两个字符串均合法，那么按照定义 s<del>1</del> 和 s<del>2</del> 拼接成的字符串也同样合法。由于计算到 dp[i] 时我们已经计算出了 dp[0..i−1] 的值，因此字符串 s<del>1</del> 是否合法可以直接由 dp[j] 得知，剩下的我们只需要看 s<del>2</del> 是否合法即可，因此我们可以得出如下转移方程：<br><code>dp[i]=dp[j] &amp;&amp; check(s[j..i−1])</code>，其中 check(s[j..i−1]) 表示子串 s[j..i−1] 是否出现在字典中。</p><p>对于检查一个字符串是否出现在给定的字符串列表里一般可以考虑哈希表来快速判断，同时也可以做一些简单的剪枝，枚举分割点的时候倒着枚举，如果分割点 j 到 i 的长度已经大于字典列表里最长的单词的长度，那么就结束枚举，但是需要注意的是下面的代码给出的是不带剪枝的写法。</p><p>对于边界条件，我们定义 dp[0]&#x3D;true 表示空串且合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; stringHashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; stringHashSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环形链表(141)：</p><p>方法一：哈希表</p><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：快慢指针</p><p>本方法需要对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针和慢指针都在位置 head。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">//注意这里只能用do-while循环</span></span><br><span class="line">        <span class="comment">//先进行判断，防止移动快指针的时候出现空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//fast走到结尾则一定没有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//while循环退出说明追上了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环形链表ⅱ</p><p>方法一：哈希表</p><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。代码很简单和上一题差不多，就不放上来了</p><p>方法二：快慢指针</p><p>可以当作一个追及问题来列方程，我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><blockquote><p>解释一下为何慢指针第一圈没走完一定会和快指针相遇： 首先，第一步，快指针先进入环 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇) 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x &#x3D; 0； 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1&#x2F;s，快指针2&#x2F;s，那么追赶需要(n-x)s 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;&#x3D;0（x&#x3D;0会在第二步相遇），则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></blockquote><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b &#x3D; a+(n+1)b+nc。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220514215556947.png" alt="image-20220514215556947"></p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有<br>a+(n+1)b+nc&#x3D;2(a+b)⟹a&#x3D;c+(n−1)(b+c)</p><p>有了 a&#x3D;c+(n-1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow=head,fast=head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next!=<span class="literal">null</span>)&#123;<span class="comment">//特判fast的next是否为空，防止空指针异常</span></span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明没有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">            ListNode ptr=head;</span><br><span class="line">            <span class="keyword">while</span> (ptr!=slow)&#123;</span><br><span class="line">                ptr=ptr.next;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//此时fast=null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LRU缓存(146)：</p><p><strong>哈希表+双向链表</strong></p><p>很好的一道面向对象的题目，同时也考察了Java集合和一些常用的数据结构</p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><p>双向链表<strong>按照被使用的顺序</strong>存储了这些键值对，<strong>靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</strong></p><p>哈希表即为普通的哈希映射（HashMap），<strong>通过缓存数据的键映射到其在双向链表中的位置</strong>。</p><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p><p>对于 get 操作，首先判断 key 是否存在：</p><ul><li><p>如果 key 不存在，则返回 -1；</p></li><li><p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></li></ul><p>对于 put 操作，首先判断 key 是否存在：</p><ul><li><p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p></li><li><p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p></li></ul><p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成。</p><p>小贴士</p><p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。&#x3D;&#x3D;<strong>在链表有关的题目中都可以使用哑结点这个技巧</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        LinkedNode prev;</span><br><span class="line">        LinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, LinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode head, tail;<span class="comment">//head和tail是哑结点，删除和插入的时候要注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">LinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">LinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>排序链表(148)：</p><p>方法一：<strong>自顶向下归并排序</strong></p><p>对链表自顶向下归并排序的过程如下。</p><p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</p><p>对两个子链表分别排序。</p><p>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用合并两个有序链表的做法，将两个有序的子链表进行合并。</p><p>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。下面有一个草图帮助理解该算法</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521160851670.png" alt="image-20220521160851670"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sortList(head,<span class="literal">null</span>);<span class="comment">//排序是不包含第二个参数tail一起的，前一个参数包含后一个不包含</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head,ListNode tail)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//如果传入的是null也在这里统一处理了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next==tail)&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;<span class="comment">//把head的next标记为null，做到真正将子链表分开，方便后面找到中点和merge</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow=head,fast=head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=tail)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast!=tail)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mid=slow;</span><br><span class="line">    ListNode list1=sortList(head,mid);<span class="comment">//排序是不包含第二个参数tail一起的，前一个参数包含后一个不包含</span></span><br><span class="line">    ListNode list2=sortList(mid,tail);</span><br><span class="line">    <span class="keyword">return</span> merge(list1,list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode temp=dummy,temp1=head1,temp2=head2;</span><br><span class="line">    <span class="keyword">while</span> (temp1!=<span class="literal">null</span>&amp;&amp;temp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1.val&lt;=temp2.val)&#123;</span><br><span class="line">            temp.next=temp1;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next=temp2;</span><br><span class="line">            temp2=temp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp1!=<span class="literal">null</span>)&#123;</span><br><span class="line">        temp.next=temp1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        temp.next=temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：自底向上归并排序</p><p>使用自底向上的方法实现归并排序，则可以达到 O(1) 的空间复杂度。</p><p>首先求得链表的长度length，然后将链表拆分成子链表进行合并。具体做法如下。</p><p>用 subLength 表示每次需要排序的子链表的长度，初始时 subLength&#x3D;1。</p><p>每次将链表拆分成若干个长度为subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行合并，合并后即可得到若干个长度为subLength×2 的有序子链表（最后一个子链表的长度可以小于 subLength×2）。合并两个子链表仍然使用 合并两个有序链表的做法。</p><p>将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上归并排序</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先从头向后遍历,统计链表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于统计链表长度</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化 引入dummynode</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 每次将链表拆分成若干个长度为subLen的子链表 , 并按照每两个子链表一组进行合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> <span class="number">1</span>;subLen &lt; length;subLen &lt;&lt;= <span class="number">1</span>)&#123; <span class="comment">// subLen每次左移一位（即sublen = sublen*2） PS:位运算对CPU来说效率更高</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummyHead.next;     <span class="comment">// curr用于记录拆分链表的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;               <span class="comment">// 如果链表没有被拆完</span></span><br><span class="line">            <span class="comment">// 3.1 拆分subLen长度的链表1</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head_1</span> <span class="operator">=</span> curr;        <span class="comment">// 第一个链表的头 即 curr初始的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLen &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++)&#123;     <span class="comment">// 拆分出长度为subLen的链表1</span></span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 拆分subLen长度的链表2</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head_2</span> <span class="operator">=</span> curr.next;  <span class="comment">// 第二个链表的头  即 链表1尾部的下一个位置</span></span><br><span class="line">            curr.next = <span class="literal">null</span>;             <span class="comment">// 断开第一个链表和第二个链表的链接</span></span><br><span class="line">            curr = head_2;                <span class="comment">// 第二个链表头 重新赋值给curr</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; subLen &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>;i++)&#123;      <span class="comment">// 再拆分出长度为subLen的链表2</span></span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3 再次断开 第二个链表最后的next的链接</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">            <span class="keyword">if</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">                next = curr.next;   <span class="comment">// next用于记录 拆分完两个链表的结束位置</span></span><br><span class="line">                curr.next = <span class="literal">null</span>;   <span class="comment">// 断开连接</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.4 合并两个subLen长度的有序链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(head_1,head_2);</span><br><span class="line">            prev.next = merged;        <span class="comment">// prev.next 指向排好序链表的头</span></span><br><span class="line">            <span class="keyword">while</span>(prev.next != <span class="literal">null</span>)&#123;  <span class="comment">// while循环 将prev移动到 subLen*2 的位置后去</span></span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = next;              <span class="comment">// next用于记录 拆分完两个链表的结束位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新排好序的链表</span></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是Leetcode21 --&gt; 合并两个有序链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span>  <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2!= <span class="literal">null</span>)&#123; <span class="comment">// 退出循环的条件是走完了其中一个链表</span></span><br><span class="line">        <span class="comment">// 判断l1 和 l2大小</span></span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">            <span class="comment">// l1 小 ， curr指向l1</span></span><br><span class="line">            curr.next = l1;</span><br><span class="line">            l1 = l1.next;       <span class="comment">// l1 向后走一位</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// l2 小 ， curr指向l2</span></span><br><span class="line">            curr.next = l2;</span><br><span class="line">            l2 = l2.next;       <span class="comment">// l2向后走一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;       <span class="comment">// curr后移一位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出while循环之后,比较哪个链表剩下长度更长,直接拼接在排序链表末尾</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) curr.next = l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) curr.next = l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后返回合并后有序的链表</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>乘积最大子数组(152)：</p><p>方法一：暴力枚举</p><p>直接枚举每个位置开始的所有的乘积，注意只有一个数字的乘积也要参与比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//0 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; max) &#123;<span class="comment">//只有一个数也要与最大值比较一下</span></span><br><span class="line">            max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            temp = temp * nums[j];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>我们可以根据当前位置的正负性进行分类讨论。</p><p>如果当前位置是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。</p><p>如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。</p><p>于是这里我们可以再维护一个它表示以第 i 个元素结尾的最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：</p><p><code>max[i]=max(max[i-1] * nums[i],nums[i],min[i-1] * nums[i])</code><br><code>min[i]=min(min[i-1] * nums[i],nums[i],max[i-1] * nums[i])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//    2 -3   2   -3</span></span><br><span class="line">    <span class="comment">//max 2 -3   2   36</span></span><br><span class="line">    <span class="comment">//min 2 -6  -12  -6</span></span><br><span class="line">    <span class="comment">//max[i]=max(max[i-1]*nums[i],nums[i],min[i-1]*nums[i])</span></span><br><span class="line">    <span class="comment">//min[i]=min(min[i-1]*nums[i],nums[i],max[i-1]*nums[i])</span></span><br><span class="line">    <span class="comment">//max[i]表示以元素nums[i]结尾的序列的乘积的最大值</span></span><br><span class="line">    <span class="type">int</span>[] max = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        max[i] = Math.max(Math.max(max[i - <span class="number">1</span>] * nums[i], nums[i]), min[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">        min[i] = Math.min(Math.min(min[i - <span class="number">1</span>] * nums[i], nums[i]), max[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果需要遍历以数组中每一个元素作为结尾的所有情况找出最大的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> max[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max[i] &gt; res) &#123;</span><br><span class="line">            res = max[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最小栈（155）：</p><p>用<strong>辅助栈</strong>来实现（第一次做这题真没想到这种做法）</p><p>要做出这道题目，首先要理解栈结构<strong>后进先出</strong>的性质。</p><p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素（从栈顶到栈底）一定是 a, b, c, d。</p><p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p><p>我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p></li><li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p></li><li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);<span class="comment">//先放入最大值做为标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> min=minStack.peek();</span><br><span class="line">        minStack.push(Math.min(val, min));<span class="comment">//minStack中放入当前元素与栈顶元素较小的那个</span></span><br><span class="line">        stack.push(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();<span class="comment">//同时弹出</span></span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相交链表（160）：</p><p>方法一：HashSet</p><p>判断两个链表是否相交，可以使用哈希集合存储某一条链表的所有节点。</p><p>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p><p>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。</p><p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">null</span>) &#123;</span><br><span class="line">        hashSet.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashSet.contains(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：双指针</p><p>根据题目意思，如果两个链表相交，那么相交点之后的长度是相同的。</p><p>我们需要做的事情是，让<strong>两个链表从同距离末尾同等距离的位置开始遍历</strong>。为此，我们必须<strong>消除两个链表的长度差</strong>。有一个重要的前提是，如果让指针a遍历完A链表后再遍历B链表，让指针b遍历完B链表后再遍历A链表，这样两个指针最后一定会走过相同的距离，如果两个链表相交两个指针就一定会落在同一个结点。</p><p>下面是算法的具体步骤：</p><ul><li>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB</li><li>每步操作需要同时更新指针 pA 和 pB。</li><li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</li><li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li><li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</li></ul><p>下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。</p><p>情况一：两个链表相交</p><p>链表headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c&#x3D;m，b+c&#x3D;n。</p><p>如果 a&#x3D;b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；</p><p>如果 a !&#x3D; b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521220004531.png" alt="image-20220521220004531"></p><p>情况二：两个链表不相交</p><p>链表 headA 和 headB 的长度分别是 m 和 n。考虑当 m&#x3D;n 和 m!&#x3D;n  时，两个指针分别会如何移动：</p><p>如果 m&#x3D;n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值null，此时返回 null；</p><p>如果 m !&#x3D; n ，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 \pB 移动了 n+m 次之后，两个指针会同时指向链表末尾变成空值 null，此时返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    ListNode pa=headA,pb=headB;</span><br><span class="line">    <span class="keyword">while</span> (pa!=pb)&#123;</span><br><span class="line">        pa=pa==<span class="literal">null</span>?headB:pa.next;</span><br><span class="line">        pb=pb==<span class="literal">null</span>?headA:pb.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多数元素（169）：</p><p>方法一：哈希表</p><p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p><p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，找到出现次数大于n&#x2F;2的键即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> hashMap.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">        hashMap.put(num, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry :</span><br><span class="line">         hashMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() &gt; nums.length / <span class="number">2</span>) &#123;</span><br><span class="line">            res = entry.getKey();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：排序</p><p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n&#x2F;2 的元素（下标从 0 开始）一定是众数。</p><p>算法</p><p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521223252489.png" alt="image-20220521223252489"></p><p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组上面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 n&#x2F;2 的地方有重叠。因此，无论众数是多少，返回 n&#x2F;2 下标对应的值都是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：<a href="https://leetcode.cn/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">Boyer-Moore 投票算法</a></p><p>注意看题解的评论，有指出官方题解错误的地方</p></li><li><p>打家劫舍（198）：</p><p>经典<strong>动态规划问题</strong>，可以好好领悟一下。</p><p>动态规划的的四个解题步骤是：</p><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li><li>空间优化（可选）</li></ul><p>步骤一：定义子问题<br>稍微接触过一点动态规划的朋友都知道动态规划有一个“子问题”的定义。什么是子问题？子问题是和原问题相似，但规模较小的问题。例如这道小偷问题，原问题是“从全部房子中能偷到的最大金额”，将问题的规模缩小，子问题就是“从 k 个房子中能偷到的最大金额”，用 f(k) 表示。</p><p>可以看到，子问题是参数化的，我们定义的子问题中有参数 k。假设一共有 n 个房子的话，就一共有 n 个子问题。动态规划实际上就是通过求这一堆子问题的解，来求出原问题的解。这要求子问题需要具备两个性质：</p><p>原问题要能由子问题表示。例如这道小偷问题中，k&#x3D;n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。<br>一个子问题的解要能通过其他子问题的解求出。例如这道小偷问题中，f(k) 可以由 f(k-1) 和 f(k-2) 求出，具体原理后面会解释。这个性质就是教科书中所说的“最优子结构”。如果定义不出这样的子问题，那么这道题实际上没法用动态规划解。<br>小偷问题由于比较简单，定义子问题实际上是很直观的。一些比较难的动态规划题目可能需要一些定义子问题的技巧。</p><p>步骤二：写出子问题的递推关系</p><p>这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步。在做题的时候，最好把这一步的思路用注释的形式写下来。做动态规划题目不要求快，而要确保无误。否则，写代码五分钟，找 bug 半小时，岂不美哉？</p><p>我们来分析一下这道小偷问题的递推关系：</p><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第k (k&gt;2) 间房屋，有两个选项：</p><ul><li><p>偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p></li><li><p>不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。</p></li></ul><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p><p>这时我们就可以写出状态转移方程了：<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code>，注意边界条件只有一间房屋和两间房屋的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">1</span>)&#123;<span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>岛屿数量(200)：</p><p>方法一：广度优先搜索</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，<strong>每个搜索到的 1 都会被重新标记为 0</strong>，这样就相当于把岛屿所联通的区域清除，表示已经搜索过了（标记为2是更好的做法，更能区分出这是已经遍历过的位置），不会干扰后面接着扫描二维网络。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//t=x*column+y,注意一下这里的写法，将二维的信息保存在一维中，</span></span><br><span class="line">    <span class="comment">//因为后面的y一定小于column，所以t%column可以正确求出y,t/column求出x</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                ArrayList&lt;Integer&gt; island = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                island.add(i * n + j);</span><br><span class="line">                <span class="keyword">while</span> (island.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> island.remove(<span class="number">0</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur / n, y = cur % n;</span><br><span class="line">                    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x + <span class="number">1</span> &lt; m &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x + <span class="number">1</span>][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add((x + <span class="number">1</span>) * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x - <span class="number">1</span>][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add((x - <span class="number">1</span>) * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (y + <span class="number">1</span> &lt; n &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x][y + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add(x * n + y + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x][y - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add(x * n + y - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：深度优先搜索</p><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0，表示已经搜索过了。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= grid.length || x &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || y &lt; <span class="number">0</span> || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(x + <span class="number">1</span>, y, grid);</span><br><span class="line">    dfs(x - <span class="number">1</span>, y, grid);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, grid);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>, grid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>翻转链表(206)：</p><p>简单题，可以复习一下链表，做链表题目的时候先画图，重点就是把图画出来按着图去做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    head=head.next;</span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode temp=head.next;</span><br><span class="line">        head.next=cur;</span><br><span class="line">        cur=head;</span><br><span class="line">        head=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>课程表(207)：</p><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><p>如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。</p><p>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</p><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><p>我们将每一门课看成一个节点；</p><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。</p><p>求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序</p><p>方法一：深度优先搜索</p><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与<strong>拓扑排序</strong>(离散学过)的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><p>「未搜索」：我们还没有搜索到这个节点；</p><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，也就是递归搜索的时候遇到了之前搜索过的点，所以存在环，因此是不存在拓扑排序的；</p><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)之前的拓扑关系，以及不用进行任何操作。</p><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储有向图，存的是每一个顶点可以到的所有其他顶点，这样来表示边</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line"><span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line"><span class="type">int</span>[] visited;</span><br><span class="line"><span class="comment">// 判断有向图中是否有环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prereq :</span><br><span class="line">         prerequisites) &#123;</span><br><span class="line">        <span class="comment">//要学0 先学1，所以存在从1到0的边，get(1).add(0)</span></span><br><span class="line">        edges.get(prereq[<span class="number">1</span>]).add(prereq[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="comment">//先将u标记为搜索中</span></span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v :</span><br><span class="line">         edges.get(u)) &#123;</span><br><span class="line">        <span class="comment">// 如果「未搜索」那么搜索相邻节点v</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v]==<span class="number">0</span>) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="comment">//剪枝，搜v结点已经有环了，就不用在搜索和u相邻的其他顶点了</span></span><br><span class="line">            <span class="keyword">if</span> (!valid)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (visited[v]==<span class="number">1</span>)&#123;</span><br><span class="line">            valid=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//u的所有相邻顶点搜索完后，再将u标记为已完成</span></span><br><span class="line">    visited[u]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，<strong>该节点一定不会有任何入边，也就是它没有任何的先修课程要求</strong>。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着<strong>它的相邻节点少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，他们没有先修课程的要求，可以直接学，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] info :</span><br><span class="line">         prerequisites) &#123;</span><br><span class="line">        <span class="comment">//从1出发指向0的边</span></span><br><span class="line">        edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中，意味着队列中的课可以先学不需要先修课程</span></span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v :</span><br><span class="line">             edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">//将u的相邻结点的入度减少一</span></span><br><span class="line">            indeg[v]--;</span><br><span class="line">            <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">            <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：深度优先搜索的时候做标记一定要先看到底有几种标记，想好每一种标记在什么时候打上，这和实际问题有关，但模板都差不多，这个题对图的这种存储方式很值得学习，用<code>List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();</code>存储边，edges.get(0)意味着拿到从顶点0出发可以到达的所有点的一个List</p></li><li><p>数组中的第k个最大元素(215)：</p><p>我直接排序后（升序）从后往前找出第k个就好了，想了解快速选择算法去看看<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">官方题解</a>，这题也可以用堆排序来做，建立大顶堆，做 k - 1 次删除堆顶的操作后堆顶元素就是我们要找的答案</p></li><li><p>会议室2：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220620111447008.png" alt="image-20220620111447008"></p><p><strong>思路</strong>：</p><p>先对所有的会议安排按照开始时间升序排列。</p><p>安排第一个会议，此时一个会议室都没有，直接开放一间会议室使用；</p><p>安排第 i 个会议，查看当前有没有会议室是已开放且空闲的，没有则接着开放新的会议室；</p><p>查看是否有会议室已开放且空闲，是看当前正在使用会议室的会议中，<strong>最早结束的那场会议的结束时间</strong>，如果现在还没结束，说明其他会议更不可能结束，直接开放新的会议室。</p><p>若在已开放的会议室中，最早结束的那场会议已经结束，说明现在存在空闲会议室，直接加入即可。</p><p><strong>算法</strong></p><p>1、将最先开始的会议的结束时间加入小顶堆，最先开始的会议肯定要先进行</p><p>2、接着对 [1, size-1] 个会议依次进行操作：对比当前会议的开始时间和小顶堆的堆顶元素值，若小于，说明当前所有会议室正在进行的会议中，最早结束的都还没结束，只能新建会议室了，也就是将其加入小顶堆；</p><p>3、若当前会议的开始时间大于等于小顶堆的堆顶元素值，说明会议室正在进行的会议中，最早结束的会议已经结束，可以把它从小顶堆删除，自己进入小顶堆（重复利用会议室）。</p><p>4、等最后一个会议时间进入小顶堆，此时的小顶堆元素个数即至少需要的会议室数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1 - o2);<span class="comment">//小顶堆</span></span><br><span class="line">    Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);<span class="comment">//按照会议开始时间升序排列</span></span><br><span class="line">    <span class="comment">//将最早开始的会议的结束时间加入小顶堆，最早开始的会议肯定要先安排会议室</span></span><br><span class="line">    heap.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 小顶堆中堆顶始终是最早结束的会议的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前会议的开始时间大于等于前面已经开始的会议中最早结束的时间</span></span><br><span class="line">        <span class="comment">// 说明有会议室空闲出来了，可以直接重复利用</span></span><br><span class="line">        <span class="comment">// 把堆顶会议删除，当前的会议结束时间加入堆，意味着当前会议在进行</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= heap.peek()) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当前会议的结束时间加入小顶堆</span></span><br><span class="line">        heap.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当所有会议遍历完毕，还在最小堆里面的，说明会议还没结束，此时的数量就是会议室的最少数量</span></span><br><span class="line">    <span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大正方形：</p><p>方法一：暴力模拟</p><p>遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；</p><p>确定正方形的左上角后，根据<strong>左上角所在的行和列计算可能的最大正方形的边长</strong>（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；</p><p>每次在<strong>下方新增一行</strong>以及在<strong>右方新增一列</strong>，判断新增的行和列是否满足所有元素都是 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>, m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                maxSide = Math.max(maxSide, <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> Math.min(m - i, n - j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; curMax; k++) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//新增的一行一列的右下角那个特判</span></span><br><span class="line">                    <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; k; l++) &#123;</span><br><span class="line">                        <span class="comment">//判断新增的一行一列是不是都是1</span></span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + l] == <span class="string">&#x27;0&#x27;</span> </span><br><span class="line">                            || matrix[i + l][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        maxSide = Math.max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>可以使用动态规划降低时间复杂度。我们用 dp(i,j) 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 dp(i,j)&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p><code>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</code></p><p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i,j) 为右下角的最大正方形的边长只能是 1，因此 dp(i,j)&#x3D;1。</p><p>该状态转移方程的推导可以看看<a href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/">官方题解</a>，看懂后该类正方形的问题应该都能明白</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, column = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][column];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除自身以外数组的乘积</p><p>方法一：左右乘积列表</p><p>思路</p><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p>对于给定索引 i，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。</p><p><code>left[i]=left[i-1]*nums[i-1]</code>, <code>right[i]=right[i+1]*nums[i+1]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//left[i]=left[i-1]*nums[i-1]</span></span><br><span class="line">    left[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        left[i]=left[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    right[nums.length-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length-<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        right[i]=right[i+<span class="number">1</span>]*nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i]=left[i]*right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法还可以优化空间，我们先把输出数组当作left数组，计算出left数组的值，然后<strong>从右向左遍历</strong>，动态的构造出right数组，只需要一个变量保存right当前的值就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans[i]=ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        ans[i]=ans[i]*right;</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        right=right*nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>搜索二维矩阵2(240)：</p><p>方法一：每行进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] row :</span><br><span class="line">         matrix) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> search(row, target);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：z字形查找</p><p>我们可以从矩阵 matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)，那么我们希望在以 matrix 的左下角为左下角、以 (x,y) 为右上角的矩阵中进行搜索，即行的范围为 [x,m−1]，列的范围为 [0,y]：</p><p>小tips：matrix[x,y]始终保持在上述的搜索区域是一行最大，一列最小的元素</p><p>如果 matrix[x,y]&#x3D;target，说明搜索完成；</p><p>如果 matrix[x,y]&gt;target，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于<strong>第 y 列</strong>的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；</p><p>如果 matrix[x,y]&lt;target，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于<strong>第 x 行</strong>的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。</p><p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m=matrix.length,n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=n-<span class="number">1</span>;<span class="comment">//矩阵的右上角，行最大的元素，列最小的元素</span></span><br><span class="line">    <span class="keyword">while</span> (x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&gt;matrix[x][y])&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&lt;matrix[x][y])&#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全平方数(279)：</p><p>方法一：动态规划</p><p>我们可以依据题目的要求写出状态表达式：f[i]表示最少需要多少个数的平方来表示整数 i。这些数必然落在区间 [1,sqrt(n)]。我们可以枚举这些数，假设当前枚举到 j，那么我们还需要取若干数的平方，构成 i-j^2 此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程 <code>dp[i]=min(dp[i],dp[i-j*j]+1),j从1枚举到sqrt(n)</code></p><p>边界条件，将dp[0]初始化为0，为了满足j*j恰好为n的情况</p><p>题目有个坑，不一定每次都取最大的平方数，结果就是用了最少的数字，比如41，如果取36，那么还需要5&#x3D;4+1，总共3个数字，但可以直接取41&#x3D;25+16总共2个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 1 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//将当前数字先更新为最大的结果，</span></span><br><span class="line">        <span class="comment">//即 dp[i]=i，比如 i=4，最坏结果为 4=1+1+1+1 即为 4 个数字</span></span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Trie（前缀树）：208题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，</span></span><br><span class="line"><span class="comment"> * 一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，</span></span><br><span class="line"><span class="comment"> * 同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。</span></span><br><span class="line"><span class="comment"> * @param word </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false，</span></span><br><span class="line"><span class="comment"> * 如果匹配到了最后一个字符，那我们只需判断 node-&gt;isEnd即可。</span></span><br><span class="line"><span class="comment"> * @param word</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和 search 操作类似，只是不需要判断最后一个字符结点的isEnd，</span></span><br><span class="line"><span class="comment"> * 因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。</span></span><br><span class="line"><span class="comment"> * @param prefix</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>通过以上介绍和代码实现我们可以总结出 Trie 的几点性质：</p><ul><li><p>Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。</p></li><li><p>查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L，和 Trie 中包含多少个单词无关。</p></li><li><p>Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)</p></li></ul><p>最后，关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。(慢慢领悟叭~~)</p><p>注意：一道题目<strong>先思考20-30分钟</strong>如果实在做不出来再看看题解和思路，然后自己试试能不能自己写出代码，题目后面是在LeetCode网站上的题号，前面那个是自动生成的有序列表。</p><ul><li>2022&#x2F;4&#x2F;24 基本上一天四道题</li></ul><ol><li><p>两数之和(1)：太简单没什么说的。</p></li><li><p>两数相加(2)：应该根据题目现有的条件来做，从题目本身出发，不要一开始就考虑转换为常用的按顺序的十进制加法，<strong>类比二进制加法计算（二进制全加法器）</strong>，直接用两个链表的结点从前往后相加即可。</p></li><li><p>无重复字符的最长子串(3)：</p><p>用<strong>滑动窗口</strong>思想，两个指针left和right，如果left和right之间没有重复就让right++，因为之前left和right之间无重复，所有如果right++后出现重复一定是现在的right和之前的left到right之间有一个值重复了，以<code>string.charAt(right)</code>为标准从left开始遍历，分三种情况（前部、中部、后部）</p><p>（1）a b c a</p><p>（2）a b c b</p><p>（3）a b c c</p><p>从j&#x3D;left开始遍历（j++），如果遇到这两种重复的情况，让left&#x3D;j+1即左指针指向重复位置的下一个位置。</p></li><li><p>寻找两个正序数组的中位数(4)：</p><p>归并排序，将<strong>两个有序数组合并为一个</strong>，for循环遍历合并后的数组，然后分别设置两个指针指向需要排序的两个数组，取两个数组中小的数放入新数组，并且让该数组指针后移，<strong>边界情况</strong>若一个数组指针已经指向末尾，则另外判断次情况，将另一个数组的数全部放入即可。</p><p>算法时间复杂度为O（m+n），只用遍历一次新数组即可。</p><!--more--></li><li><p>最长回文子串(5)：</p><p>（1）扩展中心：回文子串分两种，奇数长度：abcba可以从中间的a开始向两边扩展，偶数长度：abcabbabb，从[1]和[2]中间开始向两边扩展，下面是扩展的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))&#123;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">return</span> end-start-<span class="number">1</span>;<span class="comment">//注意这里的减一，比如abcba，到两边a的时候还会start--和end++,所以要减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历字符串，从每个点开始扩展，有两种扩展方式，分别为<code>expand(s,i,i);//abcba</code>（从c开始扩展）和<code>len2=expand(s,i,i+1);//abba</code>（从[1]b和[2]b开始扩展），然后找出最长的那个扩展方式，<code>start=i-(len-1)/2;end=i+len/2;</code>,注意这里的start和end。</p><p>（2）动态规划：p（i，j）&#x3D;p(i+1,j-1)&amp;&amp;s[i]&#x3D;&#x3D;s[j]所以如果我们想知道 P（i , j）的情况，只需要知道 P（i + 1，j - 1）的情况就可以了，然后向两边扩展即可，这样时间复杂度就少了 O(n)。因此我们可以用动态规划的方法，空间换时间，把已经求出的 P（i，j）存储起来，求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，例如求p（1，2），带入会出现p（2，1），长度为1和2的回文串需要单独判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt;= length; len++) <span class="comment">//遍历所有的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; length; start++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= length) <span class="comment">//下标已经越界，结束本次循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            P[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || P[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end); <span class="comment">//长度为 1 和 2 的单独判断下</span></span><br><span class="line">            <span class="keyword">if</span> (P[start][end] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                maxLen=len;</span><br><span class="line">                maxPal = s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：两层循环 O(n²）</p><p>空间复杂度：用二维数组 P<em>P</em> 保存每个子串的情况 O(n²)</p></li><li><p>Z字形变换(6)：是一个找规律的题目，可以找出规律来用二维数组模拟</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220328225949259.png" alt="image-20220328225949259"></p></li><li><p>正则表达式匹配(10)：</p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>使用动态规划，对匹配的方案进行枚举。我们用 f [i] [j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配.</p><p>如果 p 的第 j 个字符是一个小写字母，那么我们必须在 s中匹配一个相同的小写字母，即</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/1-166246313752888.png" alt="image-20220407223143316"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/2-166246313752887.png" alt="image-20220407223216513"></p><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了 s 中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li><p>匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</p></li><li><p>不匹配字符，将该组合扔掉，不再进行匹配。</p></li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/3-166246313752889.png" alt="image-20220407223308404"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/4-166246313752890.png" alt="image-20220407223334274"></p><p>其中 matches(x,y) 判断两个字符是否匹配的辅助函数。只有当 y 是 . 或者 x 和 y 本身相同时，这两个字符才会匹配。</p><ol start="8"><li>盛最多水的容器(11)：</li></ol><p>  <strong>双指针</strong>解决，第一次做这题可能不会想到双指针。下面解释双指针算法的过程，并证明其正确性。给定一个数组height[1, 8, 6, 2, 5, 4, 8, 3, 7]，初始时分别有一左一右两个指针位于边界，容纳的水量&#x3D;两个指针指向的数字中较小值∗指针之间的距离，假设左指针为left右指针为right，不妨设此时height[left]&lt;height[right]，如果移动右指针，那么两个指针的距离一定变小，并且min{height[left],height[right’]}&lt;&#x3D;之前的高度，因为如果此时新的高度比原来的高度大，取height[left]和height[right]的最小值还是之前的height[left]，高度没变但距离变小，所以容器的容积变小，如果新的高度比原来的高度小，则导致高度变小且距离变小，容积也会变小，即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量，也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。综上，可以得出每次移动指针的时候移动高度较小的那个指针是正确答案，边界条件是left&lt;right。</p><ol start="9"><li><p>整数转罗马数字(12)：</p><p>按照题目所给规则可能出现的罗马数字如下</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220410224312579.png" alt="image-20220410224312579"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220410225427004.png" alt="image-20220410225427004"></p><p>根据上图求140的罗马数字，我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为C&#x3D;100。接下来，对于剩余的数字 40，最大可以选择的符号值为 XL&#x3D;40。因此，140 的对应的罗马数字为 C+XL&#x3D;CXL。</p><p>采取模拟的思路，根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。</p><p>编程时，可以建立一个数值-符号对的列表valueSymbols，按数值从大到小排列。遍历 valueSymbols 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。valueSymbols对应表和代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">roman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> values[i];</span><br><span class="line">        <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> symbols[i];</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= value) &#123;</span><br><span class="line">            num -= value;</span><br><span class="line">            roman.append(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roman.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三数之和(15)：</p></li></ol><p>   刚开始做这题直接三重循环遍历，会超出时间限制，需要改进算法，看来LeetCode上的题目有些<strong>不能直接模拟</strong>，要想想降低复杂度的做法。「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><p>   第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</p><p>   第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</p><p>   也就是说，我们枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有(a,b,c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>   同时，<strong>对于每一重循环而言，相邻两次枚举的元素不能相同</strong>，否则也会造成重复。举个例子，如果排完序的数组为</p><p>   [0, 1, 2, 2, 2, 3]<br>    ^  ^  ^<br>   我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。</p><p>   <img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220411225207697.png" alt="image-20220411225207697"></p><p>   这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2) 减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。</p><p>   双指针看似容易理解，但不同题目下的<strong>边界条件</strong>都不尽相同，边界条件应该是一个难点，需要仔细考虑。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;<span class="comment">//对于每一重循环相邻两个元素不能相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果指针重合，一种情况是上一次j&lt;k时（j和k相邻），nums[j] + nums[k] &gt; target</span></span><br><span class="line">                    <span class="comment">// 另一种情况时j不断增加但nums[j]+nums[k]&lt;target，随着 j 后续的增加</span></span><br><span class="line">                    <span class="comment">// 就不会有满足 nums[j] + nums[k] = target 并且 j&lt;k 的值了，可以退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] + nums[k] == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        integerList.add(nums[i]);</span><br><span class="line">                        integerList.add(nums[j]);</span><br><span class="line">                        integerList.add(nums[k]);</span><br><span class="line">                        list.add(integerList);</span><br><span class="line">                        <span class="comment">// 这里不要写k--，要让k--交由上面的while循环来判断执行</span></span><br><span class="line">                        <span class="comment">// 如果写了k--，在j和k相邻的情况下，下一次循环j会大于k（j比k大1），</span></span><br><span class="line">                        <span class="comment">// while循环和if失效，所以k--要交由while循环来执行</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br></pre></td></tr></table></figure><ol start="11"><li>电话号码的字母组合(17)：</li></ol><p>   这道题其实<del>直接模拟</del>也能做，因为最多只有四位电话号码，直接根据不同的位数电话号码采取一层for，二层for，三层for，四层for遍历也可AC。</p><p>   首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>   回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p><p>   回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。下面贴上带有回溯的递归函数的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个回溯的递归函数借鉴了赫夫曼编码的向左为0向右为1的那个递归函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(List&lt;String&gt; res, HashMap&lt;Character, String&gt; stringHashMap, String digits, StringBuilder stringBuilder, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//用index遍历电话号码，for循环遍历每一个电话号码对应的所有字符</span></span><br><span class="line">    <span class="comment">//  2   3</span></span><br><span class="line">    <span class="comment">// abc def</span></span><br><span class="line">    <span class="keyword">if</span> (digits.length() != index) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">digitString</span> <span class="operator">=</span> stringHashMap.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digitString.length(); i++) &#123;</span><br><span class="line">            stringBuilder.append(digitString.charAt(i));</span><br><span class="line">            f(res, stringHashMap, digits, stringBuilder, index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当该递归函数返回进入下一行时，说明已经遍历完电话号码的所有数字，</span></span><br><span class="line">            <span class="comment">// 下一步应该取最后一个电话号码的下一个字符（也就是i++），需要删掉stringBuilder2的末尾一位，</span></span><br><span class="line">            <span class="comment">// 让最后一个电话号码的下一个字符填入进来</span></span><br><span class="line">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.add(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li><p>删除链表的倒数第N个结点(19)：</p><p>我的想法是从头节点开始遍历，用于遍历的结点记为indexNode，如果indexNode向后遍历n次为null的话，证明此时indexNode结点即为要删除的结点，看下面这个图可以轻松证明</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220414201955313.png" alt="image-20220414201955313"></p><p>​还需要设置一个preNode作为indexNode的前一个结点，这样才能做到删除操作，除此以外需要注意一个特殊情况即删除的结点是头结点，直接返回head.next即可。</p><p>​一个小tips：处理链表是可以在头结点前面加上一个哑节点dummy，dummy不保存任何信息只是指向原链表的头结点，这样可以有效解决删除链表头相关的特殊情况，可以把有关链表头的特殊情况统一到普通情况的代码中。（不是下面贴的那段代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//该链表只有一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode indexNode=head;</span><br><span class="line">    ListNode preNode=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode temp=indexNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (preNode==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//删除的是头节点的情况</span></span><br><span class="line">                <span class="keyword">return</span> head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode.next=preNode.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里的保存preNode是一个保存链表前一个结点的经典操作</span></span><br><span class="line">        preNode=indexNode;</span><br><span class="line">        indexNode=indexNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li>有效的括号(20)：</li></ol><p>​典型的<strong>栈的应用</strong>，我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合（<strong>后进先出</strong>），因此我们可以将这个左括号放入栈顶。当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。<strong>如果不是相同的类型，或者栈中并没有左括号</strong>，那么字符串 s 无效，返回 False。在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>​注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><ol start="14"><li><p>合并k个升序列表(23):</p><p>前置知识：合并两个有序链表</p><ul><li>首先我们需要一个变量 head 来保存合并之后链表的头部，你可以把 head 设置为一个虚拟的头（也就是 head 的 val 属性不保存任何值），这是为了方便代码的书写，在整个链表合并完之后，返回它的下一位置即可。<strong>设置哑结点方便链表操作的代码书写</strong></li><li>我们需要一个指针 tail 来记录下一个插入位置的前一个位置，以及两个指针 aPtr 和 bPtr 来记录 a 和 b 未合并部分的第一位。注意这里的描述，tail 不是下一个插入的位置，aPtr 和 bPtr 所指向的元素处于「待合并」的状态，也就是说它们还没有合并入最终的链表。 当然你也可以给他们赋予其他的定义，但是定义不同实现就会不同。</li><li>当 aPtr 和 bPtr 都不为空的时候，取 val 熟悉较小的合并；如果 aPtr 为空，则把整个 bPtr 以及后面的元素全部合并；bPtr 为空时同理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="literal">null</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//这里的head就是哑结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head, aPtr = a, bPtr = b;</span><br><span class="line">    <span class="keyword">while</span> (aPtr != <span class="literal">null</span> &amp;&amp; bPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aPtr.val &lt; bPtr.val) &#123;</span><br><span class="line">            tail.next = aPtr;</span><br><span class="line">            aPtr = aPtr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = bPtr;</span><br><span class="line">            bPtr = bPtr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.next = (aPtr != <span class="literal">null</span> ? aPtr : bPtr);</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：顺序合并</p><p>我们可以想到一种最朴素的方法：用一个变量 ans 来维护以及合并的链表，第 i 次循环把第 i个链表和 ans 合并，答案保存到 ans 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">    ListNode ans=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        ans=mergeTwoLists(ans,lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：分治合并</p><p>考虑优化方法一，用分治的方法进行合并。</p></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220416111324477.png" alt="image-20220416111324477"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//本题中其实并不会出现l&gt;r</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="literal">null</span>||lists.length==<span class="number">0</span>)&#123;<span class="comment">//注意这两个特殊情况的判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>长度为0的数组 int[] arr &#x3D; new int[0]，也称为空数组，虽然arr长度为0，但是依然是一个<strong>对象</strong></p></li><li><p>null数组，int[] arr &#x3D; null；arr是一个数组类型的<strong>空引用</strong>。</p></li></ul><p>​方法三：使用优先队列合并</p><p>这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用<strong>优先队列</strong>来优化这个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Status&gt; &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Status</span><span class="params">(<span class="type">int</span> val, ListNode ptr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Status o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val - o.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Status&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode node :</span><br><span class="line">         lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(node.val, node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Status</span> <span class="variable">f</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        tail.next = f.ptr;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="keyword">if</span> (f.ptr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(f.ptr.next.val, f.ptr.next));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li><p>下一个排列(31)：</p><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个<strong>字典序更大的排列</strong>，注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p><p>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p><p>以排列 [4,5,2,6,3,1] 为例：</p><p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。</p><p>当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。</p><p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p><ul><li><p>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</p></li><li><p>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从后向前找到第一个不满足从后向前为升序的位置，该位置为index-1（如果index！=0）</span></span><br><span class="line">    <span class="comment">//从后向前为升序意味着该子序列是最大的序列，无法通过交换该子序列的内部获得下一个排列</span></span><br><span class="line">    <span class="comment">//所以需要一直找到一个不满足该条件的位置</span></span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span>&amp;&amp;nums[index]&lt;=nums[index-<span class="number">1</span>])&#123;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;<span class="comment">//如果index!=0意味着该数列不是递减数列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minTemp</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line">        index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</span></span><br><span class="line">        <span class="keyword">while</span> (nums[index] &lt;= nums[minTemp]) &#123;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序，交换后该序列一定比原序列大，但要保证**变大的幅度尽可能小**，所以需要把后面的子序列从小到大排列，这样就是下一个排列</span></span><br><span class="line">        swap(nums, minTemp, index);</span><br><span class="line">        left = minTemp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=nums[a];</span><br><span class="line">    nums[a]=nums[b];</span><br><span class="line">    nums[b]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="16"><li><p>最长有效括号(32)：</p><ul><li><p>方法一：动态规划</p><p>首先要找到转移方程，怎么想转移方程？首先想的时候从已经求出了 <code>dp[i-1][j-1]</code> 入手，再加上已知 <code>s[i]</code>、<code>p[j]</code>，要想的问题就是怎么去求 <code>dp[i][j]</code>。</p><p>结合题目，有最长这个字眼，可以考虑尝试使用 动态规划 进行分析。这是一个 最值型 动态规划的题目。</p><p>动态规划题目分析的 4 个步骤：</p><ul><li><p>确定状态</p><p>​研究<strong>最优策略的最后一步</strong></p><p>​化为子问题</p></li><li><p>转移方程</p><p>​根据子问题定义得到</p></li><li><p>初始条件和边界情况</p></li><li><p>计算顺序</p></li></ul><p>首先，我们定义一个 int[] dp 数组，其中第 i 个元素表示<strong>以下标为 i 的字符结尾</strong>的最长有效子字符串的长度。注意：如果第i个元素为 <code>(</code> 那么s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] &#x3D; 0，以 <code>(</code> 结尾的子串对应的dp值都为零。下面来推导状态转移方程</p><p>s[i]&#x3D;&#x3D; ‘(‘</p><p>这时，s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] &#x3D; 0</p><p>s[i] &#x3D;&#x3D; ‘)’</p><p>这时，需要看其前面对元素来判断是否有有效括号对。</p><p><strong>情况1:</strong></p><p>s[i - 1] &#x3D;&#x3D; ‘(‘</p><p>即 s[i] 和 s[i - 1] 组成一对有效括号，有效括号长度新增长度2，i位置对最长有效括号长度为 其之前2个位置的最长括号长度加上当前位置新增的2，我们无需知道i-2位置对字符是否可以组成有效括号对。</p><p>那么有：<code>dp[i] = dp[i - 2] + 2</code></p><p><strong>情况2:</strong></p><p>s[i - 1] &#x3D;&#x3D; ‘)’</p><p>这种情况下，如果前面有和s[i]组成有效括号对的字符，即形如( (….) )，这样的话，就要求s[i - 1]位置必然是有效的括号对，否则s[i]无法和前面对字符组成有效括号对。这时，我们只需要找到和s[i]配对对位置，并判断其是否是 <code>(</code> 即可。</p><p>和其配对对位置为：<code>i - dp[i - 1] - 1</code></p><p>如果：<code>s[i - dp[i - 1] - 1] == &#39;(&#39;</code>,有效括号长度新增长度2，i位置对最长有效括号长度为 i-1位置的最长括号长度加上当前位置新增的2，那么有：</p><p><code>dp[i] = dp[i - 1] + 2</code></p><p>值得注意的是，<code>i - dp[i - 1] - 1</code>和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (…)这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：<code>dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2</code></p></li></ul></li></ol><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220416165854222-166246313752896.png" alt="image-20220416165854222"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">    dp[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        dp[i] = dp[i - <span class="number">2</span>] + <span class="number">2</span> <span class="comment">#要保证i - 2 &gt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] + <span class="number">2</span> </span><br><span class="line">        <span class="comment">#要保证i - dp[i - 1] - 2 &gt;= 0</span></span><br></pre></td></tr></table></figure><p>​下面贴上Java的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i]=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]=dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//s[i-1]=&#x27;)&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i]&gt;maxLen)&#123;</span><br><span class="line">            maxLen=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法二：使用<strong>栈</strong></p><p>​栈里存的是括号对应的<strong>下标</strong>，具体做法是我们始终保持<strong>栈底元素</strong>为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p><p>​对于遇到的每个 ‘(’ ，我们将它的下标放入栈中<br>​对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：</p><p>​如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」<br>​如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」<br>​我们从前往后遍历字符串并更新答案即可。需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为-1 的元素。</p><p>​总结：两种索引会入栈</p><ol><li>等待被匹配的左括号索引。</li><li>充当「参照物」的右括号索引。因为：当左括号匹配光时，栈需要留一个垫底的参照物，用于计算一段连续的有效长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//s[i]==&#x27;)&#x27;</span></span><br><span class="line">            stack.pop();<span class="comment">//先出栈，再相减计算有多少个匹配的括号</span></span><br><span class="line">            <span class="comment">//举个例子 ()(()))</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> curLen=i-stack.peek();</span><br><span class="line">                maxLen=Math.max(maxLen,curLen);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法三：</p><p>​在此方法中，我们利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加 left 计数器，对于遇到的每个 ‘)’ ，我们增加 right 计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。当 right 计数器比left 计数器大时，我们将left 和 right 计数器同时变回 0。</p><p>​这样的做法<strong>贪心</strong>地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p><p>​解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：</p><ul><li>当 left 计数器比right 计数器大时，我们将 left 和right 计数器同时变回 0。</li><li>当 left 计数器与right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。</li></ul><p>​这样我们就能涵盖所有情况从而求解出答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;<span class="comment">//从左向右遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxLen = Math.max(left + right, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            left = <span class="number">0</span>;</span><br><span class="line">            right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left=<span class="number">0</span>;</span><br><span class="line">    right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从右向左遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxLen = Math.max(left + right, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="17"><li><p>搜索旋转排序数组(33)：</p><ul><li><p>方法一：</p><p>比如<code>nums = [4,5,6,7,0,1,2], target = 0</code>，可以将该数组分为两部分看待，从4到7，从0到2，首先比较target与nums[0]的大小，如果target&lt;nums[0]，则在后半部分从后往前搜索，如果target&gt;nums[0]，则在前半部分从前往后搜索</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//[4,5,6,7,0,1,2], target = 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isInFront</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">        index = nums.length - <span class="number">1</span>;</span><br><span class="line">        isInFront = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInFront) &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[index] &lt; nums[index + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; nums[index] &gt; nums[index - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[index] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法二：</p><p>对于旋转数组 nums &#x3D; [4,5,6,7,0,1,2]，首先根据 nums[0] 与 target 的关系判断 target 是在左段还是右段。</p><p>例如 target &#x3D; 5, 目标值在左半段，因此在 [4, 5, 6, 7, inf, inf, inf] 这个有序数组里找就行了；<br>例如 target &#x3D; 1, 目标值在右半段，因此在 [-inf, -inf, -inf, -inf, 0, 1, 2] 这个有序数组里找就行了。<br>如此，我们又将「旋转数组中找目标值」 转化成了 「有序数组中找目标值」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先根据 nums[0] 与 target 的关系判断目标值是在左半段还是右半段</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// 目标值在左半段时，若 mid 在右半段，则将 mid 索引的值改成 inf</span></span><br><span class="line">            <span class="comment">// 注意这里的&gt;=，如果target在最左端，就需要&gt;=，比如</span></span><br><span class="line">            <span class="comment">// nums=[5,1,2,3] target=5</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[mid] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 目标值在右半段时，若 mid 在左半段，则将 mid 索引的值改成 -inf</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[mid] = Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在排序数组中查找元素的第一个和最后一个位置(34)：</p><ul><li><p>方法一：</p><p>先用二分查找找到该元素的位置，然后从该位置不断向前遍历和向后遍历，以此来找到第一个和最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexA</span> <span class="operator">=</span> index, indexB = index;</span><br><span class="line">    <span class="keyword">while</span> (indexA &gt; <span class="number">0</span> &amp;&amp; nums[indexA] == nums[indexA - <span class="number">1</span>]) &#123;</span><br><span class="line">        indexA--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (indexB &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[indexB] == nums[indexB + <span class="number">1</span>]) &#123;</span><br><span class="line">        indexB++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;indexA, indexB&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找主要用于在有序的列表中查找目标值，注意二分查找的前提条件必须是有序或者部分有序的列表，当列表中目标值存在多个时，我们可以利用二分查找目标值的左边界和右边界，即<strong>左值二分查找</strong>和<strong>右值二分查找</strong>。需要特别注意目标值在列表中找不到的几种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 左值二分模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出，如果left和right都很大直接相加会溢出，</span></span><br><span class="line">        <span class="comment">// 最好不要直接相加除以二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// 继续往左边找</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续往右边找</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑目标值不在数组中的两种情况,目标值小于最小值left等于0，</span></span><br><span class="line">    <span class="comment">// 目标值大于最大值left等于num.length</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length || nums[left] != target) left = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 右值二分模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &lt;= target) &#123;</span><br><span class="line">            <span class="comment">// 继续往右边找</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续往左边找</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑目标值不在数组中的两种情况，目标值小于最小值right会等于-1，</span></span><br><span class="line">    <span class="comment">// 目标值大于最大值right会等于nums.length-1</span></span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span> || nums[right] != target) right = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组数总和(39)：</p></li></ol><p>  思路分析：根据示例 1：输入: candidates &#x3D; [2, 3, 6, 7]，target &#x3D; 7。</p><p>  候选数组里有 2，如果找到了组合总和为 7 - 2 &#x3D; 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；<br>  同理考虑 3，如果找到了组合总和为 7 - 3 &#x3D; 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。<br>  基于以上的想法，可以画出如下的树形图。建议大家自己在纸上画出这棵树，这一类问题都需要先画出树形图，然后编码实现。</p><p>  <img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220418221514841.png" alt="image-20220418221514841"></p><p>  编码通过 <strong>深度优先遍历</strong> 实现，使用一个列表，在 深度优先遍历 变化的过程中，遍历所有可能的列表并判断当前列表是否符合题目的要求，成为「回溯算法」。</p><p>  说明上图：</p><p>  以 target &#x3D; 7 为 根结点 ，创建一个分支的时 做减法 ；<br>  每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 candidate 数组的每个元素的值；<br>  减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；<br>  所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。<br>  这棵树有 4 个叶子结点的值 0，对应的路径列表是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中给出的输出只有 [[7], [2, 2, 3]]。即：题目中要求每一个符合要求的解是 不计算顺序 的。下面我们分析为什么会产生重复。</p><p>  产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说 <strong>每一个元素可以重复使用</strong>，我们考虑了 <strong>所有的</strong> 候选数，因此出现了重复的列表。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起点</strong> <code>index</code>，请看下图。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220418221816511.png" alt="image-20220418221816511"></p><p>​即：从每一层的第 2 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。</p><p>​<strong>剪枝提速</strong></p><p>​根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的数依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序（从小到大），添加相关逻辑达到进一步剪枝的目的，下面贴上剪枝提速后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; integerList, <span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//[2, 3, 6, 7]  4</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//添加的时候拷贝比每次传进来就拷贝效率高</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(integerList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//在这里剪枝效率很高</span></span><br><span class="line">        &#125;</span><br><span class="line">        integerList.add(candidates[i]);</span><br><span class="line">        f(res,integerList,candidates,target-candidates[i],i);</span><br><span class="line">        integerList.remove(integerList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；</p></li><li><p>组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量（就是上面用的index）。</p></li></ul><p>下面详细介绍一下<strong>回溯算法与深度优先遍历</strong></p><ul><li>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将<strong>取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</li></ul><p>​找到一个可能存在的正确的答案；<br>​在尝试了所有可能的分步方法后宣告该问题没有答案。</p><ul><li>深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 <strong>尽可能深</strong> 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将<strong>回溯到发现结点 v 的那条边的起始结点</strong>。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</li></ul><ol start="20"><li><p>全排列（46）：</p><p>用这道题来与上面那道组数总和的回溯算法进行对比，再次深刻理解一下回溯算法和深度优先遍历（DFS）</p><p>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p><p>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422115357752.png" alt="image-20220422115357752"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; integerList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] isUsed, <span class="type">int</span> countNum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (countNum == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(integerList));<span class="comment">//每次添加到结果列表中进行拷贝会节省时间</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsed[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        integerList.add(nums[i]);</span><br><span class="line">        isUsed[i]=<span class="literal">true</span>;</span><br><span class="line">        dfs(res, integerList, nums, isUsed, countNum + <span class="number">1</span>);</span><br><span class="line">        isUsed[i] = <span class="literal">false</span>;<span class="comment">//回溯之前清除这一次操作的影响</span></span><br><span class="line">        integerList.remove(integerList.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>说明</strong>：</p><p>​每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>​使用深度优先遍历有「回头」的过程，<strong>在「回头」以后， 状态变量需要设置成为和先前一样</strong> ，因此在回到上一层结点的过程中，需要<strong>撤销上一次的选择</strong>，这个操作称之为「状态重置」；<br>​深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：<strong>往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；</strong><br>​深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>​使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><p>​<strong>设计状态变量</strong></p><p>​首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；<br>​递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们<strong>需要一个变量来表示当前程序递归到第几层</strong>，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；<br>​布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。<br>​这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><p>​<strong>每一次尝试都「复制」，则不需要回溯</strong></p><p>​如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么在回到上一层结点的时候不需要「回溯」；在递归终止的时候也不需要做拷贝。<br>​这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p><p>​<strong>剪枝</strong></p><p>​回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>​提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。</p><p>​<strong>总结</strong></p><p>​做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>​在画图的过程中思考清楚：</p><p>​分支如何产生；题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p><ol start="21"><li><p>接雨水(42):</p><p>方法一：</p><p>按行求，先求出数组的最大的高度，然后遍历数组，从最高的一层开始，计算每一层的积水量，思路比较简单，下面贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="comment">//一层一层的计算，这样直接模拟会超时，这是按行求的做法</span></span><br><span class="line">    <span class="type">int</span> maxHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i]&gt;maxHeight)&#123;</span><br><span class="line">            maxHeight=height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tempMax=maxHeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxHeight; i++) &#123;</span><br><span class="line">        <span class="type">int</span> leftIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[j]==tempMax)&#123;</span><br><span class="line">                leftIndex=j;</span><br><span class="line">                height[j]--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> leftIndex+<span class="number">1</span>; k &lt; height.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (height[k]==tempMax)&#123;</span><br><span class="line">                        res+=k-leftIndex-<span class="number">1</span>;</span><br><span class="line">                        leftIndex=k;</span><br><span class="line">                        height[k]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tempMax--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>按列求，求每一列的水，我们只需要关注当前列，以及左边最高的墙，右边最高的墙就够了。装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。所以，根据较矮的那个墙和当前列的墙的高度可以分为两种情况。</p><ul><li>较矮的墙的高度大于当前列的墙的高度，此时积水量就是较矮的墙的高度减去当前列的墙的高度</li><li>较矮的墙的高度小于或等于当前列的墙的高度，此时无法积水</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> indexHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//直接按列计算也会超时，但可以用动态规划进行优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexHeight=height[i];</span><br><span class="line">        <span class="type">int</span> leftHeightMax=<span class="number">0</span>,rightHeightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;leftHeightMax)&#123;</span><br><span class="line">                    leftHeightMax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j]&gt;rightHeightMax)&#123;</span><br><span class="line">                    rightHeightMax=height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> minHeight=Math.min(leftHeightMax,rightHeightMax);</span><br><span class="line">        <span class="keyword">if</span> (minHeight&gt;indexHeight)&#123;</span><br><span class="line">            res+=minHeight-indexHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><p>使用动态规划对方法二按列求的方法进行优化</p><p>我们注意到，解法二中。对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，max_left [i] 代表第 i 列左边最高的墙的高度，max_right[i] 代表第 i 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p><p>对于 max_left我们其实可以这样求。</p><p>max_left [i] &#x3D; Max(max_left [i-1],height[i-1])。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p><p>对于 max_right我们可以这样求。</p><p>max_right[i] &#x3D; Max(max_right[i+1],height[i+1]) 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><p>这样，我们再利用解法二的算法，就不用在 for 循环里每次重新遍历一次求 max_left 和 max_right 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="comment">//dp做法</span></span><br><span class="line">    <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];<span class="comment">//初始化都是0</span></span><br><span class="line">    <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">    <span class="type">int</span> indexHeight=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; maxLeft.length; i++) &#123;<span class="comment">//从左往右求</span></span><br><span class="line">        maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> maxLeft.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从右往左求</span></span><br><span class="line">        maxRight[i]=Math.max(maxRight[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexHeight=height[i];</span><br><span class="line">        <span class="type">int</span> minHeight=Math.min(maxLeft[i],maxRight[i]);<span class="comment">//直接查表得出两边较矮的高度</span></span><br><span class="line">        <span class="keyword">if</span> (minHeight&gt;indexHeight)&#123;</span><br><span class="line">            res+=minHeight-indexHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：</p><p><strong>双指针优化动态规划</strong></p><p>我们先明确几个变量的意思：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left_max：左边的最大值，它是从左往右遍历找到的</span><br><span class="line">right_max：右边的最大值，它是从右往左遍历找到的</span><br><span class="line"><span class="attribute">left</span>：从左往右处理的当前下标</span><br><span class="line"><span class="attribute">right</span>：从右往左处理的当前下标</span><br></pre></td></tr></table></figure><p>定理一：在某个位置<code>i</code>处，它能存的水，取决于它左右两边的最大值中较小的一个。</p><p>定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）</p><p>定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                                   right_max</span><br><span class="line"> left_max                             __</span><br><span class="line">   __                                |  |</span><br><span class="line">  |  |__   __??????????????????????  |  |</span><br><span class="line">__|     |__|                       __|  |__</span><br><span class="line">        left                      right</span><br></pre></td></tr></table></figure><p>对于位置<code>left</code>而言，它左边最大值一定是left_max，右边最大值<strong>大于等于</strong>right_max，这时候，如果<code>left_max&lt;right_max</code>成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当<code>left_max&lt;right_max</code>时，我们就希望去处理left下标，反之，我们希望去处理right下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">1</span>, right = height.length - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> height[<span class="number">0</span>], rightMax = height[height.length - <span class="number">1</span>];<span class="comment">//初始化左边最大高度和右边最大高度</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//等于是保证最后一列也会被处理</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &gt; height[left]) &#123;<span class="comment">//先判断能不能积水再对左边最大高度进行更新</span></span><br><span class="line">                res += leftMax - height[left];</span><br><span class="line">            &#125;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//leftMax&gt;=rightMax</span></span><br><span class="line">            <span class="keyword">if</span> (rightMax&gt;height[right])&#123;</span><br><span class="line">                res+=rightMax-height[right];</span><br><span class="line">            &#125;</span><br><span class="line">            rightMax = Math.max(rightMax,height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：</p><p>使用<strong>栈</strong>，说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。我们用栈保存每堵墙。</p></li></ol><p>​当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>​如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>​总体的原则就是，当前高度小于等于栈顶高度，入栈，指针后移。当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p><p>​而对于计算 current 指向墙和新的栈顶之间的水，根据图的关系，我们可以直接把这两个墙当做之前解法三的 max_left 和 max_right，然后之前弹出的栈顶当做每次遍历的 height [ i ]。水量就是 Min ( max _ left ，max _ right ) - height [ i ]，只不过这里需要乘上两个墙之间的距离。可以根据下面这个图自己推导（验证）一下计算方法即可</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422162412824-1662463137547102.png" alt="image-20220422162412824"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> current=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current&lt;height.length)&#123;</span><br><span class="line">        <span class="comment">//当前高度大于栈顶的高度</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;height[current]&gt;height[stack.peek()])&#123;</span><br><span class="line">            <span class="type">int</span> h=height[stack.pop()];<span class="comment">//每次遍历的 height[i]</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果栈为空直接将此时的current入栈即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> distance=current-stack.peek()-<span class="number">1</span>;<span class="comment">//计算两堵墙之间的距离</span></span><br><span class="line">            <span class="type">int</span> min=Math.min(height[current],height[stack.peek()]);<span class="comment">//取两堵墙的较矮的一堵墙的高度</span></span><br><span class="line">            res+=distance*(min-h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current);</span><br><span class="line">        current++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="22"><li><p>旋转图像(48):</p><p>方法一：使用辅助数组</p><p>对于矩阵中第 i 行的第 j个元素，在旋转后，它出现在倒数第 i 列的第 j个位置，即第j行第n-i-1列。这样以来，我们使用一个与 matrix 大小相同的辅助数组 newMatrix 临时存储旋转后的结果。我们遍历 matrix 中的每一个元素，根据上述规则将该元素存放到 newMatrix 中对应的位置。在遍历完成之后，再将 newMatrix 中的结果复制到原数组中即可。代码比较简单就不放上来了</p><p>方法二：原地旋转</p><p><strong>想出方法一中的等式很重要</strong></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224637149.png" alt="image-20220422224637149"></p></li></ol><p>​不断重复此过程，就可以发现这四项处于一个循环中，并且每一项旋转后的位置就是下一项所在的位置</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224751882-1662463137547101.png" alt="image-20220422224751882"></p><p>​当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224901047-1662463137547103.png" alt="image-20220422224901047"></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422224918636-1662463137547104.png" alt="image-20220422224918636"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n+<span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//如果n是奇数，(n-1)/2=n/2</span></span><br><span class="line">            <span class="comment">//如果n是偶数，(n+1)/2=n/2</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​方法三：用翻转代替旋转</p><p>​可以通过先进行水平翻转，再进行对角线翻转得到结果。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220422225301778-1662463137547105.png" alt="image-20220422225301778"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=matrix.length;</span><br><span class="line">    <span class="comment">//水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n-i-<span class="number">1</span>][j];</span><br><span class="line">            matrix[n-i-<span class="number">1</span>][j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="23"><li><p>字母异位词分组(49)：</p><p>两个字符串互为字母异位词，当且仅当<strong>两个字符串包含的字母相同</strong>。同一组字母异位词中的字符串具备相同特征，可以使用相同特征作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键，也就是用排序和计数两种方式求出的对应的字符串的特征来作为哈希表的键。代码可以很好的复习一下Java的集合的使用。</p><p>方法一：排序</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将<strong>排序之后的字符串</strong>作为哈希表的键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str :</span><br><span class="line">         strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        String key=<span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">        <span class="comment">//getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</span></span><br><span class="line">        <span class="comment">//hashmap.getOrDefault(Object key, V defaultValue)</span></span><br><span class="line">        List&lt;String&gt; list=map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：计数</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str :</span><br><span class="line">         strs) &#123;</span><br><span class="line">        <span class="type">int</span>[] counts=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            counts[str.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span></span><br><span class="line">        StringBuffer stringBuffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                stringBuffer.append((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i));</span><br><span class="line">                stringBuffer.append(counts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String key=stringBuffer.toString();</span><br><span class="line">        List&lt;String&gt; list=map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key,list);<span class="comment">//设置哈希表的键值对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大子数组和(53)：</p><p>方法一：动态规划</p><p>设计状态思路：<strong>把不确定的因素确定下来</strong>，进而<strong>把子问题定义清楚，把子问题定义得简单</strong>。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>编写动态规划解题的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><p>定义状态（定义子问题）</p><p><code>dp[i]</code>：表示以 <code>nums[i]</code> <strong>结尾</strong> 的 <strong>连续</strong> 子数组的最大和。</p><p><strong>说明</strong>：「结尾」和「连续」是关键字。</p><p>状态转移方程（描述子问题之间的联系）</p><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><ul><li>如果 <code>dp[i - 1] &gt; 0</code>，那么可以把 <code>nums[i]</code> 直接接在 <code>dp[i - 1]</code> 表示的那个数组的后面，得到和更大的连续子数组；</li><li>如果 dp[i - 1] &lt;&#x3D; 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</li></ul><p>以上两种情况的最大值就是 <code>dp[i]</code> 的值，写出如下状态转移方程：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423152015663-1662463137547106.png" alt="image-20220423152015663"></p><p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423152050928-1662463137547107.png" alt="image-20220423152050928"></p><p>友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。</p><p>思考初始值</p><p><code>dp[0]</code> 根据定义，只有 1 个数，一定以 <code>nums[0]</code> 结尾，因此 <code>dp[0] = nums[0]</code>。</p><p>思考输出</p><p><strong>注意</strong>：这里状态的定义不是题目中的问题的定义，<strong>不能直接将最后一个状态返回回去</strong>，而要返回dp数组的最大值</p></li><li><p>跳跃游戏(55)：</p><p>方法一：</p><p>根据题目所给条件<code>0 &lt;= nums[i] &lt;= 105</code>，如果数组中的数字全大于0，那么每次跳一步一定可以到达终点，那么就只需判断等于0的位置，看在等于0的位置前面有没有位置可以跳过0，这样又能化归到全部大于0的情况，<del>偷鸡做法</del>。</p><blockquote><p>开始想用回溯法来做，会超时，思路是从起点开始遍历所有可能走的情况看最终能不能走到终点，类似dfs</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//[2,0,0]，这种情况需要特别判断</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp=i-<span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> canJumpZero=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//如果从temp位置可以直接跳到结尾当然也能跳过0，这是防止结尾的数是0导致算法不正确</span></span><br><span class="line">                <span class="keyword">if</span> (nums[temp]&gt;=i-temp+<span class="number">1</span>||nums[temp]&gt;=nums.length-<span class="number">1</span>-temp)&#123;</span><br><span class="line">                    canJumpZero=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!canJumpZero)&#123;<span class="comment">//不能跳过零就会卡在零的位置直接返回false即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：贪心</p><p>设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即x+nums[x]≥y，那么位置 y 也可以到达。</p><p>换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p><p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。</p><p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p><p>以题目中的示例一[2, 3, 1, 1, 4]为例：</p><p>我们一开始在位置 0，可以跳跃的最大长度为 2，因此最远可以到达的位置被更新为 2；</p><p>我们遍历到位置 1，由于1≤2，因此位置 1 可达。我们用 1 加上它可以跳跃的最大长度 3，将最远可以到达的位置更新为 1+3&#x3D;4。由于 4 大于等于最后一个位置 4，因此我们直接返回 True。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> canReach=cur+nums[cur];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canReach&gt;= nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//稍微优化一下，如果能够到达终点就直接返回true了不要继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canReach&gt;=i)&#123;</span><br><span class="line">            canReach=Math.max(canReach,i+nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并区间(56)：</p><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423194439426-1662463137547108.png" alt="image-20220423194439426"></p><p>我们用数组 merged 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li><p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p></li><li><p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。举几个例子，<code>[1,3] 和 [3,6]</code>，<code>[1,3]和[2,6]</code>，但当前区间的左端点一定小于数组末尾的左端点，因为前面已经排过序了</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);<span class="comment">//按照数组的第一个元素升序排序</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; merged=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> left=intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> right=intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//当前区间的左端点在数组 merged 中最后一个区间的右端点之后</span></span><br><span class="line">        <span class="keyword">if</span> (merged.size()==<span class="number">0</span>||merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>]&lt;left)&#123;</span><br><span class="line">            merged.add(intervals[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//重置数组末尾的右端点</span></span><br><span class="line">            merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>]=Math.max(merged.get(merged.size()-<span class="number">1</span>)[<span class="number">1</span>],right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同路径(62)：</p><p>方法一：递归，<del>虽然不能AC</del>还是贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] paths)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == m &amp;&amp; y == n) &#123;</span><br><span class="line">        paths[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; m || y &gt; n) &#123;</span><br><span class="line">        <span class="comment">//越界就直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    findPaths(m, n, x + <span class="number">1</span>, y, paths);<span class="comment">//向下走</span></span><br><span class="line">    findPaths(m, n, x, y + <span class="number">1</span>, paths);<span class="comment">//向右走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] paths = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];<span class="comment">//传数组进去是为了能在函数里面修改值</span></span><br><span class="line">    findPaths(m, n, <span class="number">1</span>, <span class="number">1</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> paths[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>用f（i，j）表示从左上角走到第i行第j列位置的路径总数，1&#x3D;&lt;i&lt;&#x3D;m，1&#x3D;&lt;j&lt;&#x3D;n</p><p>由于我们每一步只能从向下或者向右移动一步，因此要想走到 (i, j)，如果向下走一步，那么会从 (i-1, j) 走过来；如果向右走一步，那么会从 (i, j-1) 走过来。</p><p>因此我们可以写出动态规划转移方程：<code>f(i, j) = f(i-1, j) + f(i, j-1)</code><br>需要注意<strong>初始条件</strong>，dp [1] [1] &#x3D; 1，表示从（1，1）走到（1，1）有一种走法，这是为了保证m和n等于一时代码也是正确的，其次是第一行和第一列都是1，因为只能向右走和向下走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>动态规划的解题套路</strong></p><p>什么样的问题可以考虑使用动态规划解决呢？</p><p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。比如一些求最值的场景，如<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等等，都是动态规划的经典应用场景。</p><p>动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里总结了一下我做动态规划的思路：</p><ul><li>穷举分析</li><li>确定边界</li><li>找出规律，确定最优子结构</li><li>写出状态转移方程</li></ul><p><strong>动态规划是自底向上解决问题，递归是自顶向下解决问题</strong></p></li><li><p>最小路径和(64)：</p><p>与62题的动态规划大同小异，由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p><p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p><p>创建二维数组 dp，与原始网格的大小相同，dp [i] [j] 表示从左上角出发到 (i,j) 位置的最小路径和。显然，dp[0] [0]&#x3D;grid[0] [0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。</p><p>当 i&gt;0 且 j&#x3D;0 时，<code>dp [i] [j]=dp [i-1] [0]+grid[i] [0]</code></p><p>当 i&#x3D;0 且 j&gt;0 时，<code>dp [i] [j]=dp[0] [j-1]+grid[0] [j]</code></p><p>当 i&gt;0 且 j&gt;0 时，<code>dp[i] [j]=Math.min(dp[i-1] [j],dp[i] [j-1])+grid[i] [j]</code></p><p>最后得到 dp[m-1] [n-1] 的值即为从网格左上角到网格右下角的最小路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>爬楼梯(70)：</p><p>方法一：动态规划</p><p>经典的动态规划和递归的问题，比较简单直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：矩阵快速幂</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423221916169-1662463137547109.png" alt="image-20220423221916169"></p><p>快速幂算法求$M^n$可以使时间复杂度降为O(log n),下面简单介绍一下快速幂算法</p><p><strong>递归快速幂</strong></p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220423230325266-1662463137547110.png" alt="image-20220423230325266"></p><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n&#x2F;2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> qpow(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> qpow(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个temp变量是必要的，因为如果不把quickPow算出的结果记录下来，直接写成quickPow(a, n &#x2F;2)*quickPow(a, n &#x2F;2)，那会计算两次a^(n&#x2F;2)，整个算法就退化为了 O(n)。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p><p>递归虽然<strong>简洁</strong>，但会产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong>。</p><p><strong>非递归快速幂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;       <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;<span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码可以作为非递归快速幂的模板代码，尽量记住</p><p>矩阵的快速幂只需要把上面代码中的乘法改成矩阵乘法，把ans初始化为单位矩阵即可，下面贴上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] matrixMultiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">    <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] quickPow(<span class="type">int</span>[][] a, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//初始化为单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = matrixMultiply(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a = matrixMultiply(a, a);<span class="comment">//a=a*a</span></span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] res = quickPow(matrix, n);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">1</span>][<span class="number">0</span>]+res[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑距离(72)：</p><p>动态规划问题，dp[i] [j]表示word1中长度为i的字符串（下标从 0 到 i-1 ）转换成word2中长度为j的字符串（下标从 0 到 j-1 ）所需要的最小步数。</p><p>状态转移方程：</p><p>当 <code>word1[i] == word2[j]，dp[i] [j] = dp[i-1] [j-1]</code>；</p><p>当 <code>word1[i] != word2[j]，dp[i] [j] = min(dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]) + 1</code></p><p>其中，<code>dp[i-1] [j-1]</code>表示<strong>替换</strong>word1[i-1]为word2[j-1]操作，<code>dp[i-1] [j]</code> 表示<strong>删除</strong>word1[i-1]操作，<code>dp[i] [j-1]</code> 表示在word1后<strong>插入</strong>word[j-1]操作。三种操作中取步骤数最小的然后加上本次操作。 </p><p>注意，针对第一行，第一列要单独考虑，我们引入 <code>&#39;&#39;</code> 下图所示：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220424201017152-1662463137547111.png" alt="image-20220424201017152"></p><p>第一行，是 <code>word1</code> 为空变成 <code>word2</code> 最少步数，就是插入操作</p><p>第一列，是 <code>word2</code> 为空，需要的最少步数，就是删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="comment">//动态规划，dp数组里的i j分别表示word1和word2的长度</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word1.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word2.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; word1.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; word2.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>颜色分类(75)：</p><p>方法一：<del>偷鸡做法</del></p><p>因为一共只有三种ya颜色分别是0，1，2，所以遍历一遍原数组找出每种颜色有多少，在按照题目要求的颜色的顺序填回到原数组即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] colors=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        colors[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> indexColors=<span class="number">0</span>,indexRes=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexColors&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (colors[indexColors]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[indexRes]=indexColors;</span><br><span class="line">            colors[indexColors]--;</span><br><span class="line">            indexRes++;</span><br><span class="line">        &#125;</span><br><span class="line">        indexColors++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>直接<del>调用排序AP</del>I来做就好，自己手写排序算法即可</p></li><li><p>最小覆盖子串(76)：<strong>滑动窗口</strong></p><p>本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<strong>我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。如果收缩后不满足条件，则让r指针不断扩张窗口，寻找新的满足条件的滑动窗口。</strong>一直重复此过程直到 j 超出了字符串 S 范围。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220425220202755.png" alt="image-20220425220202755"></p><p>这道题目的解题代码中就用了两个HashMap来实现并维护s中出现的需要的字符数量表（简称已有字符表），实现了一次遍历统计出t中每个字符的数量（简称所需字符表），可以好好领悟一下HashMap的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinWindow</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; ori = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="literal">null</span>|| s.equals(<span class="string">&quot;&quot;</span>) ||t==<span class="literal">null</span>||t.equals(<span class="string">&quot;&quot;</span>)||s.length()&lt;t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tLen=t.length();</span><br><span class="line">        <span class="comment">//利用HashMap的特点统计t中每个字符出现的次数，getOrDefault经典操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tLen; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c=t.charAt(i);</span><br><span class="line">            ori.put(c, ori.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l窗口的左边界，r窗口的右边界,r初始化为-1是为了匹配下面while循环一开始就r++，len是窗口的最小长度</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len=Integer.MAX_VALUE,ansL=-<span class="number">1</span>,ansR=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sLen=s.length();</span><br><span class="line">        <span class="keyword">while</span> (r&lt;sLen)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="comment">//向右扩展一格窗口，如果此时右边界的字符是所需要的字符，则更新已有字符表</span></span><br><span class="line">            <span class="keyword">if</span> (r&lt;sLen&amp;&amp; ori.containsKey(s.charAt(r)))&#123;</span><br><span class="line">                cnt.put(s.charAt(r),cnt.getOrDefault(s.charAt(r),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check满足条件后才开始不断收缩左边界直到不满足包含t中所有字符</span></span><br><span class="line">            <span class="comment">//l&lt;=r,窗口会不断收缩l++但l不能超过r可以等于r</span></span><br><span class="line">            <span class="keyword">while</span> (check()&amp;&amp;l&lt;=r)&#123;</span><br><span class="line">                <span class="keyword">if</span> (r-l+<span class="number">1</span>&lt;len)&#123;<span class="comment">//更新窗口的最小长度</span></span><br><span class="line">                    len=r-l+<span class="number">1</span>;</span><br><span class="line">                    ansL=l;</span><br><span class="line">                    ansR=r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收缩的过程中如果左边界的字符是t所需要的，l++后该字符就没有了，需要更新已有字符表</span></span><br><span class="line">                <span class="keyword">if</span> (ori.containsKey(s.charAt(l)))&#123;</span><br><span class="line">                    cnt.put(s.charAt(l),cnt.get(s.charAt(l))-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ansL==-<span class="number">1</span>&amp;&amp;ansR==-<span class="number">1</span>)?<span class="string">&quot;&quot;</span>:s.substring(ansL,ansR+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry :</span><br><span class="line">             ori.entrySet()) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            Integer value= entry.getValue();</span><br><span class="line">            <span class="comment">//s的子串的某些字符的数量大于等于t中每一个字符的数量都是可以的，但如果某一个小于就不符合条件了</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.getOrDefault(key,<span class="number">0</span>)&lt;value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子集(78)：</p><p>方法一：迭代法实现子集枚举</p><p>用01序列表示特征函数，1表示该位置的数在子集里，0表示该位置的数不在子集里，可以发现 01 序列对应的二进制数正好从 0 到 2^n - 1，这样我们可以吗，枚举完所有的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span>[] index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index.length; i++) &#123;<span class="comment">//枚举01序列的函数</span></span><br><span class="line">        <span class="keyword">if</span> (index[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            index[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//00 10 01 11</span></span><br><span class="line">    <span class="comment">//000 100 010 110 001 101 011 111</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, nums.length);<span class="comment">//计算出需要枚举的次数</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; index.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        update(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归法实现子集枚举</p><p>对于集合中的每一个数，只有两种情况，选取该数字加入子集中，不选取该数字，和上面的01序列相似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp,<span class="type">int</span> cur,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur== nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.add(nums[cur]);<span class="comment">//取当前位置的数字</span></span><br><span class="line">    dfs(res, temp, cur+<span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size()-<span class="number">1</span>);<span class="comment">//不取当前位置的数字</span></span><br><span class="line">    dfs(res, temp, cur+<span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(res,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),<span class="number">0</span>,nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单词搜索(79)：</p><p>与递归走迷宫类似，从某一个起点出发，递归的向上走，向下走，向左走，向右走，看四个方向的哪个方向可以满足单词的字符，如果都不能满足直接返回false即可，还要注意不能走回头，走过的路不能重复再走一次，需要维护一个<code>boolean[] isVisited</code>，访问过就标记为已访问。如果此路不通则要回退为没用访问过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exist</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findWord</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> wordIndex, <span class="type">boolean</span>[][] isVisited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordIndex == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//搜索到单词的末尾返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &lt; board.length &amp;&amp; board[x + <span class="number">1</span>][y] == word.charAt(wordIndex) &amp;&amp; !isVisited[x + <span class="number">1</span>][y]) &#123;</span><br><span class="line">            isVisited[x + <span class="number">1</span>][y] = <span class="literal">true</span>;<span class="comment">//先标记为已访问再递归进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x + <span class="number">1</span>, y, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x + <span class="number">1</span>][y] = <span class="literal">false</span>;<span class="comment">//如果此路不通需要回退为没用访问过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x - <span class="number">1</span>][y] == word.charAt(wordIndex) &amp;&amp; !isVisited[x - <span class="number">1</span>][y]) &#123;</span><br><span class="line">            isVisited[x - <span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x - <span class="number">1</span>, y, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x - <span class="number">1</span>][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt; board[<span class="number">0</span>].length &amp;&amp; board[x][y + <span class="number">1</span>] == word.charAt(wordIndex) &amp;&amp; !isVisited[x][y + <span class="number">1</span>]) &#123;</span><br><span class="line">            isVisited[x][y + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x, y + <span class="number">1</span>, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x][y + <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[x][y - <span class="number">1</span>] == word.charAt(wordIndex) &amp;&amp; !isVisited[x][y - <span class="number">1</span>]) &#123;</span><br><span class="line">            isVisited[x][y - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, x, y - <span class="number">1</span>, wordIndex + <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isVisited[x][y - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length * board[<span class="number">0</span>].length &lt; word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断特殊情况直接返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Point&gt; points = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                    points.add(<span class="keyword">new</span> <span class="title class_">Point</span>(i, j));<span class="comment">//找到满足第一个字符的所有位置，依次从这些位置开始搜索</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Point start :</span><br><span class="line">             points) &#123;</span><br><span class="line">            <span class="type">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">            isVisited[start.x][start.y] = <span class="literal">true</span>;<span class="comment">//将起始位置标记为已访问，这一步很重要!</span></span><br><span class="line">            <span class="comment">//防止后面递归搜索路径的时候又搜索到开始的位置</span></span><br><span class="line">            <span class="keyword">if</span> (findWord(board, word, start.x, start.y, <span class="number">1</span>, isVisited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//有一条路存在直接返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>柱状图中最大的矩形(84)：这道题可以好好的理解一下<strong>单调栈</strong></p><p>方法一：暴力模拟（超时）</p><p>依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。</p><p>为此，我们需要：</p><p>左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</p><p>右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。</p><p>对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (left - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; heights[left - <span class="number">1</span>] &gt;= heights[i]) &#123;<span class="comment">//先判断前一位是否满足条件再left--</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (right + <span class="number">1</span> &lt; len &amp;&amp; heights[right + <span class="number">1</span>] &gt;= heights[i]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heights[i] * (right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; res) &#123;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：<strong>单调栈</strong></p><p>先说明一下单调栈是什么</p><ul><li>单调递增栈：从<strong>栈底到栈顶</strong>，栈中的值单调递增</li><li>单调递减栈：从<strong>栈底到栈顶</strong>，栈中的值单调递减</li></ul><p>单调栈则主要用于解决<strong>NGE问题</strong>（Next Greater Element），也就是，对序列中每个元素，找到下一个比它大的元素。（当然，“下一个”可以换成“上一个”，“比它大”也可以换成“比他小”，原理不变。）</p><p>我们维护一个栈，表示“<strong>待确定NGE的元素</strong>”，然后遍历序列。当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的NGE，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p><p>我们归纳一下枚举「高」的方法：</p><p>首先我们枚举某一根柱子 i 作为高 h&#x3D;heights[i]；</p><p>随后我们需要进行向左右两边扩展，使得<strong>扩展到的柱子的高度均不小于 h</strong>。换句话说，我们需要<strong>找到左右两侧最近的高度小于 h 的柱子</strong>，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 h，并且就是 i 能够扩展到的最远范围。</p><p>那么我们先来看看如何求出<strong>一根柱子的左侧且最近的小于其高度的柱子</strong>，可以用单调递增栈来实现，栈中存放的是每根柱子的下标</p><p>栈中存放了 j 值。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</p><p>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 height[j]≥height[i] 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 height[j]&lt;height[i]，此时 j 就是 i 左侧且最近的小于其高度的柱子，我们再将 i 放入栈顶。</p><p>这里会有一种特殊情况。如果我们移除了栈中所有的 j 值，那就说明 i 左侧所有柱子的高度都大于等于 height[i]，那么我们可以认为 i 左侧且最近的小于其高度的柱子在位置 j&#x3D;-1，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。相对应的最右侧也会有哨兵。</p><p>下面的代码是通过从左向右和从右向左两次遍历分别求出一根柱子的左侧且最近的小于其高度的柱子，一根柱子的右侧且最近的小于其高度的柱子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            left[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            right[i] = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.max(res, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了两次遍历之外，我们还可以对该方法进行优化，只用一次遍历就找出left和right数组.</p><p>在方法一中，我们在对位置 i 进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置 i 进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置 i 被弹出栈时，说明此时遍历到的位置的高度小于等于 height[i]，并且在 i0 与 i 之间没有其他高度小于等于 height[i] 的柱子。这是因为，如果在 i 和i0之间还有其它位置的高度小于等于 height[i] 的，那么在遍历到那个位置的时候，i 应该已经被弹出栈了。所以位置 i0就是位置 i的右边界。</p><p>等等，我们需要的是「一根柱子的左侧（或右侧）且最近的小于其高度的柱子」，但这里我们求的是小于等于，那么会造成什么影响呢？答案是：我们确实无法求出正确的右边界，但对最终的答案没有任何影响。这是因为在答案对应的矩形中，如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界</strong>的，而我们没有对求出左边界的算法进行任何改动，因此最终的答案还是可以从最右侧的与矩形高度相同的柱子求得的。下面举一个例子来说明这一点</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220502225551702-1662463137547113.png" alt="image-20220502225551702"></p><p>该算法有两个规则：</p><ul><li>当有柱子假设为柱子i入栈时，栈顶的柱子就是柱子i的左边界（因为是单调递增栈）</li><li>当有柱子（记为柱子i）出栈时，此时遍历到的柱子（记为index）的高度小于等于柱子i，柱子i的右边界为柱子index</li></ul><p>首先要明确当有柱子出栈和入栈时，可以确定柱子的左边界或右边，还要时刻记得栈中的数据从栈底到栈顶是严格递增的。如上图所示，当我们遍历到柱子4的时候，栈中只有柱子3（因为柱子4最近的小于其高度的柱子是柱子3，如果不明白可以从头开始推），我们将柱子4入栈，那么可以确定柱子4的左边界为柱子3，然后遍历到柱子5，此时柱子5的高度大于等于柱子4，柱子4将出栈，按照规则此时可以确定柱子4的右边界是柱子5（虽然柱子5不是右边最近的小于其高度的柱子，耐心接着往下看），然后柱子5比栈中的柱子3高，柱子5入栈，此时可以确定柱子5的左边界是柱子3，然后接着遍历到了柱子6，柱子6的高度小于此时栈顶柱子（为柱子5）的高度，柱子5出栈，可以确定柱子5的右边界为柱子6，所以柱子5的边界为柱子3和柱子6，虽然柱子4的右边界不正确。至此就可以理解如果有若干个柱子的高度都等于矩形的高度，那么<strong>最右侧的那根柱子是可以求出正确的右边界</strong>的.</p><p>在遍历结束后，栈中仍然有一些位置，这些位置对应的右边界就是位置为 n 的「哨兵」。我们可以将它们依次出栈并更新右边界，也可以在初始化右边界数组时就将所有的元素的值置为 n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=heights.length;</span><br><span class="line">    <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(right,n);<span class="comment">//初始化右边界哨兵为n</span></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;=heights[i])&#123;</span><br><span class="line">            right[stack.peek()]=i;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            left[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i]=stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res=Math.max(res,(right[i]-left[i]-<span class="number">1</span>)*heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大矩形(85)：</p><p>如果能发现这道题是上一题的一个变种就比较好做，题目要求的是在二维矩阵中找出最大矩形，可以<strong>一行一行的看</strong>，当作是<strong>在一维数组中找到最大的矩形</strong>，如下图所示</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507143621905.png" alt="image-20220507143621905"></p><p>需要注意的是，比如说以第四行为坐标轴的时候，第四行第二列的元素为0，那么这一行的高度就为0，而不要考虑上面有多高，不会出现悬浮的列，这样才能和84题统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=heights.length;</span><br><span class="line">    <span class="type">int</span>[] left=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(right,n);<span class="comment">//记得初始化右哨兵为n</span></span><br><span class="line">    Deque&lt;Integer&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//依旧是单调栈解法找出第一个比他小的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;=heights[i])&#123;</span><br><span class="line">            right[stack.pop()]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            left[i]=-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i]=stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res=Math.max(res,heights[i]*(right[i]-left[i]-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] heights=<span class="keyword">new</span> <span class="title class_">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                heights[j]+=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                heights[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxArea=Math.max(maxArea,largestRectangleArea(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的中序遍历(94)：</p><p>简单题，一定要记得二叉树的三种递归遍历方式</p></li><li><p>不同的二叉搜索树(96)：</p><p>这道题是一个<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin">卡塔兰树</a>问题，<del>虽然我不知道卡塔兰树</del></p><p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)。</p><p>可见，G(n) 是我们求解需要的函数。稍后我们将看到，G(n) 可以从 F(i, n) 得到，而 F(i, n)又会递归地依赖于 G(n)。不同的二叉搜索树的总数 G(n)，是对遍历所有 i (1≤i≤n) 的 F(i, n) 之和。对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：G(0)&#x3D;1,G(1)&#x3D;1</p><p>给定序列 1 2 3 ⋯ n，我们选择数字 i 作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507211036783-1662463137547115.png" alt="image-20220507211036783"></p><p>注意到 G(n)和序列的内容无关，只和序列的长度有关。 因此，我们可以得到以下公式：</p><p><code>F(i, n) = G(i-1)*G(n-i)</code><br>最终G(n)的递归表达式为：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220507211414749-1662463137547116.png" alt="image-20220507211414749"></p><p>至此，我们从小到大计算 G函数即可，因为 G(n)的值依赖于 G(0)⋯G(n−1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>验证二叉搜索树(98)：</p><p>方法一：递归</p><p>由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p><p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p><p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode node,<span class="type">long</span> low,<span class="type">long</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.val&lt;=low||node.val&gt;=high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(node.left,low,node.val)&amp;&amp;helper(node.right,node.val,high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root,Long.MIN_VALUE,Long.MAX_VALUE);<span class="comment">//取为long防止数据过大达到int的最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另一种递归的方式，中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;<span class="comment">//初始化前驱结点的值为最小值保证根结点处的正确性</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;<span class="comment">//向右递归时，将此时的结点作为pre结点</span></span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>二叉搜索树中序遍历得到严格升序的序列，对给定的二叉树中序遍历，结果记录于res之中，检验res是否为严格的升序，若是则为true，反之false。因为中序遍历得到的序列（记为res）一定严格递增，所以如果有一处位置i不满足单调递增，一定有res[i]&gt;&#x3D;res[i+1]，换句话说就是不满足递增的位置一定是相邻的两个位置，假设位置不相邻，比如序列 i , j , k，res[i]&gt;&#x3D;res[k]，但是res[j]&gt;&#x3D;res[i]，所以res[j]&gt;&#x3D;res[k]，所以一定可以找到一个不满足递增的相邻位置。</p><p>这一点上有时候直觉（直接的感觉）挺有用的，可以先按照直觉写出代码跑一下，如果不正确根据错误用例来改就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        inorderTraversal(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inorderTraversal(root, res);</span><br><span class="line">    Integer[] seq = <span class="keyword">new</span> <span class="title class_">Integer</span>[res.size()];</span><br><span class="line">    res.toArray(seq);</span><br><span class="line">    <span class="comment">//遍历一次如果有相邻的两个数不满足单调递增直接返回false即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; seq.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[i] &gt;= seq[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的层序遍历(102)：广度优先搜索</p><p>首先根元素入队<br>当队列不为空的时候</p><ul><li>求当前队列的长度 si </li><li>依次从队列中取 si个元素进行拓展，然后进入下一次迭代</li></ul><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里<strong>每次取 si个元素</strong>。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 si个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="keyword">while</span> (deque.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeCount</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodeCount; i++) &#123;<span class="comment">//每次取si个元素进行扩展</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            temp.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;<span class="comment">//左子节点为空或右子节点为空就不要加入队列</span></span><br><span class="line">                deque.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树的最大深度(104)：</p><p>方法一：深度优先搜索</p><p>如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为<code>max(l,r)+1</code></p><p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1)时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。<strong>这是求二叉树深度的经典算法最好背下来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                deque.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从前序与中序遍历序列构造二叉树(105)：</p><p>方法一：递归</p><p>对于任意一颗树而言，前序遍历的形式总是 [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p><strong>细节</strong></p><p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1)的时间对根节点进行定位了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">myBuildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;<span class="comment">//说明此时得到的是叶子结点，直接返回null就行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">    <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inorder_root</span> <span class="operator">=</span> indexMap.get(preorder[preorder_left]);</span><br><span class="line">    <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preorder_left]);</span><br><span class="line">    <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size_left_subtree</span> <span class="operator">=</span> inorder_root - inorder_left;</span><br><span class="line">    <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">    root.left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">    root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">    indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        indexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：迭代</p><p>了解一下，这个做法不一定能想得出来<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p></li><li><p>二叉树展开为链表(114)：</p><p>方法一：前序遍历</p><p>将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。可以通过递归或迭代的方式实现前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, ArrayList&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    res.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        preorder(node.left, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        preorder(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">        cur.left = <span class="literal">null</span>;</span><br><span class="line">        cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(res.get(i));</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：前序遍历和展开同时进行</p><p>使用方法一的前序遍历，由于将节点展开之后会破坏二叉树的结构而丢失子节点的信息，因此前序遍历和展开为单链表分成了两步。能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？</p><p>之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。只要对前序遍历进行修改，<strong>在遍历左子树之前就获得左右子节点的信息</strong>，并存入栈内，子节点的信息就不会丢失，就可以将前序遍历和展开为单链表同时进行。</p><p>该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历。修改后的前序遍历的具体做法是，每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则<strong>依次将右子节点和左子节点压入栈内（注意入栈顺序）</strong>。</p><p>展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.left = <span class="literal">null</span>;</span><br><span class="line">            pre.right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> cur.left, right = cur.right;</span><br><span class="line">        <span class="comment">//先压栈的是右节点，然后再压入左节点，出栈是就是先左再右的顺序</span></span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次pre等于null的时候将pre写为cur，不能写成pre=pre.right，第一次pre为null</span></span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：寻找前驱结点</p><p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。找前驱结点在<strong>线索化二叉树</strong>的时候做过，找到叶子结点 的前驱结点和后继结点。</p><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点（就是把后继结点挂上去），然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空，（向右展开）。对当前节点处理结束后，继续处理链表中的下一个节点（下一个右子节点），直到所有节点都处理结束。这个地方需要画图好好理解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录下当前结点的左子结点</span></span><br><span class="line">            TreeNode next=cur.left;</span><br><span class="line">            TreeNode pre=next;</span><br><span class="line">           <span class="comment">//对于当前节点cur，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点</span></span><br><span class="line">            <span class="keyword">while</span> (pre.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pre=pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前节点的右子节点赋给前驱节点的右子节点（就是把后继结点挂上去）</span></span><br><span class="line">            pre.right=cur.right;</span><br><span class="line">            <span class="comment">//将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空</span></span><br><span class="line">            cur.left=<span class="literal">null</span>;</span><br><span class="line">            cur.right=next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>买卖股票的最佳时机(121)：</p><p>一道简单题，翻译一下就是找到数组中后一个数与前一个数的最大差值（差值必须是真的，如果只能是负的就返回0），可以通过一次遍历来实现这个结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,buy=prices[<span class="number">0</span>];<span class="comment">//买入的价格初始化为第一天的价格，结果初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果某一天的价格大于买入的价格就尝试卖出，并且和之前卖出的收入进行比较，取收入高的那个</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i]&gt;buy)&#123;</span><br><span class="line">            res=Math.max(res,prices[i]-buy);</span><br><span class="line">        <span class="comment">//如果某天的价格比买入的价格低，那么就应该从这一天买入</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (prices[i]&lt;buy)&#123;</span><br><span class="line">            buy=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树中的最大路径和(124)：</p><p>这题目的难点在于理解题意和转化题意。</p><p><strong>思路</strong></p><ol><li><p>「可以从任意节点出发, 到达任意节点」 的路径,<br>一定是先上升（ 0 ～ n 个）节点, 到达顶点, 后下降（ 0 ～ n 个）节点。当我们站在顶点的位置来看，就是向左子树走一条路径，向右子树走一条路径，在左子树中不能既向左走又向右走，这样就无法从左子树走回到右子树了（下面还会仔细说明这个地方）。我们可以通过枚举顶点的方式来枚举路径。</p></li><li><p>我们枚举顶点时, 可以把路径分拆成3部分： 左侧路径、右侧路径和顶点。<br>如下面的路径, 顶点为 20, 左侧路径为 6 -&gt; 15, 右侧为 6 -&gt; 7。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> -10</span><br><span class="line"> /  \</span><br><span class="line">9   20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br><span class="line"> /    / \</span><br><span class="line">6    4   6</span><br></pre></td></tr></table></figure><p>以当前节点为顶点的路径中, 最大和为 两侧路径的最大和 + 节点的值。需要注意的是, 两侧路径也可能不选, 此时取 0</p></li></ol><p><strong>实现细节</strong></p><p>首先，考虑实现一个简化的函数 maxGain(node)，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p><p>具体而言，该函数的计算如下。</p><ul><li><p>空节点的最大贡献值等于 0。</p></li><li><p>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</p></li></ul><p>例如，考虑如下二叉树。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  -10</span><br><span class="line"> /   \</span><br><span class="line">9    20</span><br><span class="line">    /  \</span><br><span class="line">  15    7</span><br></pre></td></tr></table></figure><p>叶节点 9、15、7 的最大贡献值分别为 9、15、7。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 20+max(15,7)&#x3D;35，节点 -10 的最大贡献值等于 −10+max(9,35)&#x3D;25。</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 maxGain，即可得到每个节点的最大贡献值。</p><p>再次说明一下这里的最大贡献值，某一个结点的最大贡献值只能取左子树的最大贡献值和右子树的最大贡献值中较大的一个并且和结点的值相加，然后会将该结果返回到递归的上一层，这样对于上一层来看，拿到的就是左子树的最大贡献值，并且可以从左子树走到这一层的顶点，然后再往右子树走</p><p>根据函数 maxGain 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，<strong>该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</strong>，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> res=Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//保证传入空结点时的正确性</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxGain(root);<span class="comment">//求出每个结点的最大贡献值，这是个递归的过程</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=Math.max(maxGain(node.left),<span class="number">0</span>);<span class="comment">//左结点的最大贡献值如果小于0就不要贡献了，越加越小肯定是不对的</span></span><br><span class="line">    <span class="type">int</span> right=Math.max(maxGain(node.right),<span class="number">0</span>);</span><br><span class="line">    res=Math.max(res,node.val+left+right);</span><br><span class="line">    <span class="keyword">return</span> node.val+Math.max(left,right);<span class="comment">//这里体现了这个递归的精髓</span></span><br><span class="line">    <span class="comment">//将该结点与左子树贡献和右子树贡献最大的一个向上返回（只返回左右子树的一边），对于父亲结点（大问题）来看，就是在父结点中找到了加起来的值最大的一条通路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复盘总结递归</strong><br>递归一个树，会对每个子树做同样的事（你写的处理逻辑），所以你需要思考要对每个子树做什么事，即思考子问题是什么，大问题怎么拆解成子问题。<br>通过求出每个子树对外提供的最大路径和（返回出来给父节点），从递归树底部向上，不断求出了每个子树内部的最大路径和，后者是求解的目标，它的求解需要前者，搞清楚二者的关系。<br>每个子树的内部最大路径和，都挑战一下最大纪录，递归结束时，最大纪录就有了。<br>思考递归问题，别纠结细节实现，内部细节是子递归帮你去做的，应结合求解的目标，自顶而下、屏蔽细节地思考，思考递归子问题的定义。随着递归出栈，子问题自下而上地解决，最后解决了整个问题。<br>要做的只是<strong>写好递归的处理逻辑，怎么处理当前子树？需要返回什么吗？怎么设置递归的出口？</strong><br>没有思路的时候，试着画画递归树找思路。就算做对了，画图也能加深对递归算法的理解。</p><p>画图的时候可以反过来自底向上的画，先画出最简单的情况，然后看得出简单情况的结果后，如果该情况是一个大问题的子问题，那么该子问题可以怎么运用到大问题的解决当中去</p></li><li><p>最长连续序列(128)：</p><p>这是一道很好的使用<strong>哈希表</strong>的题目（<del>虽然我想到了用哈希表但还是没做出来</del>），我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列 x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>那么怎么判断是否跳过呢？由于我们<strong>要枚举的数 x 一定是在数组中不存在前驱数 x−1 的</strong>，不然按照上面的分析我们会从 x-1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1 即能判断是否需要跳过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; numsSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//创建HashSet去重并且实现了HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         nums) &#123;</span><br><span class="line">        numsSet.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> longest=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         numsSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!numsSet.contains(num-<span class="number">1</span>))&#123;<span class="comment">//不存在前继才开始向后枚举</span></span><br><span class="line">            <span class="type">int</span> curLong=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> temp=num+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (numsSet.contains(temp))&#123;</span><br><span class="line">                curLong+=<span class="number">1</span>;</span><br><span class="line">                temp+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            longest=Math.max(longest,curLong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只出现一次的数字(136)：</p><p>方法一：利用HashSet，遍历数组，当该数字出现在HashSet中就将HashSet中的该数字删掉，如果不存在就将该数字加入到HashSet中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">            set.remove(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num :</span><br><span class="line">         set) &#123;</span><br><span class="line">        res=num;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：异或运算</p><p>经典的异或运算的题目，根据异或运算的交换律和结合律，以及下面两条性质<code>A^A=0, A^0=A</code>，对数组中的数字一次进行异或运算，最后得到的值就是结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res=res^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单词拆分(139)：</p><p>方法一：<strong>动态规划</strong></p><p>我们定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i−1] 是否能被空格拆分成若干个字典中出现的单词。从前往后计算考虑转移方程，每次转移的时候我们需要枚举包含位置 i−1 的最后一个单词，看它是否出现在字典中以及除去这部分的字符串是否合法即可。公式化来说，我们需要枚举 s[0..i−1] 中的分割点 j ，看 s[0..j−1] 组成的字符串s<del>1</del>（默认 j &#x3D; 0 时 s<del>1</del> 为空串）和  s[j..i−1] 组成的字符串 s<del>2</del> 是否都合法，如果两个字符串均合法，那么按照定义 s<del>1</del> 和 s<del>2</del> 拼接成的字符串也同样合法。由于计算到 dp[i] 时我们已经计算出了 dp[0..i−1] 的值，因此字符串 s<del>1</del> 是否合法可以直接由 dp[j] 得知，剩下的我们只需要看 s<del>2</del> 是否合法即可，因此我们可以得出如下转移方程：<br><code>dp[i]=dp[j] &amp;&amp; check(s[j..i−1])</code>，其中 check(s[j..i−1]) 表示子串 s[j..i−1] 是否出现在字典中。</p><p>对于检查一个字符串是否出现在给定的字符串列表里一般可以考虑哈希表来快速判断，同时也可以做一些简单的剪枝，枚举分割点的时候倒着枚举，如果分割点 j 到 i 的长度已经大于字典列表里最长的单词的长度，那么就结束枚举，但是需要注意的是下面的代码给出的是不带剪枝的写法。</p><p>对于边界条件，我们定义 dp[0]&#x3D;true 表示空串且合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; stringHashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; stringHashSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环形链表(141)：</p><p>方法一：哈希表</p><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：快慢指针</p><p>本方法需要对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针和慢指针都在位置 head。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">//注意这里只能用do-while循环</span></span><br><span class="line">        <span class="comment">//先进行判断，防止移动快指针的时候出现空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//fast走到结尾则一定没有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//while循环退出说明追上了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环形链表ⅱ</p><p>方法一：哈希表</p><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。代码很简单和上一题差不多，就不放上来了</p><p>方法二：快慢指针</p><p>可以当作一个追及问题来列方程，我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><blockquote><p>解释一下为何慢指针第一圈没走完一定会和快指针相遇： 首先，第一步，快指针先进入环 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置(也可能此时相遇) 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x &#x3D; 0； 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1&#x2F;s，快指针2&#x2F;s，那么追赶需要(n-x)s 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;&#x3D;0（x&#x3D;0会在第二步相遇），则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></blockquote><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b &#x3D; a+(n+1)b+nc。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220514215556947-1662463137547117.png" alt="image-20220514215556947"></p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有<br>a+(n+1)b+nc&#x3D;2(a+b)⟹a&#x3D;c+(n−1)(b+c)</p><p>有了 a&#x3D;c+(n-1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow=head,fast=head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast.next!=<span class="literal">null</span>)&#123;<span class="comment">//特判fast的next是否为空，防止空指针异常</span></span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明没有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">            ListNode ptr=head;</span><br><span class="line">            <span class="keyword">while</span> (ptr!=slow)&#123;</span><br><span class="line">                ptr=ptr.next;</span><br><span class="line">                slow=slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//此时fast=null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LRU缓存(146)：</p><p><strong>哈希表+双向链表</strong></p><p>很好的一道面向对象的题目，同时也考察了Java集合和一些常用的数据结构</p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><p>双向链表<strong>按照被使用的顺序</strong>存储了这些键值对，<strong>靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</strong></p><p>哈希表即为普通的哈希映射（HashMap），<strong>通过缓存数据的键映射到其在双向链表中的位置</strong>。</p><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p><p>对于 get 操作，首先判断 key 是否存在：</p><ul><li><p>如果 key 不存在，则返回 -1；</p></li><li><p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p></li></ul><p>对于 put 操作，首先判断 key 是否存在：</p><ul><li><p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p></li><li><p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p></li></ul><p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成。</p><p>小贴士</p><p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。&#x3D;&#x3D;<strong>在链表有关的题目中都可以使用哑结点这个技巧</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        LinkedNode prev;</span><br><span class="line">        LinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, LinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode head, tail;<span class="comment">//head和tail是哑结点，删除和插入的时候要注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">LinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">LinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">LinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(LinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>排序链表(148)：</p><p>方法一：<strong>自顶向下归并排序</strong></p><p>对链表自顶向下归并排序的过程如下。</p><p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</p><p>对两个子链表分别排序。</p><p>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用合并两个有序链表的做法，将两个有序的子链表进行合并。</p><p>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。下面有一个草图帮助理解该算法</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521160851670-1662463137547118.png" alt="image-20220521160851670"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sortList(head,<span class="literal">null</span>);<span class="comment">//排序是不包含第二个参数tail一起的，前一个参数包含后一个不包含</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head,ListNode tail)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//如果传入的是null也在这里统一处理了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next==tail)&#123;</span><br><span class="line">        head.next=<span class="literal">null</span>;<span class="comment">//把head的next标记为null，做到真正将子链表分开，方便后面找到中点和merge</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow=head,fast=head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=tail)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast!=tail)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode mid=slow;</span><br><span class="line">    ListNode list1=sortList(head,mid);<span class="comment">//排序是不包含第二个参数tail一起的，前一个参数包含后一个不包含</span></span><br><span class="line">    ListNode list2=sortList(mid,tail);</span><br><span class="line">    <span class="keyword">return</span> merge(list1,list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode temp=dummy,temp1=head1,temp2=head2;</span><br><span class="line">    <span class="keyword">while</span> (temp1!=<span class="literal">null</span>&amp;&amp;temp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1.val&lt;=temp2.val)&#123;</span><br><span class="line">            temp.next=temp1;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next=temp2;</span><br><span class="line">            temp2=temp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp1!=<span class="literal">null</span>)&#123;</span><br><span class="line">        temp.next=temp1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        temp.next=temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：自底向上归并排序</p><p>使用自底向上的方法实现归并排序，则可以达到 O(1) 的空间复杂度。</p><p>首先求得链表的长度length，然后将链表拆分成子链表进行合并。具体做法如下。</p><p>用 subLength 表示每次需要排序的子链表的长度，初始时 subLength&#x3D;1。</p><p>每次将链表拆分成若干个长度为subLength 的子链表（最后一个子链表的长度可以小于 subLength），按照每两个子链表一组进行合并，合并后即可得到若干个长度为subLength×2 的有序子链表（最后一个子链表的长度可以小于 subLength×2）。合并两个子链表仍然使用 合并两个有序链表的做法。</p><p>将 subLength 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 length，整个链表排序完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 自底向上归并排序</span></span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 1. 首先从头向后遍历,统计链表长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于统计链表长度</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                length++;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 2. 初始化 引入dummynode</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            dummyHead.next = head;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 3. 每次将链表拆分成若干个长度为subLen的子链表 , 并按照每两个子链表一组进行合并</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> <span class="number">1</span>;subLen &lt; length;subLen &lt;&lt;= <span class="number">1</span>)&#123; <span class="comment">// subLen每次左移一位（即sublen = sublen*2） PS:位运算对CPU来说效率更高</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummyHead.next;     <span class="comment">// curr用于记录拆分链表的位置</span></span><br><span class="line">        </span><br><span class="line">                <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;               <span class="comment">// 如果链表没有被拆完</span></span><br><span class="line">                    <span class="comment">// 3.1 拆分subLen长度的链表1</span></span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">head_1</span> <span class="operator">=</span> curr;        <span class="comment">// 第一个链表的头 即 curr初始的位置</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLen &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++)&#123;     <span class="comment">// 拆分出长度为subLen的链表1</span></span><br><span class="line">                        curr = curr.next;</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// 3.2 拆分subLen长度的链表2</span></span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">head_2</span> <span class="operator">=</span> curr.next;  <span class="comment">// 第二个链表的头  即 链表1尾部的下一个位置</span></span><br><span class="line">                    curr.next = <span class="literal">null</span>;             <span class="comment">// 断开第一个链表和第二个链表的链接</span></span><br><span class="line">                    curr = head_2;                <span class="comment">// 第二个链表头 重新赋值给curr</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; subLen &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>;i++)&#123;      <span class="comment">// 再拆分出长度为subLen的链表2</span></span><br><span class="line">                        curr = curr.next;</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// 3.3 再次断开 第二个链表最后的next的链接</span></span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">                    <span class="keyword">if</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">                        next = curr.next;   <span class="comment">// next用于记录 拆分完两个链表的结束位置</span></span><br><span class="line">                        curr.next = <span class="literal">null</span>;   <span class="comment">// 断开连接</span></span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// 3.4 合并两个subLen长度的有序链表</span></span><br><span class="line">                    <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> mergeTwoLists(head_1,head_2);</span><br><span class="line">                    prev.next = merged;        <span class="comment">// prev.next 指向排好序链表的头</span></span><br><span class="line">                    <span class="keyword">while</span>(prev.next != <span class="literal">null</span>)&#123;  <span class="comment">// while循环 将prev移动到 subLen*2 的位置后去</span></span><br><span class="line">                        prev = prev.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curr = next;              <span class="comment">// next用于记录 拆分完两个链表的结束位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回新排好序的链表</span></span><br><span class="line">            <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line">​        <span class="comment">// 此处是Leetcode21 --&gt; 合并两个有序链表</span></span><br><span class="line">​        <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">​            <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">​            <span class="type">ListNode</span> <span class="variable">curr</span>  <span class="operator">=</span> dummy;</span><br><span class="line">​        </span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2!= <span class="literal">null</span>)&#123; <span class="comment">// 退出循环的条件是走完了其中一个链表</span></span><br><span class="line">                <span class="comment">// 判断l1 和 l2大小</span></span><br><span class="line">                <span class="keyword">if</span> (l1.val &lt; l2.val)&#123;</span><br><span class="line">                    <span class="comment">// l1 小 ， curr指向l1</span></span><br><span class="line">                    curr.next = l1;</span><br><span class="line">                    l1 = l1.next;       <span class="comment">// l1 向后走一位</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// l2 小 ， curr指向l2</span></span><br><span class="line">                    curr.next = l2;</span><br><span class="line">                    l2 = l2.next;       <span class="comment">// l2向后走一位</span></span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.next;       <span class="comment">// curr后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 退出while循环之后,比较哪个链表剩下长度更长,直接拼接在排序链表末尾</span></span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span>) curr.next = l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">null</span>) curr.next = l1;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 最后返回合并后有序的链表</span></span><br><span class="line">            <span class="keyword">return</span> dummy.next; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>乘积最大子数组(152)：</p><p>方法一：暴力枚举</p><p>直接枚举每个位置开始的所有的乘积，注意只有一个数字的乘积也要参与比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//0 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; max) &#123;<span class="comment">//只有一个数也要与最大值比较一下</span></span><br><span class="line">            max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            temp = temp * nums[j];</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>我们可以根据当前位置的正负性进行分类讨论。</p><p>如果当前位置是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。</p><p>如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。</p><p>于是这里我们可以再维护一个它表示以第 i 个元素结尾的最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：</p><p><code>max[i]=max(max[i-1] * nums[i],nums[i],min[i-1] * nums[i])</code><br><code>min[i]=min(min[i-1] * nums[i],nums[i],max[i-1] * nums[i])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//    2 -3   2   -3</span></span><br><span class="line">    <span class="comment">//max 2 -3   2   36</span></span><br><span class="line">    <span class="comment">//min 2 -6  -12  -6</span></span><br><span class="line">    <span class="comment">//max[i]=max(max[i-1]*nums[i],nums[i],min[i-1]*nums[i])</span></span><br><span class="line">    <span class="comment">//min[i]=min(min[i-1]*nums[i],nums[i],max[i-1]*nums[i])</span></span><br><span class="line">    <span class="comment">//max[i]表示以元素nums[i]结尾的序列的乘积的最大值</span></span><br><span class="line">    <span class="type">int</span>[] max = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        max[i] = Math.max(Math.max(max[i - <span class="number">1</span>] * nums[i], nums[i]), min[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">        min[i] = Math.min(Math.min(min[i - <span class="number">1</span>] * nums[i], nums[i]), max[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果需要遍历以数组中每一个元素作为结尾的所有情况找出最大的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> max[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max[i] &gt; res) &#123;</span><br><span class="line">            res = max[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最小栈（155）：</p><p>用<strong>辅助栈</strong>来实现（第一次做这题真没想到这种做法）</p><p>要做出这道题目，首先要理解栈结构<strong>后进先出</strong>的性质。</p><p>对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。</p><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素（从栈顶到栈底）一定是 a, b, c, d。</p><p>那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。</p><p>我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p></li><li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p></li><li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);<span class="comment">//先放入最大值做为标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> min=minStack.peek();</span><br><span class="line">        minStack.push(Math.min(val, min));<span class="comment">//minStack中放入当前元素与栈顶元素较小的那个</span></span><br><span class="line">        stack.push(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();<span class="comment">//同时弹出</span></span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相交链表（160）：</p><p>方法一：HashSet</p><p>判断两个链表是否相交，可以使用哈希集合存储某一条链表的所有节点。</p><p>首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p><p>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。</p><p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="literal">null</span>) &#123;</span><br><span class="line">        hashSet.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashSet.contains(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：双指针</p><p>根据题目意思，如果两个链表相交，那么相交点之后的长度是相同的。</p><p>我们需要做的事情是，让<strong>两个链表从同距离末尾同等距离的位置开始遍历</strong>。为此，我们必须<strong>消除两个链表的长度差</strong>。有一个重要的前提是，如果让指针a遍历完A链表后再遍历B链表，让指针b遍历完B链表后再遍历A链表，这样两个指针最后一定会走过相同的距离，如果两个链表相交两个指针就一定会落在同一个结点。</p><p>下面是算法的具体步骤：</p><ul><li>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB</li><li>每步操作需要同时更新指针 pA 和 pB。</li><li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</li><li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li><li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</li></ul><p>下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。</p><p>情况一：两个链表相交</p><p>链表headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c&#x3D;m，b+c&#x3D;n。</p><p>如果 a&#x3D;b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；</p><p>如果 a !&#x3D; b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521220004531.png" alt="image-20220521220004531"></p><p>情况二：两个链表不相交</p><p>链表 headA 和 headB 的长度分别是 m 和 n。考虑当 m&#x3D;n 和 m!&#x3D;n  时，两个指针分别会如何移动：</p><p>如果 m&#x3D;n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值null，此时返回 null；</p><p>如果 m !&#x3D; n ，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 \pB 移动了 n+m 次之后，两个指针会同时指向链表末尾变成空值 null，此时返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    ListNode pa=headA,pb=headB;</span><br><span class="line">    <span class="keyword">while</span> (pa!=pb)&#123;</span><br><span class="line">        pa=pa==<span class="literal">null</span>?headB:pa.next;</span><br><span class="line">        pb=pb==<span class="literal">null</span>?headA:pb.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多数元素（169）：</p><p>方法一：哈希表</p><p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p><p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，找到出现次数大于n&#x2F;2的键即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> hashMap.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">        hashMap.put(num, cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry :</span><br><span class="line">         hashMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() &gt; nums.length / <span class="number">2</span>) &#123;</span><br><span class="line">            res = entry.getKey();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：排序</p><p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n&#x2F;2 的元素（下标从 0 开始）一定是众数。</p><p>算法</p><p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220521223252489-1662463137547119.png" alt="image-20220521223252489"></p><p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组上面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 n&#x2F;2 的地方有重叠。因此，无论众数是多少，返回 n&#x2F;2 下标对应的值都是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：<a href="https://leetcode.cn/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">Boyer-Moore 投票算法</a></p><p>注意看题解的评论，有指出官方题解错误的地方</p></li><li><p>打家劫舍（198）：</p><p>经典<strong>动态规划问题</strong>，可以好好领悟一下。</p><p>动态规划的的四个解题步骤是：</p><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li><li>空间优化（可选）</li></ul><p>步骤一：定义子问题<br>稍微接触过一点动态规划的朋友都知道动态规划有一个“子问题”的定义。什么是子问题？子问题是和原问题相似，但规模较小的问题。例如这道小偷问题，原问题是“从全部房子中能偷到的最大金额”，将问题的规模缩小，子问题就是“从 k 个房子中能偷到的最大金额”，用 f(k) 表示。</p><p>可以看到，子问题是参数化的，我们定义的子问题中有参数 k。假设一共有 n 个房子的话，就一共有 n 个子问题。动态规划实际上就是通过求这一堆子问题的解，来求出原问题的解。这要求子问题需要具备两个性质：</p><p>原问题要能由子问题表示。例如这道小偷问题中，k&#x3D;n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。<br>一个子问题的解要能通过其他子问题的解求出。例如这道小偷问题中，f(k) 可以由 f(k-1) 和 f(k-2) 求出，具体原理后面会解释。这个性质就是教科书中所说的“最优子结构”。如果定义不出这样的子问题，那么这道题实际上没法用动态规划解。<br>小偷问题由于比较简单，定义子问题实际上是很直观的。一些比较难的动态规划题目可能需要一些定义子问题的技巧。</p><p>步骤二：写出子问题的递推关系</p><p>这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步。在做题的时候，最好把这一步的思路用注释的形式写下来。做动态规划题目不要求快，而要确保无误。否则，写代码五分钟，找 bug 半小时，岂不美哉？</p><p>我们来分析一下这道小偷问题的递推关系：</p><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第k (k&gt;2) 间房屋，有两个选项：</p><ul><li><p>偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p></li><li><p>不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。</p></li></ul><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p><p>这时我们就可以写出状态转移方程了：<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code>，注意边界条件只有一间房屋和两间房屋的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">1</span>)&#123;<span class="comment">//特殊情况判断</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>岛屿数量(200)：</p><p>方法一：广度优先搜索</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，<strong>每个搜索到的 1 都会被重新标记为 0</strong>，这样就相当于把岛屿所联通的区域清除，表示已经搜索过了（标记为2是更好的做法，更能区分出这是已经遍历过的位置），不会干扰后面接着扫描二维网络。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//t=x*column+y,注意一下这里的写法，将二维的信息保存在一维中，</span></span><br><span class="line">    <span class="comment">//因为后面的y一定小于column，所以t%column可以正确求出y,t/column求出x</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                ArrayList&lt;Integer&gt; island = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                island.add(i * n + j);</span><br><span class="line">                <span class="keyword">while</span> (island.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> island.remove(<span class="number">0</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur / n, y = cur % n;</span><br><span class="line">                    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x + <span class="number">1</span> &lt; m &amp;&amp; grid[x + <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x + <span class="number">1</span>][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add((x + <span class="number">1</span>) * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x - <span class="number">1</span>][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x - <span class="number">1</span>][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add((x - <span class="number">1</span>) * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (y + <span class="number">1</span> &lt; n &amp;&amp; grid[x][y + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x][y + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add(x * n + y + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[x][y - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        grid[x][y - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        island.add(x * n + y - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：深度优先搜索</p><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0，表示已经搜索过了。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= grid.length || x &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || y &lt; <span class="number">0</span> || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(x + <span class="number">1</span>, y, grid);</span><br><span class="line">    dfs(x - <span class="number">1</span>, y, grid);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, grid);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>, grid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>翻转链表(206)：</p><p>简单题，可以复习一下链表，做链表题目的时候先画图，重点就是把图画出来按着图去做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur=head;</span><br><span class="line">    head=head.next;</span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode temp=head.next;</span><br><span class="line">        head.next=cur;</span><br><span class="line">        cur=head;</span><br><span class="line">        head=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>课程表(207)：</p><p>本题是一道经典的「拓扑排序」问题。</p><p>给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：</p><p>如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。</p><p>如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。</p><p>有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：</p><p>我们将每一门课看成一个节点；</p><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。</p><p>求出该图是否存在拓扑排序，就可以判断是否有一种符合要求的课程学习顺序</p><p>方法一：深度优先搜索</p><p><strong>思路</strong></p><p>我们可以将深度优先搜索的流程与<strong>拓扑排序</strong>(离散学过)的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p><strong>算法</strong></p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><p>「未搜索」：我们还没有搜索到这个节点；</p><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，也就是递归搜索的时候遇到了之前搜索过的点，所以存在环，因此是不存在拓扑排序的；</p><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)之前的拓扑关系，以及不用进行任何操作。</p><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储有向图，存的是每一个顶点可以到的所有其他顶点，这样来表示边</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line"><span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line"><span class="type">int</span>[] visited;</span><br><span class="line"><span class="comment">// 判断有向图中是否有环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prereq :</span><br><span class="line">         prerequisites) &#123;</span><br><span class="line">        <span class="comment">//要学0 先学1，所以存在从1到0的边，get(1).add(0)</span></span><br><span class="line">        edges.get(prereq[<span class="number">1</span>]).add(prereq[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">    <span class="comment">//先将u标记为搜索中</span></span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v :</span><br><span class="line">         edges.get(u)) &#123;</span><br><span class="line">        <span class="comment">// 如果「未搜索」那么搜索相邻节点v</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v]==<span class="number">0</span>) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="comment">//剪枝，搜v结点已经有环了，就不用在搜索和u相邻的其他顶点了</span></span><br><span class="line">            <span class="keyword">if</span> (!valid)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (visited[v]==<span class="number">1</span>)&#123;</span><br><span class="line">            valid=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//u的所有相邻顶点搜索完后，再将u标记为已完成</span></span><br><span class="line">    visited[u]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><p><strong>思路</strong></p><p>方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。</p><p>我们考虑拓扑排序中最前面的节点，<strong>该节点一定不会有任何入边，也就是它没有任何的先修课程要求</strong>。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着<strong>它的相邻节点少了一门先修课程的要求</strong>。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p><p>上面的想法类似于广度优先搜索，因此我们可以将广度优先搜索的流程与拓扑排序的求解联系起来。</p><p><strong>算法</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，他们没有先修课程的要求，可以直接学，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] info :</span><br><span class="line">         prerequisites) &#123;</span><br><span class="line">        <span class="comment">//从1出发指向0的边</span></span><br><span class="line">        edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中，意味着队列中的课可以先学不需要先修课程</span></span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v :</span><br><span class="line">             edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">//将u的相邻结点的入度减少一</span></span><br><span class="line">            indeg[v]--;</span><br><span class="line">            <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">            <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：深度优先搜索的时候做标记一定要先看到底有几种标记，想好每一种标记在什么时候打上，这和实际问题有关，但模板都差不多，这个题对图的这种存储方式很值得学习，用<code>List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();</code>存储边，edges.get(0)意味着拿到从顶点0出发可以到达的所有点的一个List</p></li><li><p>数组中的第k个最大元素(215)：</p><p>我直接排序后（升序）从后往前找出第k个就好了，想了解快速选择算法去看看<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">官方题解</a>，这题也可以用堆排序来做，建立大顶堆，做 k - 1 次删除堆顶的操作后堆顶元素就是我们要找的答案</p></li><li><p>会议室2：</p><p><img src="/2022/09/06/LeetCode-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20220620111447008.png" alt="image-20220620111447008"></p><p><strong>思路</strong>：</p><p>先对所有的会议安排按照开始时间升序排列。</p><p>安排第一个会议，此时一个会议室都没有，直接开放一间会议室使用；</p><p>安排第 i 个会议，查看当前有没有会议室是已开放且空闲的，没有则接着开放新的会议室；</p><p>查看是否有会议室已开放且空闲，是看当前正在使用会议室的会议中，<strong>最早结束的那场会议的结束时间</strong>，如果现在还没结束，说明其他会议更不可能结束，直接开放新的会议室。</p><p>若在已开放的会议室中，最早结束的那场会议已经结束，说明现在存在空闲会议室，直接加入即可。</p><p><strong>算法</strong></p><p>1、将最先开始的会议的结束时间加入小顶堆，最先开始的会议肯定要先进行</p><p>2、接着对 [1, size-1] 个会议依次进行操作：对比当前会议的开始时间和小顶堆的堆顶元素值，若小于，说明当前所有会议室正在进行的会议中，最早结束的都还没结束，只能新建会议室了，也就是将其加入小顶堆；</p><p>3、若当前会议的开始时间大于等于小顶堆的堆顶元素值，说明会议室正在进行的会议中，最早结束的会议已经结束，可以把它从小顶堆删除，自己进入小顶堆（重复利用会议室）。</p><p>4、等最后一个会议时间进入小顶堆，此时的小顶堆元素个数即至少需要的会议室数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1 - o2);<span class="comment">//小顶堆</span></span><br><span class="line">    Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);<span class="comment">//按照会议开始时间升序排列</span></span><br><span class="line">    <span class="comment">//将最早开始的会议的结束时间加入小顶堆，最早开始的会议肯定要先安排会议室</span></span><br><span class="line">    heap.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 小顶堆中堆顶始终是最早结束的会议的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前会议的开始时间大于等于前面已经开始的会议中最早结束的时间</span></span><br><span class="line">        <span class="comment">// 说明有会议室空闲出来了，可以直接重复利用</span></span><br><span class="line">        <span class="comment">// 把堆顶会议删除，当前的会议结束时间加入堆，意味着当前会议在进行</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= heap.peek()) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把当前会议的结束时间加入小顶堆</span></span><br><span class="line">        heap.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当所有会议遍历完毕，还在最小堆里面的，说明会议还没结束，此时的数量就是会议室的最少数量</span></span><br><span class="line">    <span class="keyword">return</span> heap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最大正方形：</p><p>方法一：暴力模拟</p><p>遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；</p><p>确定正方形的左上角后，根据<strong>左上角所在的行和列计算可能的最大正方形的边长</strong>（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；</p><p>每次在<strong>下方新增一行</strong>以及在<strong>右方新增一列</strong>，判断新增的行和列是否满足所有元素都是 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>, m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                maxSide = Math.max(maxSide, <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> Math.min(m - i, n - j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; curMax; k++) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//新增的一行一列的右下角那个特判</span></span><br><span class="line">                    <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; k; l++) &#123;</span><br><span class="line">                        <span class="comment">//判断新增的一行一列是不是都是1</span></span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + l] == <span class="string">&#x27;0&#x27;</span> </span><br><span class="line">                            || matrix[i + l][j + k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        maxSide = Math.max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：动态规划</p><p>可以使用动态规划降低时间复杂度。我们用 dp(i,j) 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dp 中的每个元素值呢？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 dp(i,j)&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p><code>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</code></p><p>此外，还需要考虑边界条件。如果 i 和 j 中至少有一个为 0，则以位置 (i,j) 为右下角的最大正方形的边长只能是 1，因此 dp(i,j)&#x3D;1。</p><p>该状态转移方程的推导可以看看<a href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/">官方题解</a>，看懂后该类正方形的问题应该都能明白</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, column = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][column];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除自身以外数组的乘积</p><p>方法一：左右乘积列表</p><p>思路</p><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><p>对于给定索引 i，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积。</p><p><code>left[i]=left[i-1]*nums[i-1]</code>, <code>right[i]=right[i+1]*nums[i+1]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//left[i]=left[i-1]*nums[i-1]</span></span><br><span class="line">    left[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        left[i]=left[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    right[nums.length-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length-<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        right[i]=right[i+<span class="number">1</span>]*nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i]=left[i]*right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法还可以优化空间，我们先把输出数组当作left数组，计算出left数组的值，然后<strong>从右向左遍历</strong>，动态的构造出right数组，只需要一个变量保存right当前的值就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans[i]=ans[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">        ans[i]=ans[i]*right;</span><br><span class="line">        <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">        right=right*nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>搜索二维矩阵2(240)：</p><p>方法一：每行进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] row :</span><br><span class="line">         matrix) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> search(row, target);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：z字形查找</p><p>我们可以从矩阵 matrix 的右上角 (0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)，那么我们希望在以 matrix 的左下角为左下角、以 (x,y) 为右上角的矩阵中进行搜索，即行的范围为 [x,m−1]，列的范围为 [0,y]：</p><p>小tips：matrix[x,y]始终保持在上述的搜索区域是一行最大，一列最小的元素</p><p>如果 matrix[x,y]&#x3D;target，说明搜索完成；</p><p>如果 matrix[x,y]&gt;target，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于<strong>第 y 列</strong>的元素都是严格大于 target 的，因此我们可以将它们全部忽略，即将 y 减少 1；</p><p>如果 matrix[x,y]&lt;target，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于<strong>第 x 行</strong>的元素都是严格小于 target 的，因此我们可以将它们全部忽略，即将 x 增加 1。</p><p>在搜索的过程中，如果我们超出了矩阵的边界，那么说明矩阵中不存在 target。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m=matrix.length,n=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=n-<span class="number">1</span>;<span class="comment">//矩阵的右上角，行最大的元素，列最小的元素</span></span><br><span class="line">    <span class="keyword">while</span> (x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (target&gt;matrix[x][y])&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&lt;matrix[x][y])&#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全平方数(279)：</p><p>方法一：动态规划</p><p>我们可以依据题目的要求写出状态表达式：f[i]表示最少需要多少个数的平方来表示整数 i。这些数必然落在区间 [1,sqrt(n)]。我们可以枚举这些数，假设当前枚举到 j，那么我们还需要取若干数的平方，构成 i-j^2 此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程 <code>dp[i]=min(dp[i],dp[i-j*j]+1),j从1枚举到sqrt(n)</code></p><p>边界条件，将dp[0]初始化为0，为了满足j*j恰好为n的情况</p><p>题目有个坑，不一定每次都取最大的平方数，结果就是用了最少的数字，比如41，如果取36，那么还需要5&#x3D;4+1，总共3个数字，但可以直接取41&#x3D;25+16总共2个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 1 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//将当前数字先更新为最大的结果，</span></span><br><span class="line">        <span class="comment">//即 dp[i]=i，比如 i=4，最坏结果为 4=1+1+1+1 即为 4 个数字</span></span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Trie（前缀树）：208题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，</span></span><br><span class="line"><span class="comment"> * 一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，</span></span><br><span class="line"><span class="comment"> * 同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。</span></span><br><span class="line"><span class="comment"> * @param word </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false，</span></span><br><span class="line"><span class="comment"> * 如果匹配到了最后一个字符，那我们只需判断 node-&gt;isEnd即可。</span></span><br><span class="line"><span class="comment"> * @param word</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和 search 操作类似，只是不需要判断最后一个字符结点的isEnd，</span></span><br><span class="line"><span class="comment"> * 因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。</span></span><br><span class="line"><span class="comment"> * @param prefix</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>通过以上介绍和代码实现我们可以总结出 Trie 的几点性质：</p><ul><li><p>Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。</p></li><li><p>查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L，和 Trie 中包含多少个单词无关。</p></li><li><p>Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)</p></li></ul><p>最后，关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。(慢慢领悟叭~~)</p></li></ol></li></ol><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC review</title>
      <link href="/2022/09/06/JDBC-review/"/>
      <url>/2022/09/06/JDBC-review/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1.数据库事务"></a>1.数据库事务</h2><h3 id="1-1什么是数据库事务"><a href="#1-1什么是数据库事务" class="headerlink" title="1.1什么是数据库事务"></a>1.1什么是数据库事务</h3><p>事务：一组逻辑操作单元（一个或多个DML操作），使数据从一种状态变换到另一种状态</p><h3 id="1-2哪些操作会导致数据自动提交"><a href="#1-2哪些操作会导致数据自动提交" class="headerlink" title="1.2哪些操作会导致数据自动提交"></a>1.2哪些操作会导致数据自动提交</h3><ul><li>DDL操作，<code>set autocommit=false</code>的方式对DDL无效</li><li>DML操作m默认情况下，一旦执行也会自动提交，可以通过<code>set autocommit=false</code>的方式取消DML操作的自动提交</li><li>默认在关闭连接时，会自动提交数据</li></ul><h2 id="2-DAO-data-base-access-object-数据访问对象"><a href="#2-DAO-data-base-access-object-数据访问对象" class="headerlink" title="2.DAO:data(base) access object(数据访问对象)"></a>2.DAO:data(base) access object(数据访问对象)</h2><h2 id="一些其他知识"><a href="#一些其他知识" class="headerlink" title="一些其他知识"></a>一些其他知识</h2><ol><li>url:uniform resource locator (统一资源定位符)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb教程</title>
      <link href="/2022/09/06/JavaWeb%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/06/JavaWeb%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JavaScript"><a href="#1-JavaScript" class="headerlink" title="1. JavaScript"></a>1. JavaScript</h1><h1 id="2-XML"><a href="#2-XML" class="headerlink" title="2. XML"></a>2. XML</h1><h2 id="2-1-XML的概念：可扩展的标记语言"><a href="#2-1-XML的概念：可扩展的标记语言" class="headerlink" title="2.1 XML的概念：可扩展的标记语言"></a>2.1 XML的概念：可扩展的标记语言</h2><h2 id="2-2-XML包含三个部分"><a href="#2-2-XML包含三个部分" class="headerlink" title="2.2 XML包含三个部分"></a>2.2 XML包含三个部分</h2><ul><li>XML声明，必须有而且声明这一行代码必须在XML文件的第一行</li><li>DTD(document type defination) 文档类型定义</li><li>XML正文</li></ul><h1 id="3-MVC"><a href="#3-MVC" class="headerlink" title="3. MVC"></a>3. MVC</h1><h2 id="3-1-MVC：Model（模型）、View（视图）、Controller（控制器）"><a href="#3-1-MVC：Model（模型）、View（视图）、Controller（控制器）" class="headerlink" title="3.1 MVC：Model（模型）、View（视图）、Controller（控制器）"></a>3.1 MVC：Model（模型）、View（视图）、Controller（控制器）</h2><ul><li><p>视图层：用于做数据展示以及用户交互的界面</p></li><li><p>控制层：能够接受客户端的请求，具体的业务功能需要借助于模型组件来完成</p></li><li><p>模型层：模型分为很多种，有比较简单的pojo&#x2F;vo(value object)（数据库的一条记录所对应的对象） ，有业务模型组件，有数据访问组件</p><ul><li>pojo&#x2F;vo：值对象</li><li>DAO：数据访问对象</li><li>BO(business object)：业务对象</li></ul></li><li><p>区分业务对象和数据访问对象</p><p>（1）DAO中的方法都是单精度方法或者细粒度方法，一个方法只考虑一个操作，比如添加就是insert操作，查询就是select操作等等。</p><p>（2）BO中的方法属于业务方法，而实际的业务是比较复杂的，因此业务方法的粒度比较粗</p><span id="more"></span></li></ul><h1 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4. IOC"></a>4. IOC</h1><h2 id="4-1-耦合-x2F-依赖"><a href="#4-1-耦合-x2F-依赖" class="headerlink" title="4.1 耦合&#x2F;依赖"></a>4.1 耦合&#x2F;依赖</h2><p>依赖指的是某某某离不开某某某，在软件系统中，层与层之间是存在依赖的，也称之为耦合，系统架构设计的原则是<strong>高内聚低耦合</strong>，层内部的组成应该是高度耦合的，而层与层之间的关系应该是低耦合的，最理想的情况是零耦合（就是没用耦合）</p><h2 id="4-2-IOC-控制反转-x2F-DI-依赖注入"><a href="#4-2-IOC-控制反转-x2F-DI-依赖注入" class="headerlink" title="4.2 IOC-控制反转&#x2F;DI-依赖注入"></a>4.2 IOC-控制反转&#x2F;DI-依赖注入</h2><h3 id="4-2-1-控制反转"><a href="#4-2-1-控制反转" class="headerlink" title="4.2.1 控制反转"></a>4.2.1 控制反转</h3><p>（1）之前在Servlet中，我们创建Service对象，<code>FruitService fruitService=new FruitServiceImpl();</code>，这句代码如果出现在Servlet中的某个方法内部，那么这个fruitService的作用域就是这个方法级别，如果这句话出现在Servlet类中（即作为成员变量），那么这个fruitService的作用域就是这个Servlet的实例级别。</p><p>（2）之后我们在applicationContext.xml中定义了这个fruitService，然后通过解析XML产生fruitService实例，存放在beanMap中，这个beanMap在一个BeanFactory中，因此我们改变了之前的Service实例，DAO实例等等的生命周期。也就意味着控制权从程序员转移到BeanFactory（BeanFactory又称为IOC容器）。这个现象我们称之为控制反转。</p><h3 id="4-2-2-依赖注入"><a href="#4-2-2-依赖注入" class="headerlink" title="4.2.2 依赖注入"></a>4.2.2 依赖注入</h3><p>（1）之前我们在控制层出现代码<code>FruitService fruitService=new FruitServiceImpl();</code>，那么，控制层和service层存在耦合。</p><p>（2）之后，我们将代码修改成<code>FruitService fruitService=null;</code>，然后在配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fruit.controller.FruitController&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fruitService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;fruitService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置文件表明FruitController需要fruitService，IOC容器在解析配置文件时，会去寻找Service实例，通过反射注入到Controller中，以前是程序员主动去获取绑定的，现在靠配置文件解析，容器帮我们注入。</p><h1 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. 过滤器</h1><p><strong>过滤器链</strong></p><ul><li>如果采取的是注解的方式配置过滤器，那么过滤器链的拦截顺序是按照全类名（字母）的先后顺序进行排序的。</li><li>如果采取xml的方式进行配置，那么按照配置的先后顺序进行排序</li></ul><h1 id="6-事务管理"><a href="#6-事务管理" class="headerlink" title="6. 事务管理"></a>6. 事务管理</h1><p>ThreadLocal称之为本地线程，用于同一个线程中的数据通信，我们可以通过set(obj)方法在当前线程上存储数据，通过get()方法在当前线程上获取数据</p><h1 id="7-监听器"><a href="#7-监听器" class="headerlink" title="7. 监听器"></a>7. 监听器</h1>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS Review</title>
      <link href="/2022/09/06/HTML-CSS-Review/"/>
      <url>/2022/09/06/HTML-CSS-Review/</url>
      
        <content type="html"><![CDATA[<h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h4><table><thead><tr><th align="center">标签</th><th align="center">标签</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">strong</td><td align="center">加粗</td></tr><tr><td align="center">u</td><td align="center">ins</td><td align="center">下划线</td></tr><tr><td align="center">i</td><td align="center">em</td><td align="center">倾斜</td></tr><tr><td align="center">s</td><td align="center">del</td><td align="center">删除线</td></tr></tbody></table><span id="more"></span><h4 id="HTML常用标签含义及其对应英文"><a href="#HTML常用标签含义及其对应英文" class="headerlink" title="HTML常用标签含义及其对应英文"></a>HTML常用标签含义及其对应英文</h4><table><thead><tr><th>标签</th><th>标签含义</th><th>英文</th><th>英文含义</th><th>备注</th></tr></thead><tbody><tr><td>h</td><td>标题</td><td>headline</td><td>标题</td><td></td></tr><tr><td>p</td><td>段落</td><td>paragraph</td><td>段落</td><td></td></tr><tr><td>hr</td><td>水平分割线</td><td>horizontal rules</td><td>水平分割线</td><td></td></tr><tr><td>b</td><td>加粗</td><td>bold</td><td>加粗&#x2F;粗体</td><td></td></tr><tr><td>strong</td><td>加粗(强调语义)</td><td>strong</td><td>强壮的</td><td></td></tr><tr><td>i</td><td>倾斜</td><td>incline</td><td>倾斜</td><td></td></tr><tr><td>em</td><td>倾斜(强调语义)</td><td>emphasize</td><td>强调</td><td>用倾斜来起到强调作用</td></tr><tr><td>u</td><td>下划线</td><td>underline</td><td>下划线</td><td></td></tr><tr><td>ins</td><td>下划线(强调语义)</td><td>insert</td><td>插入</td><td>ins标签准确来说是:插入字效果</td></tr><tr><td>s</td><td>删除线</td><td>strikethrough</td><td>删除线</td><td></td></tr><tr><td>del</td><td>删除线</td><td>delete</td><td>删除</td><td></td></tr><tr><td>br</td><td>回车换行</td><td>break</td><td>打破&#x2F;折断</td><td></td></tr><tr><td>img</td><td>插入图</td><td>image</td><td>图片</td><td></td></tr><tr><td>src</td><td>图片路径</td><td>source</td><td>源头</td><td>img标签的属性</td></tr><tr><td>width</td><td>宽度</td><td>width</td><td>宽度</td><td>标签属性</td></tr><tr><td>height</td><td>高度</td><td>height</td><td>高度</td><td>标签属性</td></tr><tr><td>title</td><td>提示内容</td><td>title</td><td>标题</td><td>img标签的属性</td></tr><tr><td>alt</td><td>替换的内容</td><td>alternative</td><td>替换&#x2F;交替</td><td>img标签属性</td></tr><tr><td>border</td><td>边框线</td><td>border</td><td>边界</td><td>标签属性</td></tr><tr><td>a</td><td>超链接</td><td>anchor [‘æŋkə]</td><td>锚点</td><td></td></tr><tr><td>href</td><td>超链接地址</td><td>hypertext reference</td><td>超链接</td><td>a标签的属性</td></tr><tr><td>target</td><td>超链接在哪个窗口打开</td><td>target</td><td>目标</td><td>a标签的属性</td></tr><tr><td>_blank</td><td>新窗口</td><td>blank</td><td>空白</td><td>target属性值</td></tr><tr><td>_self</td><td>当前窗口</td><td>self</td><td>自己</td><td>target属性值</td></tr><tr><td></td><td>空格符</td><td>non-breaking space</td><td>不间断空格</td><td></td></tr><tr><td>ul</td><td>无序列表</td><td>unorder list</td><td>无序列表</td><td></td></tr><tr><td>li</td><td>列表项</td><td>list item</td><td>列表条目</td><td></td></tr><tr><td>ol</td><td>有序列表</td><td>order list</td><td>有序列表</td><td></td></tr><tr><td>dl</td><td>自定义列表</td><td>defined list</td><td>自定义列表</td><td></td></tr><tr><td>dt</td><td>自定义列表标题</td><td>defined title</td><td>自定义标题</td><td></td></tr><tr><td>dd</td><td>自定义列表详情</td><td>defined detail</td><td>自定义详情</td><td></td></tr><tr><td>table</td><td>表格</td><td>table</td><td>表格</td><td></td></tr><tr><td>tr</td><td>行</td><td>table row</td><td>表格行</td><td></td></tr><tr><td>td</td><td>单元格</td><td>table data</td><td>表格数据单元格</td><td></td></tr><tr><td>radio</td><td>单选按钮</td><td>radio</td><td>收音机</td><td>收音机的按钮只能按下一个(单选)</td></tr><tr><td>rows</td><td>行数</td><td>rows</td><td>行的复数</td><td>textarea属性</td></tr><tr><td>cols</td><td>列数</td><td>columns</td><td>列的复数</td><td>textarea属性</td></tr><tr><td>get</td><td>get请求方式</td><td>get</td><td>获取</td><td></td></tr><tr><td>post</td><td>post请求方式</td><td>post</td><td>提交</td><td></td></tr><tr><td>css</td><td>层叠样式表(样式)</td><td>Cascading Style Sheet</td><td>层叠样式表</td><td></td></tr><tr><td>font-family</td><td>字体</td><td>font-family</td><td>字体族&#x2F;字体类型</td><td></td></tr><tr><td>text-align</td><td>内容对齐</td><td>text-align</td><td>文字对齐</td><td></td></tr><tr><td>text-indent</td><td>文字首行缩进</td><td>text-indent</td><td>文字缩进</td><td></td></tr><tr><td>background</td><td>背景</td><td>background</td><td>背景</td><td>笔记中记录background为背景色,其实准确来说是背景.这个属性除了可以设置背景颜色,还可以设置背景图片等.</td></tr><tr><td>display</td><td>显示模式</td><td>display</td><td>显示</td><td></td></tr><tr><td>block</td><td>块级</td><td>block</td><td>块</td><td></td></tr><tr><td>inline</td><td>行内</td><td>inline</td><td>内联的</td><td>这里可以这样理解:line是行,in是在…里边.inline就是在行里边(行内)</td></tr><tr><td>none</td><td>隐藏</td><td>none</td><td>没有&#x2F;消失</td><td>display属性值:none可以理解为消失(不占位置隐藏)</td></tr><tr><td>visibility</td><td>显示</td><td>visibility</td><td>能见度</td><td></td></tr><tr><td>hidden</td><td>隐藏</td><td>hidden</td><td>隐藏</td><td>占位置隐藏(隐身)</td></tr><tr><td>class</td><td>类样式</td><td>class</td><td>类</td><td></td></tr><tr><td>style</td><td>行内样式</td><td>style</td><td>风格&#x2F;设计</td><td></td></tr><tr><td>link</td><td>外链式</td><td>link</td><td>关系&#x2F;连接</td><td></td></tr><tr><td>rel</td><td>关系</td><td>relationship</td><td>关系&#x2F;关联</td><td></td></tr><tr><td>stylesheet</td><td>样式单</td><td>stylesheet</td><td>样式  床单</td><td></td></tr><tr><td>important</td><td>提权功能(变为最重要)</td><td>important</td><td>重要</td><td></td></tr><tr><td>italic</td><td>倾斜</td><td>italic</td><td>斜体字</td><td>font-style属性值</td></tr><tr><td>normal</td><td>正常</td><td>normal</td><td>正常</td><td>font-style属性值</td></tr><tr><td>text-decoration</td><td>文字修饰属性</td><td>decoration</td><td>修饰&#x2F;装饰</td><td></td></tr><tr><td>overline</td><td>顶划线</td><td>overline</td><td>上划线</td><td>text-decoration属性值</td></tr><tr><td>line-through</td><td>删除线&#x2F;贯穿线</td><td>through</td><td>穿过</td><td>text-decoration属性值</td></tr><tr><td>word-break</td><td>强制打散单词换行</td><td>beak</td><td>折断</td><td></td></tr><tr><td>visited</td><td>访问后</td><td>visited</td><td>访问后</td><td>超链接伪类</td></tr><tr><td>hover</td><td>鼠标以上</td><td>hover</td><td>悬浮&#x2F;盘旋</td><td>超链接伪类</td></tr><tr><td>active</td><td>点击状态</td><td>active</td><td>激活&#x2F;积极</td><td>超链接伪类</td></tr><tr><td>solid</td><td>实线</td><td>solid</td><td>固体的</td><td>border边框线条样式</td></tr><tr><td>dashed</td><td>虚线</td><td>dashed</td><td>虚线</td><td>border边框线条样式</td></tr><tr><td>repeat</td><td>平铺</td><td>repeat</td><td>重复</td><td>background属性值</td></tr><tr><td>fixed</td><td>背景图固定</td><td>fixed</td><td>固定的</td><td>background属性值</td></tr><tr><td>margin</td><td>外边距</td><td>margin</td><td>边缘</td><td>边缘可以理解为盒子外边的距离(盒子与盒子之间的距离)</td></tr><tr><td>padding</td><td>内边距</td><td>padding</td><td>填补&#x2F;填充</td><td>填充意味着属于盒子内部的距离</td></tr><tr><td>auto</td><td>自动(自适应宽高)</td><td>auto</td><td>自动</td><td>margin&#x2F;padding取值</td></tr><tr><td>list-style</td><td>列表样式</td><td>list,style</td><td>列表,样式</td><td></td></tr><tr><td>overflow</td><td>溢出</td><td>overflow</td><td>溢出</td><td></td></tr><tr><td>hidden</td><td>隐藏</td><td>hidden</td><td>隐藏</td><td>overflow属性值(visibility属性值)</td></tr><tr><td>float</td><td>浮动</td><td>float</td><td>浮动</td><td></td></tr><tr><td>position</td><td>定位</td><td>position</td><td>位置</td><td></td></tr><tr><td>relative</td><td>相对定位</td><td>relative</td><td>相对</td><td>position的属性值</td></tr><tr><td>static</td><td>静态定位</td><td>static</td><td>静态的</td><td></td></tr><tr><td>absolute</td><td>绝对定位</td><td>absolute</td><td>绝对的</td><td></td></tr><tr><td>cursor</td><td>鼠标样式</td><td>cursor</td><td>光标</td><td></td></tr><tr><td>pointer</td><td>小手</td><td>pointer</td><td>指针</td><td></td></tr><tr><td>border-radius</td><td>边框半径(制作圆角矩形)</td><td>radius</td><td>半径</td><td></td></tr><tr><td>filter</td><td>滤镜</td><td>filter</td><td>过滤器</td><td></td></tr><tr><td>alpha</td><td>透明度</td><td>alpha</td><td>透明度</td><td></td></tr><tr><td>opacity</td><td>透明度</td><td>opacity</td><td>不透明度</td><td>虽然翻译是不透明度,但是css中还是当做透明度处理了</td></tr><tr><td>css sprite</td><td>css精灵图</td><td>sprite</td><td>精灵&#x2F;雪碧</td><td></td></tr><tr><td>background-attachment</td><td>背景图固定</td><td>attachment</td><td>附着</td><td></td></tr><tr><td>wrap</td><td>包裹</td><td>wrap</td><td>包裹</td><td></td></tr><tr><td>banner</td><td>广告条</td><td>banner</td><td>标语&#x2F;横幅广告</td><td></td></tr><tr><td>prefect</td><td>完美</td><td>prefect</td><td>完美</td><td></td></tr><tr><td>course</td><td>课程体系</td><td>course</td><td>课程</td><td></td></tr><tr><td>pilot</td><td>领航者</td><td>pilot</td><td>飞行员&#x2F;领航者</td><td></td></tr><tr><td>vertical-align</td><td>垂直对齐方式</td><td>vertical</td><td>垂直的</td><td></td></tr></tbody></table><h4 id="标签嵌套"><a href="#标签嵌套" class="headerlink" title="标签嵌套"></a>标签嵌套</h4><p>p和h不能相互嵌套，p里面不能包含div，a标签内可以嵌套任意元素，但a不能嵌套a</p><h4 id="CSS书写顺序-这样写浏览器的执行效率更高"><a href="#CSS书写顺序-这样写浏览器的执行效率更高" class="headerlink" title="CSS书写顺序(这样写浏览器的执行效率更高)"></a>CSS书写顺序(这样写浏览器的执行效率更高)</h4><ol><li>浮动&#x2F;display&#x2F;定位</li><li>盒子模型:margin, border, padding, 宽度高度背景色</li><li>文字样式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程</title>
      <link href="/2022/09/06/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/06/Git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><h2 id="1-一些常用的git命令"><a href="#1-一些常用的git命令" class="headerlink" title="1. 一些常用的git命令"></a>1. 一些常用的git命令</h2><p><img src="/2022/09/06/Git%E6%95%99%E7%A8%8B/image-20220505162534378.png" alt="image-20220505162534378"></p><ul><li>ctrl+L清空屏幕（输入clear然后回车也可以）</li><li>git reflog 查看版本信息</li><li>git log 查看版本详细信息</li></ul><p><img src="/2022/09/06/Git%E6%95%99%E7%A8%8B/image-20220505171148921.png" alt="image-20220505171148921"></p><p>下面是一个很好用的查看提交记录的命令，可以可视化的查看commit和merge</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=format:&#x27;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%</span><br><span class="line">d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span><br></pre></td></tr></table></figure><h2 id="2-廖雪峰的git教程"><a href="#2-廖雪峰的git教程" class="headerlink" title="2. 廖雪峰的git教程"></a>2. 廖雪峰的git教程</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作git - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><img src="/2022/09/06/Git%E6%95%99%E7%A8%8B/image-20221101100754052.png" alt="image-20221101100754052"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discrete Math</title>
      <link href="/2022/09/06/Discrete-Math/"/>
      <url>/2022/09/06/Discrete-Math/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS（广度优先搜索）"><a href="#BFS（广度优先搜索）" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h1><p>我们采用示例图来说明这个过程，在搜索的过程中，初始所有节点是白色（代表了所有点都还没开始搜索），把起点V0标志成灰色（表示即将辐射V0），下一步搜索的时候，我们把所有的灰色节点访问一次，然后将其变成黑色（表示已经被辐射过了），进而再将他们所能到达的节点标志成灰色（因为那些节点是下一步搜索的目标点了），但是这里有个判断，就像刚刚的例子，当访问到V1节点的时候，它的下一个节点应该是V0和V4，但是V0已经在前面被染成黑色了，所以不会将它染灰色。这样持续下去，直到目标节点V6被染灰色，说明了下一步就到终点了，没必要再搜索（染色）其他节点了，此时可以结束搜索了，整个搜索就结束了。然后根据搜索过程，反过来把最短路径找出来，下图中把最终路径上的节点标志成绿色。</p><span id="more"></span><p><img src="/2022/09/06/Discrete-Math/image-20220317231004623.png" alt="image-20220317231004623"></p><p><img src="/2022/09/06/Discrete-Math/image-20220317231029925.png" alt="image-20220317231029925"></p><p><img src="/2022/09/06/Discrete-Math/1335725885_9403.png" alt="1335725885_9403"></p><p>为了便于进行搜索，要设置一个表存储所有的结点。由于在广度优先搜索算法中，要满足先生成的结点先扩展的原则，所以存储结点的表一般采用队列这种数据结构。</p><p>在编写程序时，可用数组q模拟队列。front和rear分别表示队头指针和队尾指针，初始时front&#x3D;rear&#x3D;0。</p><p>元素x入队操作为 q[rear++]&#x3D;x;</p><p>元素x出队操作为 x &#x3D;q[front++];</p><p> 广度优先搜索算法的搜索步骤一般是：</p><p>   （1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。</p><p>   （2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。</p><p>  （3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。</p><p>最终可能产生两种结果：找到目标结点，或扩展完所有结点而没有找到目标结点。</p><p>对于广度优先搜索算法来说，问题不同则状态结点的结构和结点扩展规则是不同的，但搜索的策略是相同的。广度优先搜索算法的框架一般如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  BFS（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    队列初始化；</span><br><span class="line"></span><br><span class="line">    初始结点入队；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> （队列非空）</span><br><span class="line"></span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">          队头元素出队，赋给current；</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>  （current 还可以扩展）</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">              由结点current扩展出新结点new；</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>  （new 重复于已有的结点状态） <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">              new结点入队；</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>  (new结点是目标状态)</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                    置flag= <span class="literal">true</span>;    <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS（深度优先搜索）"><a href="#DFS（深度优先搜索）" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h1><p>深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。下面是dfs的框架代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS核心伪代码</span></span><br><span class="line"><span class="comment"> * 前置条件是visit数组全部设置成false</span></span><br><span class="line"><span class="comment"> * @param n 当前开始搜索的节点</span></span><br><span class="line"><span class="comment"> * @param d 当前到达的深度，也即是路径长度</span></span><br><span class="line"><span class="comment"> * @return 是否有解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DFS</span><span class="params">(Node n, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">4</span>)&#123;<span class="comment">//路径长度为返回true，表示此次搜索有解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node nextNode in n)&#123;<span class="comment">//遍历跟节点n相邻的节点nextNode，这里体现了回溯</span></span><br><span class="line">        <span class="keyword">if</span> (!visit[nextNode])&#123;<span class="comment">//未访问过的节点才能继续搜索</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//例如搜索到V1了，那么V1要设置成已访问</span></span><br><span class="line">            visit[nextNode] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来要从V1开始继续访问了，路径长度当然要加</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DFS(nextNode, d+<span class="number">1</span>))&#123;<span class="comment">//如果搜索出有解</span></span><br><span class="line">                <span class="comment">//例如到了V6，找到解了，你必须一层一层递归的告诉上层已经找到解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新设置成未访问，因为它有可能出现在下一次搜索的别的路径中</span></span><br><span class="line">            visit[nextNode] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里，发现本次搜索还没找到解，那就要从当前节点的下一个节点开始搜索。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//本次搜索无解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再贴一段DFS的伪码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int check(参数)</span><br><span class="line">&#123;</span><br><span class="line">    if(满足条件)</span><br><span class="line">        return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void dfs(int step)</span><br><span class="line">&#123;</span><br><span class="line">        判断边界</span><br><span class="line">        &#123;</span><br><span class="line">            相应操作</span><br><span class="line">        &#125;</span><br><span class="line">        尝试每一种可能，会用到for循环</span><br><span class="line">        &#123;</span><br><span class="line">               满足check条件</span><br><span class="line">               标记</span><br><span class="line">               继续下一步dfs(step+1)</span><br><span class="line">               恢复初始状态（回溯的时候要用到）</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>深度与广度的比较</strong></p><p>我们假设一个节点衍生出来的相邻节点平均的个数是N个，那么当起点开始搜索的时候，队列有一个节点，当起点拿出来后，把它相邻的节点放进去，那么队列就有N个节点，当下一层的搜索中再加入元素到队列的时候，节点数达到了N^2，你可以想想，一旦N是一个比较大的数的时候，这个树的层次又比较深，那这个队列就得需要很大的内存空间了。</p><p>于是广度优先搜索的缺点出来了：在<strong>树的层次较深并且子节点数较多</strong>的情况下，消耗内存十分严重。广度优先搜索适用于节点的子节点数量不多，并且树的层次不会太深的情况。</p><p>那么深度优先就可以克服这个缺点，因为每次搜的过程，每一层只需维护一个节点。但回过头想想，广度优先能够找到最短路径，那深度优先能否找到呢？深度优先的方法是一条路走到黑，那显然无法知道这条路是不是最短的，所以你还得继续走别的路去判断是否是最短路？</p><p>于是深度优先搜索的缺点也出来了：难以寻找最优解，仅仅只能寻找有解。其优点就是内存消耗小，克服了刚刚说的广度优先搜索的缺点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ review</title>
      <link href="/2022/09/06/c-review/"/>
      <url>/2022/09/06/c-review/</url>
      
        <content type="html"><![CDATA[<h1 id="Accelerated-c"><a href="#Accelerated-c" class="headerlink" title="Accelerated c++"></a>Accelerated c++</h1><h2 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h2><ol><li><p><code>&gt;&gt;</code>运算符从标准输入读进一个字符串，它会首先略去输入开始碰到的空白字符（空白、制表符、回退键和换行符），然后连续的读入字符到某个变量中，直到遇到了另一个空白字符或文件结束标记为止</p></li><li><p>c++的数据结构可以用struct实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">studentInfo</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">double</span> midterm;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>随机访问：s[2],s[5],这样随机的数字进行访问就是随机访问，顺序访问就是从第一个元素开始，按照既定顺序一个一个遍历到结尾</p></li><li><p>半开[i,j)区间的元素个数是j-i，[i,j]闭区间的元素个数是j-i+1</p></li></ol><span id="more"></span><ol><li><p>反向迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v&#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;::reverse_iterator rtr;</span><br><span class="line">    <span class="keyword">for</span>(rtr=v.<span class="built_in">rbegin</span>();rtr!=v.<span class="built_in">rend</span>();rtr++)</span><br><span class="line">        std::cout&lt;&lt; *rtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avaj</span><br></pre></td></tr></table></figure></li><li><p>如果我们在类的内部定义了一个成员函数，就是请求把对这个函数的调用扩展成内联子过程，这样就避免了函数调用额外的开销。如果成员函数是在类的外部定义的，那么我们必须在这个函数的函数名中指明他是来自类作用域的：<code>&quot;class-name::membername&quot;</code></p></li><li><p>如果在第一个保护标识符之前有成员，class中的成员是私有的（private），struct中的成员是共有的（public）</p></li></ol><h1 id="C-Primer"><a href="#C-Primer" class="headerlink" title="C++ Primer"></a>C++ Primer</h1><blockquote><p>Part1也就是前七章，除了6.6，6.7节，都要通读。尤其是第三章初步介绍了vector和string，简直就是新手福音，搞定这两个容器就能写一些简单的程序。<br>Part2基本就是数据结构和算法，如果有基础读起来很轻松。<br>9，11两章介绍的容器，以及12.1节的智能指针要通读。多用智能指针和容器，远离segment fault. 第10章里的泛型算法可以慢慢读，读完以后可以写出高逼格的函数式风格C++。12.2节讲了怎么用new和delete分配空间，题主作为新手，知道这种写法就行，写程序时尽量用容器代替原始数组，尤其是代码里最好不要有delete。<br>Part3是块硬骨头，标题就是Tools for Class Authors. 作为一个”class user”，有些部分第一次是可以略过的。<br>13章很重要，要细读。初始化，复制，赋值，右值引用是C++里很微妙很重要的部分，别的语言对于这些概念很少有区分得这么细的。这一章不但要精读，还要完全掌握。<br>14章的操作符重载第一次可以观其大略；14.9节第一次可以跳过。<br>15章讲OOP，重要性不言而喻。如果之前一点概念都没有，学起来会觉得比较抽象。网上关于OOP有很多通俗有趣的文章，可以一起看看。<br>16章讲泛型编程，第一次读16.1节，掌握最基本的函数模板和类模板就行了。<br>Part4就更高档了，很多内容第一次就算啃下来，长久不用又忘了。第一次读推荐把18.2节读懂，命名空间简单易用效果好。别的内容可以观其大略，用时再看。17.1节的tuple是个有趣的东东，可以读一读。17.3节的正则表达式和17.4节的随机数也许有用，也可以读一读。如果需要读写文件，要读一下17.5.2节的raw I&#x2F;O和17.5.3节的random I&#x2F;O。</p><p>最后给题主的建议是，写C++，要尽量避免C的写法。用static_cast而不是括号转换符；用vector而不是C里面的数组；用string而不是char *；用智能指针而不是原始指针。当然I&#x2F;O是个例外，printf()还是比cout好用的；转换数字和字符串时sprintf()也比stringstream快</p></blockquote><ol><li><p>如果想声明一个变量而非定义它，就在变量名前加关键字extern，定义与声明的区别：定义申请存储空间，也可能会为变量赋一个初始值</p></li><li><p>头文件不应该包含using声明</p></li><li><p><strong>顶层const</strong>表示指针本身是个常量，<strong>底层const</strong>表示指针所指对象是个常量</p></li><li><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内</p></li><li><p>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值</p></li><li><p>将只有一个参数的构造函数声明为explicit可以抑制构造函数定义的隐式转换，只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复</p></li><li><p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义和其他非内联函数的定义放在同一个文件中</p></li><li><p>lambda表达式</p><p><img src="/2022/09/06/c-review/image-20220715200844207.png" alt="image-20220715200844207"></p></li><li><p>11.4节的hasher函数<code>hash&lt;string&gt;()(sd.isbn());</code>hash<string>()生成了可调用对象,然后该可调用对象(可以看作是函数)作用在sd.isbn()上</p></li><li><p>返回const和非const的函数重载，是因为调用函数时隐式的传递了this指针</p></li><li><p><img src="/2022/09/06/c-review/image-20220716144342905.png" alt="image-20220716144342905"></p></li><li><p>用new分配数组时值初始化和默认初始化,默认情况下动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化.也可以对动态分配的对象进行值初始化,只需在类型名之后跟一对空括号即可</p></li><li><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p></li><li><p>一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符.一旦一个类需要一个拷贝构造函数,它一定也需要一个拷贝复制运算符,但不一定需要析构函数</p></li><li><p>拷贝赋值运算符应该返回一个指向其左侧运算对象的引用,即在赋值函数中<code>return *this</code></p></li><li><p>通常情况下，不应该重载逗号、取地址、逻辑与、和逻辑或运算符</p></li><li><p>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做，这两类运算符都应该返回左侧运算对象的引用</p></li><li><p>如果类定义了调用运算符，则该类的对象称作函数对象，因为可以调用这种对象，所以我们说这些对象的行为像函数一样</p></li><li><p>赋值（包括复合赋值）、下标、函数调用和箭头运算符必须作为类的成员</p></li><li><p>在c++中，当我们使用<strong>基类的引用或指针</strong>调用一个<strong>虚函数</strong>时将发生<strong>动态绑定</strong>（又称作运行时绑定）</p></li><li><p>派生类构造函数只初始化它的直接基类</p></li><li><p>派生列表中用到的访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见</p></li><li><p>explicit关键字：指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化</p></li><li><p>必须使用初始化列表的时候：</p><p>（1）常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面<br>（2）引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</p><p>（3）没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</p><p>下图解释了拷贝构造函数</p><p><img src="/2022/09/06/c-review/image-20220907104527530.png" alt="image-20220907104527530"></p></li></ol><p><img src="/2022/09/06/c-review/image-20221028221748699.png" alt="image-20221028221748699"></p><ol start="25"><li>构造函数的调用：</li></ol><p><img src="/2022/09/06/c-review/image-20220907115924242.png" alt="image-20220907115924242"></p><ol start="26"><li><p>一个左值是一个标识非临时性对象的表达式。一个右值是一个标识临时性对象的表达式，或者一个不与任何对象相联系的值（如字面值常数），一般的法则是，如果程序中有一个变量名，那么他就是一个左值。在所有情况下函数调用的结果都是右值。</p></li><li><p>当一个类包含指针作为数据成员时，一般我们必须自己实现析构函数，拷贝赋值函数和拷贝构造函数</p><p><img src="/2022/09/06/c-review/image-20220907150933740.png" alt="image-20220907150933740"></p></li></ol><h1 id="B站C-视频课程"><a href="#B站C-视频课程" class="headerlink" title="B站C++视频课程"></a>B站C++视频课程</h1><h2 id="1-引用"><a href="#1-引用" class="headerlink" title="1. 引用"></a>1. 引用</h2><h3 id="1-1-引用的本质"><a href="#1-1-引用的本质" class="headerlink" title="1.1 引用的本质"></a>1.1 引用的本质</h3><p>给变量取个别名。定义引用时必须初始化，因为系统不会为引用开辟空间，引用和原变量代表同一内存空间。c语言角度看底层用常量指针实现（用c++不要关心这件事）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line"><span class="comment">//底层实际发生的是</span></span><br><span class="line"><span class="comment">//int * const b=&amp;a;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-引用赋值问题"><a href="#1-2-引用赋值问题" class="headerlink" title="1.2 引用赋值问题"></a>1.2 引用赋值问题</h3><p><img src="/2022/09/06/c-review/image-20220914141348979.png" alt="image-20220914141348979"></p><h3 id="1-3-函数返回值为引用"><a href="#1-3-函数返回值为引用" class="headerlink" title="1.3 函数返回值为引用"></a>1.3 函数返回值为引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function1</span><span class="params">(<span class="type">int</span> &amp; aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">function2</span><span class="params">(<span class="type">int</span> &amp; aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    b = <span class="built_in">function1</span>(a);<span class="comment">//function1()的返回值先储存在一个临时变量中，</span></span><br><span class="line">                     <span class="comment">//然后再把临时变量赋值给b</span></span><br><span class="line">    <span class="built_in">function1</span>(a) = <span class="number">20</span>;<span class="comment">//不OK function1()的返回值为临时变量，不能赋值</span></span><br><span class="line">    <span class="built_in">function2</span>(a) = <span class="number">20</span>;<span class="comment">//OK  此时a的值变成了20，返回的是左值引用可以出现在等号左边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：若函数的返回值为引用(&amp;)，则编译器就不为返回值创建临时变量了。直接返回那个变量的引用。所以千万不要返回临时变量的引用，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> b;<span class="comment">//不OK 等函数返回后，b就消失了，引用了一个消失的东西</span></span><br><span class="line">             <span class="comment">//程序会懵逼的。指针也一样。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="built_in">function</span>();<span class="comment">//function()返回的东西已经消失了，引用也就不存在了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/c-review/image-20220914142131245.png" alt="image-20220914142131245"></p><h2 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. 内联函数</h2><p><img src="/2022/09/06/c-review/image-20220913134523934.png" alt="image-20220913134523934"></p><p>在<strong>编译阶段</strong>将内联函数中的函数体替换函数调用处，避免函数调用时的开销（入栈出栈）。必须在定义时使用关键字inline修饰，不能在声明的时候使用inline</p><h2 id="3-缺省参数"><a href="#3-缺省参数" class="headerlink" title="3. 缺省参数"></a>3. 缺省参数</h2><p>建议在函数声明处给默认值。</p><h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. 构造函数</h2><p>调用构造函数的几种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式调用无参构造（推荐）</span></span><br><span class="line">Data ob1;</span><br><span class="line"><span class="comment">//显示调用有参构造</span></span><br><span class="line">Data ob2=<span class="built_in">Data</span>()</span><br><span class="line"><span class="comment">//隐式调用有参构造（推荐）</span></span><br><span class="line">Data <span class="built_in">ob3</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//显示调用有参构造</span></span><br><span class="line">Data ob4=<span class="built_in">Data</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//构造函数的隐式转换（前提：类中只有一个数据成员）</span></span><br><span class="line">Data ob5=<span class="number">30</span>;<span class="comment">//Data ob5(30)</span></span><br></pre></td></tr></table></figure><h2 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h2><ul><li><p>如果类有指针成员必须实现析构函数，释放指针成员所指向的内存空间。</p></li><li><p>同一级别先构造的后释放（符合栈的特点）</p></li></ul><h2 id="6-拷贝构造函数"><a href="#6-拷贝构造函数" class="headerlink" title="6. 拷贝构造函数"></a>6. 拷贝构造函数</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>本质是构造函数，只有在旧对象初始化新对象（定义时的对象是新对象，定义完以后就变成了旧对象）时才会调用拷贝构造。函数调用时给形参（此时的形参是普通对象，不是引用）开辟空间，会调用拷贝构造函数用实参初始化形参。</p><h3 id="6-2-需要自己实现的情况"><a href="#6-2-需要自己实现的情况" class="headerlink" title="6.2 需要自己实现的情况"></a>6.2 需要自己实现的情况</h3><p>如果类中没有指针成员，不用实现拷贝构造（浅拷贝）和析构函数；如果类中有指针成员，必须实现拷贝构造（深拷贝）和析构函数（释放指针成员指向的堆区空间）</p><h3 id="6-3-拷贝构造的几种调用形式"><a href="#6-3-拷贝构造的几种调用形式" class="headerlink" title="6.3 拷贝构造的几种调用形式"></a>6.3 拷贝构造的几种调用形式</h3><ul><li>旧对象给新对象初始化，调用拷贝构造</li><li>给对象取别名，不会调用拷贝构造</li><li>普通对象作为函数参数，调用函数时，会发生拷贝构造</li></ul><h2 id="7-初始化列表"><a href="#7-初始化列表" class="headerlink" title="7. 初始化列表"></a>7. 初始化列表</h2><ul><li><p>成员对象：一个类的对象作为另一个类的成员。</p></li><li><p>类会自动调用成员对象的无参构造函数，如果类中想调用成员对象的有参构造函数，必须使用初始化列表。</p></li><li><p>对象的初始化和析构顺序：先初始化类中的成员对象（先把内部建好才能建外部），然后再初始化该对象；析构顺序正好相反（先拆外部才能拆内部），先析构该对象，再析构成员对象。</p></li><li><p>对象数组的初始化：必须显示使用有参构造，逐个元素初始化。若不显示初始化，则会对每个元素默认调用无参构造函数</p></li></ul><h2 id="8-类的存储结构"><a href="#8-类的存储结构" class="headerlink" title="8. 类的存储结构"></a>8. 类的存储结构</h2><p>成员函数、静态成员是独立存储，所有对象共享的，对象独有的只有成员数据</p><h2 id="9-this指针"><a href="#9-this指针" class="headerlink" title="9. this指针"></a>9. this指针</h2><h2 id="10-类中有指针成员"><a href="#10-类中有指针成员" class="headerlink" title="10. 类中有指针成员"></a>10. 类中有指针成员</h2><p>如果有指针成员，必须自己写拷贝构造函数、赋值运算符函数、析构函数</p><h2 id="11-重载箭头运算符"><a href="#11-重载箭头运算符" class="headerlink" title="11. 重载箭头运算符"></a>11. 重载箭头运算符</h2><p>箭头操作符(-&gt;)的内置用法是，使用一个类对象的指针来调用所指对象的成员。左操作数为对象指针，右操作数为该对象的成员。</p><p>定义重载箭头操作符之后看起来就有点特别，既可用类对象的指针来调用，也可用类对象直接调用。<br>重载箭头操作符，首先重载箭头操作符必须定义为类成员函数。</p><p>箭头操作符与众不同。它其实是一元操作符，却表现得像二元操作符一样：接受一个对象和一个成员名。对对象解引用以获取成员。不管外表如何，箭头操作符不接受显式形参。</p><p>这里没有第二个形参，因为 -&gt; 的右操作数不是表达式，相反，是对应着类成员的一个标识符。没有明显可行的途径将一个标识符作为形参传递给函数，相反，由编译器处理获取成员的工作。</p><p>对于形如point-&gt;member的表达式来说，point必须是二者之一：指向类对象的指针、一个重载了operator-&gt;() 的类对象。</p><p>根据point类型的不同，有如下两条作用规则：</p><ol><li><p>如果point是指针，则按照内置的箭头运算符去处理。表达式等价于(*point).member。首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类没有名为member的成员，则编译器报错。</p></li><li><p>如果point是一个定义了operator-&gt;() 的类对象，则point-&gt;member等价于point.operator-&gt;() -&gt;member。其中，如果operator-&gt;()的返回结果是一个指针，则转第1步；如果返回结果仍然是一个对象，且该对象本身也重载了operator-&gt;()，则重复调用第2步，否则编译器报错。最终，过程要么结束在第一步，要么无限递归，要么报错。</p></li></ol><p>也就是说，如果返回类型是类类型的其他对象（或是这种对象的引用），则将递归应用该操作符。编译器检查返回对象所属类型是否具有成员箭头，如果有，就应用那个操作符；否则，编译器产生一个错误。这个过程继续下去，直到返回一个指向带有指定成员的的对象的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">firstClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">firstClass* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;firstClass -&gt;() is called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;firstClass action() is called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span> &#123;</span><br><span class="line">firstClass firstObj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">firstClass&amp; <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;myClass -&gt;() is called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> firstObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;myClass action() is called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">myClass obj;</span><br><span class="line">obj-&gt;<span class="built_in">action</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClass -&gt;() is called!</span><br><span class="line">firstClass -&gt;() is called!</span><br><span class="line">firstClass action() is called!</span><br></pre></td></tr></table></figure><h2 id="12-继承"><a href="#12-继承" class="headerlink" title="12. 继承"></a>12. 继承</h2><h3 id="12-1-重定义"><a href="#12-1-重定义" class="headerlink" title="12.1 重定义"></a>12.1 重定义</h3><p>重定义：有继承，子类重定义了父类的同名函数（包含静态和非静态，必须是非虚函数），参数顺序、个数、类型可以不同，子类一旦重定义了父类的同名函数，不管参数是否一致，都将屏蔽父类所有的同名函数，需要加父类的作用域才能访问。</p><p>补充一下<strong>重载</strong>的定义：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。函数的返回值 类型不能作为重载条件（函数重载、运算符重载）</p><h3 id="12-2-子类不能继承父类的成员"><a href="#12-2-子类不能继承父类的成员" class="headerlink" title="12.2 子类不能继承父类的成员"></a>12.2 子类不能继承父类的成员</h3><p>父类的构造函数、析构函数（但是在<strong>析构函数前加上virtual</strong>也有多态的性质，编译器为了让析构函数实现多态,会将它们的名字都处理为destructor）、赋值运算符不能被子类继承。</p><p>友元不属于类的成员所以不存在继承。</p><h2 id="13-多态"><a href="#13-多态" class="headerlink" title="13. 多态"></a>13. 多态</h2><h3 id="13-1-多态的分类"><a href="#13-1-多态的分类" class="headerlink" title="13.1 多态的分类"></a>13.1 多态的分类</h3><ul><li><p>静态多态：函数重载，运算符重载。</p></li><li><p>动态多态：有继承，子类重写父类的虚函数，父类指针指向子类地址空间。</p></li></ul><h3 id="13-2-虚函数"><a href="#13-2-虚函数" class="headerlink" title="13.2 虚函数"></a>13.2 虚函数</h3><p>定义：在成员函数前virtual修饰。</p><p>子类重写父类的虚函数要注意：函数名、返回值类型、参数<strong>类型个数顺序</strong>必须完全一致。</p><p>今后在定义类时析构函数都定义为虚函数。</p><p>重写（覆盖）：有继承，子类重写父类的虚函数。返回值类型、函数名、参数顺序、个数、类型都必须一致。</p><h3 id="13-3-虚函数的实现机制"><a href="#13-3-虚函数的实现机制" class="headerlink" title="13.3 虚函数的实现机制"></a>13.3 虚函数的实现机制</h3><p>靠虚函数指针和虚函数表实现</p><p><img src="/2022/09/06/c-review/image-20220914211210548.png" alt="image-20220914211210548"></p><h2 id="14-STL-容器"><a href="#14-STL-容器" class="headerlink" title="14. STL-容器"></a>14. STL-容器</h2><h3 id="14-1-vector容器"><a href="#14-1-vector容器" class="headerlink" title="14.1 vector容器"></a>14.1 vector容器</h3><p><strong>单端动态数组容器</strong></p><p><img src="/2022/09/06/c-review/image-20220916210913071.png" alt="image-20220916210913071"></p><h3 id="14-2-deque容器"><a href="#14-2-deque容器" class="headerlink" title="14.2 deque容器"></a>14.2 deque容器</h3><p><strong>双端动态数组容器</strong></p><p><img src="/2022/09/06/c-review/image-20220916215345053.png" alt="image-20220916215345053"></p><h2 id="15-STL-算法"><a href="#15-STL-算法" class="headerlink" title="15. STL-算法"></a>15. STL-算法</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文技术文档写作规范</title>
      <link href="/2022/09/06/%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
      <url>/2022/09/06/%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><h2 id="1-1-层级"><a href="#1-1-层级" class="headerlink" title="1.1 层级"></a>1.1 层级</h2><p>标题分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：文章主要部分的大标题</li><li>三级标题：二级标题下面一级的小标题</li><li>四级标题：三级标题下面某一方面的小标题</li></ul><p>下面是示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><p><strong>（1）一级标题下，不能直接出现三级标题</strong></p><p>示例：下面的文章结构，缺少二级标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p><strong>（2）标题要避免孤立编号（即同级标题只有一个）</strong></p><p>示例：下面的文章结构，<code>二级标题 A</code> 只包含一个三级标题，完全可以省略 <code>三级标题 A</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 二级标题 A</span><br><span class="line"></span><br><span class="line">### 三级标题 A</span><br><span class="line"></span><br><span class="line">## 二级标题 B</span><br></pre></td></tr></table></figure><p><strong>（3）下级标题不重复上一级标题的名字</strong></p><p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 概述</span><br><span class="line"></span><br><span class="line">### 概述</span><br></pre></td></tr></table></figure><p><strong>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节</strong></p><p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p><p>示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">结构一</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题 A</span><br><span class="line"></span><br><span class="line">#### 四级标题 B</span><br><span class="line"></span><br><span class="line">#### 四级标题 C</span><br><span class="line"></span><br><span class="line">结构二</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">**（1）A**</span><br><span class="line"></span><br><span class="line">**（2）B**</span><br><span class="line"></span><br><span class="line">**（3）C**</span><br></pre></td></tr></table></figure><blockquote><p>建议：无论是几级标题，只要下方的内容是对标题的解释，那么推荐直接使用项目列表（Item list）</p><p>举例：<code>一、标题</code>（一级标题）的 <code>1.2 原则</code>（二级标题）下方直接跟项目列表</p></blockquote><h1 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h1><h2 id="2-1-字间距"><a href="#2-1-字间距" class="headerlink" title="2.1 字间距"></a>2.1 字间距</h2><p><strong>（1）全角中文字符与半角英文字符之间，应有一个半角空格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本文介绍如何快速启动Windows系统。</span><br><span class="line"></span><br><span class="line">正确：本文介绍如何快速启动 Windows 系统。</span><br></pre></td></tr></table></figure><p><strong>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。</span><br><span class="line"></span><br><span class="line">正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。(个人推荐)</span><br></pre></td></tr></table></figure><p>半角的百分号，视同阿拉伯数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确：今年我国经济增长率是6.5%。</span><br><span class="line"></span><br><span class="line">正确：今年我国经济增长率是 6.5%。（个人推荐）</span><br></pre></td></tr></table></figure><p><strong>（3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例1：一部容量为 16 GB 的智能手机</span><br><span class="line"></span><br><span class="line">例2：1 h = 60 min = 3,600 s</span><br></pre></td></tr></table></figure><p><strong>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：他的电脑是 MacBook Air 。</span><br><span class="line"></span><br><span class="line">正确：他的电脑是 MacBook Air。</span><br></pre></td></tr></table></figure><h2 id="2-2-句子"><a href="#2-2-句子" class="headerlink" title="2.2 句子"></a>2.2 句子</h2><p><strong>（1）避免使用长句</strong></p><p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</span><br><span class="line"></span><br><span class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</span><br></pre></td></tr></table></figure><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p><p><strong>（2）尽量使用简单句和并列句，避免使用复合句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并列句：他昨天生病了，没有参加会议。</span><br><span class="line"></span><br><span class="line">复合句：那个昨天生病的人没有参加会议。</span><br></pre></td></tr></table></figure><p><strong>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：请确认没有接通装置的电源。</span><br><span class="line"></span><br><span class="line">正确：请确认装置的电源已关闭。</span><br></pre></td></tr></table></figure><p><strong>（4）避免使用双重否定句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：没有删除权限的用户，不能删除此文件。</span><br><span class="line"></span><br><span class="line">正确：用户必须拥有删除权限，才能删除此文件。</span><br></pre></td></tr></table></figure><h2 id="2-3-写作风格"><a href="#2-3-写作风格" class="headerlink" title="2.3 写作风格"></a>2.3 写作风格</h2><p><strong>（1）尽量不使用被动语态，改为使用主动语态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：假如此软件尚未被安装，</span><br><span class="line"></span><br><span class="line">正确：假如尚未安装这个软件，</span><br></pre></td></tr></table></figure><p><strong>（2）不使用非正式的语言风格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</span><br><span class="line"></span><br><span class="line">正确：无法参加本次活动，我深感遗憾。</span><br></pre></td></tr></table></figure><p><strong>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：这是唯二的快速启动的方法。</span><br><span class="line"></span><br><span class="line">正确：这是仅有的两种快速启动的方法。</span><br></pre></td></tr></table></figure><p><strong>（4）用对 “的”、“地”、“得”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">她露出了开心的笑容。</span><br><span class="line">（形容词＋的＋名词）</span><br><span class="line"></span><br><span class="line">她开心地笑了。</span><br><span class="line">（副词＋地＋动词）</span><br><span class="line"></span><br><span class="line">她笑得很开心。</span><br><span class="line">（动词＋得＋副词）</span><br></pre></td></tr></table></figure><p><strong>（5）使用代词时（比如 “其”、“该”、“此”、“这” 等词），必须明确指代的内容，保证只有一个含义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</span><br><span class="line"></span><br><span class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</span><br></pre></td></tr></table></figure><p><strong>（6）名词前不要使用过多的形容词</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</span><br><span class="line"></span><br><span class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</span><br></pre></td></tr></table></figure><h2 id="2-4-英文处理"><a href="#2-4-英文处理" class="headerlink" title="2.4 英文处理"></a>2.4 英文处理</h2><p><strong>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：⋯information stored in random access memory (RAMs)⋯</span><br><span class="line"></span><br><span class="line">中文：……存储在随机存取存储器（RAM）里的信息……</span><br></pre></td></tr></table></figure><p><strong>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">U.S.A.</span><br><span class="line">Apple, Inc.</span><br></pre></td></tr></table></figure><p><strong>（3）表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：5 minutes later⋯</span><br><span class="line"></span><br><span class="line">中文：5 分钟过去了……</span><br></pre></td></tr></table></figure><p><strong>（4）英文书名或电影名改用中文表达时，双引号应改为书名号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英文：He published an article entitled &quot;The Future of the Aviation&quot;.</span><br><span class="line"></span><br><span class="line">中文：他发表了一篇名为《航空业的未来》的文章。</span><br></pre></td></tr></table></figure><p><strong>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用 “IOC” 了。</span><br></pre></td></tr></table></figure><p><strong>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。</span><br><span class="line"></span><br><span class="line">“online transaction processing”（在线事务处理）不是专有名词，不应大写。</span><br></pre></td></tr></table></figure><h1 id="三、段落"><a href="#三、段落" class="headerlink" title="三、段落"></a>三、段落</h1><h2 id="3-1-原则"><a href="#3-1-原则" class="headerlink" title="3.1 原则"></a>3.1 原则</h2><ul><li>一个段落只能有一个主题，或一个中心句子</li><li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务</li><li>一个段落的长度不能超过七行，最佳段落长度小于等于四行</li><li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气</li><li>段落之间使用一个空行隔开</li><li>段落开头不要留出空白字符</li><li>文本句子正常情况下均该以句号结尾</li></ul><h2 id="3-2-引用"><a href="#3-2-引用" class="headerlink" title="3.2 引用"></a>3.2 引用</h2><p>引用第三方内容时，应注明出处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One man’s constant is another man’s variable. — Alan Perlis</span><br></pre></td></tr></table></figure><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文转载自 WikiQuote</span><br></pre></td></tr></table></figure><p>使用外部图片时，必须在图片下方或文末标明来源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文部分图片来自 Wikipedia</span><br></pre></td></tr></table></figure><h1 id="四、数值"><a href="#四、数值" class="headerlink" title="四、数值"></a>四、数值</h1><h2 id="4-1-半角数字"><a href="#4-1-半角数字" class="headerlink" title="4.1 半角数字"></a>4.1 半角数字</h2><p>阿拉伯数字一律使用半角形式，不得使用全角形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：这件商品的价格是１０００元。</span><br><span class="line"></span><br><span class="line">正确：这件商品的价格是 1000 元。</span><br></pre></td></tr></table></figure><h2 id="4-2-千分号"><a href="#4-2-千分号" class="headerlink" title="4.2 千分号"></a>4.2 千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXX 公司的实收资本为 ￥1,258,000 人民币。</span><br></pre></td></tr></table></figure><p>对于 4 位以下的数值，千分号是选用的，比如 <code>1000</code> 和 <code>1,000</code> 都可以接受。对于 4 位以上的数值，千分号是必须的。</p><h2 id="4-3-货币"><a href="#4-3-货币" class="headerlink" title="4.3 货币"></a>4.3 货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1,000</span><br><span class="line">1,000 美元</span><br></pre></td></tr></table></figure><p>英文的货币名称，建议参考国际标准 <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217</a>。</p><h2 id="4-4-数值范围"><a href="#4-4-数值范围" class="headerlink" title="4.4 数值范围"></a>4.4 数值范围</h2><p>表示数值范围时，用 <code>～</code> 或 <code>——</code> 连接。参见《标点符号》一节的 “连接号” 部分。</p><p>带有单位或百分号时，两个数字建议都要加上单位或百分号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">132kg～234kg</span><br><span class="line"></span><br><span class="line">67%～89%</span><br></pre></td></tr></table></figure><h2 id="4-5-变化程度的表示法"><a href="#4-5-变化程度的表示法" class="headerlink" title="4.5 变化程度的表示法"></a>4.5 变化程度的表示法</h2><p>数字的增加要使用 “增加了”、“增加到”。“了” 表示增量，“到” 表示定量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">增加到过去的两倍</span><br><span class="line">（过去为一，现在为二）</span><br><span class="line"></span><br><span class="line">增加了两倍</span><br><span class="line">（过去为一，现在为三）</span><br></pre></td></tr></table></figure><p>数字的减少要使用 “降低了”、“降低到”。“了” 表示增量，“到” 表示定量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">降低到百分之八十</span><br><span class="line">（定额是一百，现在是八十）</span><br><span class="line"></span><br><span class="line">降低了百分之八十</span><br><span class="line">（原来是一百，现在是二十）</span><br></pre></td></tr></table></figure><p>不能用 “降低 N 倍 ” 或 “减少 N 倍” 的表示法，要用 “降低百分之几” 或 “减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p><h1 id="五、标点符号"><a href="#五、标点符号" class="headerlink" title="五、标点符号"></a>五、标点符号</h1><h2 id="5-1-原则"><a href="#5-1-原则" class="headerlink" title="5.1 原则"></a>5.1 原则</h2><p><strong>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致</strong></p><p><strong>（2）如果整句为英文，则该句使用英文&#x2F;半角标点</strong></p><p><strong>（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首</strong></p><p><strong>（4）点号（句号、逗号、顿号、分号、冒号）不得出现在标题的末尾，而标号（引号、括号、破折号、省略号、书名号、着重号、间隔号、叹号、问号）可以</strong></p><h2 id="5-2-句号"><a href="#5-2-句号" class="headerlink" title="5.2 句号"></a>5.2 句号</h2><p><strong>（1）中文语句的结尾处应该用全角句号（<code>。</code>）</strong></p><p><strong>（2）句子末尾用括号加注时，句号应在括号之外</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）</span><br><span class="line"></span><br><span class="line">正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。</span><br></pre></td></tr></table></figure><h2 id="5-3-逗号"><a href="#5-3-逗号" class="headerlink" title="5.3 逗号"></a>5.3 逗号</h2><p><strong>（1）逗号（<code>，</code>）表示句子内部的一般性停顿</strong></p><p><strong>（2）注意避免 “一逗到底”，即整个段落除了结尾，全部停顿都使用逗号</strong></p><h2 id="5-4-顿号"><a href="#5-4-顿号" class="headerlink" title="5.4 顿号"></a>5.4 顿号</h2><p><strong>（1）中文句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使存在并列词是英语也是如此</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure><p><strong>（2）英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.</span><br></pre></td></tr></table></figure><p><strong>（3）中文句子内部的并列词，最后一个尽量使用（<code>和</code>）来连接，使句子读起来更加连贯，下面两个句子都可以，第二个更优</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里，以及百度等。</span><br><span class="line"></span><br><span class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</span><br></pre></td></tr></table></figure><h2 id="5-5-分号"><a href="#5-5-分号" class="headerlink" title="5.5 分号"></a>5.5 分号</h2><p><strong>（1）分号（<code>；</code>）表示复句内部并列分句之间的停顿</strong></p><h2 id="5-6-引号"><a href="#5-6-引号" class="headerlink" title="5.6 引号"></a>5.6 引号</h2><p><strong>（1）引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：许多人都认为客户服务的核心是 “友好” 和 “专业”。</span><br></pre></td></tr></table></figure><p><strong>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</span><br></pre></td></tr></table></figure><p><strong>（3）引号与前后文字之间应该用一个空格隔开，与标点符号之间则不用</strong></p><h2 id="5-7-括号"><a href="#5-7-括号" class="headerlink" title="5.7 括号"></a>5.7 括号</h2><p><strong>（1）使用全角圆括号（<code>（）</code>），括号前后不加空格。使用半角圆括号（<code>()</code>），括号前后加一个空格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</span><br><span class="line"></span><br><span class="line">例句：I love you (GitHub).</span><br></pre></td></tr></table></figure><p>圆括号前后遇到标点符号不用加空格。</p><p><strong>（2）几种括号的中英文名称</strong></p><table><thead><tr><th></th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td><code>&#123; &#125;</code></td><td>braces 或 curly brackets</td><td>大括号</td></tr><tr><td><code>[ ]</code></td><td>square brackets 或 brackets</td><td>方括号</td></tr><tr><td><code>&lt; &gt;</code></td><td>angled brackets</td><td>尖括号</td></tr><tr><td><code>( )</code></td><td>parentheses</td><td>圆括号</td></tr></tbody></table><p><strong>（3）中文句子中只能出现全角圆括号（<code>（）</code>），无论括号中是中文还是英文。英文句子中只能出现半角圆括号（<code>()</code>），无论括号中是英文还是中文</strong></p><h2 id="5-8-冒号"><a href="#5-8-冒号" class="headerlink" title="5.8 冒号"></a>5.8 冒号</h2><p><strong>（1）全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：请确认以下几项内容：时间、地点、活动名称和来宾数量。</span><br></pre></td></tr></table></figure><p><strong>（2）中文句子中一律使用全角冒号（<code>：</code>），无论冒号前是中文还是英文；英文句子中一律使用半角冒号（<code>:</code>），无论冒号前是英文还是中文</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Markdown：是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</span><br></pre></td></tr></table></figure><p><strong>（3）表示时间时，应使用半角冒号（<code>:</code>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：早上 8:00</span><br></pre></td></tr></table></figure><h2 id="5-9-省略号"><a href="#5-9-省略号" class="headerlink" title="5.9 省略号"></a>5.9 省略号</h2><p><strong>（1）省略号（<code>……</code>）表示语句未完、或者语气的不连续</strong></p><p><strong>（2）省略号占两个汉字空间、包含六个省略点，不要使用 <code>。。。</code> 或 <code>...</code> 等非标准形式</strong></p><p><strong>（3）省略号不应与 “等” 这个词一起使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</span><br><span class="line"></span><br><span class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</span><br></pre></td></tr></table></figure><h2 id="5-10-感叹号"><a href="#5-10-感叹号" class="headerlink" title="5.10 感叹号"></a>5.10 感叹号</h2><p><strong>（1）应该使用平静的语气叙述，尽量避免使用感叹号（<code>！</code>）</strong></p><p><strong>（2）不得多个感叹号连用，比如 <code>！！</code> 和 <code>!!!</code></strong></p><h2 id="5-11-破折号"><a href="#5-11-破折号" class="headerlink" title="5.11 破折号"></a>5.11 破折号</h2><p><strong>（1）破折号 <code>————</code> 一般用于进一步解释</strong></p><p><strong>（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</span><br><span class="line"></span><br><span class="line">例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。</span><br></pre></td></tr></table></figure><h2 id="5-12-连接号"><a href="#5-12-连接号" class="headerlink" title="5.12 连接号"></a>5.12 连接号</h2><p><strong>（1）连接号用于连接两个类似的词</strong></p><p><strong>（2）以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置</strong></p><ul><li>两个名词的复合</li><li>图表编号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：氧化-还原反应</span><br><span class="line"></span><br><span class="line">例句：图 1-1</span><br></pre></td></tr></table></figure><p><strong>（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>），占一个全角字符的位置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：2009年～2011年</span><br></pre></td></tr></table></figure><p>注意，波浪连接号前后两个值都应该加上单位。</p><p><strong>（4）波浪连接号也可以用汉字 “至” 代替</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：周围温度：-20°C 至 -10°C</span><br></pre></td></tr></table></figure><h1 id="六、Markdown"><a href="#六、Markdown" class="headerlink" title="六、Markdown"></a>六、Markdown</h1><blockquote><p>Markdown 中所有文本内容均建议按照上述规范来书写。</p></blockquote><h2 id="6-1-标题"><a href="#6-1-标题" class="headerlink" title="6.1 标题"></a>6.1 标题</h2><p>只使用三级标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>四级标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 全角圆括号加粗 --&gt;</span><br><span class="line">**（1）标题**</span><br></pre></td></tr></table></figure><p>一到四级标题末尾不能出现句号。</p><p>单个四级标题直接加粗即可，不要写序号。</p><p>四级标题后请使用列表。</p><p><strong>开头规范</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 名称&lt;!-- 书名、文件名、文档名用《》，其他用 【】 --&gt;</span><br><span class="line"></span><br><span class="line">**第二名称**</span><br><span class="line"></span><br><span class="line">&gt; 声明</span><br><span class="line"></span><br><span class="line">**目录**</span><br><span class="line"></span><br><span class="line"># 一、一级标题</span><br><span class="line">或者</span><br><span class="line"># 第一章 一级标题</span><br><span class="line"></span><br><span class="line">## 1.1 二级标题</span><br><span class="line"></span><br><span class="line">### 1.1.1 三级标题</span><br><span class="line"></span><br><span class="line">**（1）四级标题**</span><br></pre></td></tr></table></figure><h2 id="6-2-段落"><a href="#6-2-段落" class="headerlink" title="6.2 段落"></a>6.2 段落</h2><p>四级标题及关键字才能使用 “加粗”，书名、人名等可以 “斜体”，建议不要使用 “高亮”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**Markdown**：是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</span><br><span class="line"></span><br><span class="line">*斜体*</span><br><span class="line"></span><br><span class="line">==高亮==</span><br></pre></td></tr></table></figure><blockquote><p><strong>Markdown</strong>：是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p></blockquote><p>标题上下不要使用分割线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><p>上下角标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5~4~</span><br><span class="line">2^4^</span><br><span class="line">5&lt;sup&gt;4&lt;/sup&gt;</span><br><span class="line">2&lt;sub&gt;4&lt;/sub&gt;</span><br><span class="line">&lt;!-- 推荐使用 HTML 便签法 --&gt;</span><br></pre></td></tr></table></figure><blockquote><p>5<del>4</del></p><p>2^4^</p><p>54</p><p>24</p></blockquote><h2 id="6-3-列表"><a href="#6-3-列表" class="headerlink" title="6.3 列表"></a>6.3 列表</h2><p>同一列表不能分隔开，建议列表元素单行字数不要过长。</p><p>两个及以上元素才能使用列表，单个元素不能用列表表示。</p><p>列表每行的结束不加句号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 无序列表 --&gt;</span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br><span class="line"></span><br><span class="line">&lt;!-- 有序列表 --&gt;</span><br><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><h2 id="6-4-区块"><a href="#6-4-区块" class="headerlink" title="6.4 区块"></a>6.4 区块</h2><p>区块使用在声明、引用、特殊强调和非主体内容部分。</p><p>区块严禁嵌套，区块中可以使用列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; 3. 第三项</span><br><span class="line">&gt; - 第一项</span><br><span class="line">&gt; - 第二项</span><br><span class="line">&gt; - 第三项</span><br></pre></td></tr></table></figure><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="6-5-代码"><a href="#6-5-代码" class="headerlink" title="6.5 代码"></a>6.5 代码</h2><p>段落中的片段代码适量使用，关键字不要重复使用片段代码。</p><p>片段代码前后遇到文字留一个空格，遇到标点符号不用留空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个 `片段代码` 示 `例`。</span><br></pre></td></tr></table></figure><blockquote><p>这是一个 <code>片段代码</code> 示 <code>例</code>。</p></blockquote><p>代码块严格标注类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 普通文本 --&gt;</span><br><span class="line">```text</span><br><span class="line">普通文字标注 text 类型</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;!-- markdown --&gt;</span><br><span class="line">```markdown</span><br><span class="line">### Markdown 文本标注为 markdown 类型。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;!-- 命令行 --&gt;</span><br><span class="line">```bash</span><br><span class="line">$ javac Test.java</span><br><span class="line"># 编译 Test.java 文件。</span><br><span class="line"># 命令行统一为 bash 类型，且每条命令前加上 &#x27;$&#x27;，其中 &#x27;#&#x27; 为 bash 注释。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;!-- 代码 --&gt;</span><br><span class="line">```java</span><br><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">// 打印 Hello World!</span><br><span class="line">/* 根据不同的编程语言选择不同的类型。 */</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通文字标注 text 类型</span><br></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### Markdown 文本标注为 markdown 类型。</span><br></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac Test.java</span><br><span class="line"># 编译 Test.java 文件。</span><br><span class="line"># 命令行统一为 bash 类型，且每条命令前加上 &#x27;$&#x27;，其中 &#x27;#&#x27; 为 bash 注释。</span><br></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">// 打印 Hello World!</span><br><span class="line">/* 根据不同的编程语言选择不同的类型。 */</span><br></pre></td></tr></table></figure><h2 id="6-6-链接"><a href="#6-6-链接" class="headerlink" title="6.6 链接"></a>6.6 链接</h2><p>非特殊情况不要直接暴露链接地址。</p><p>链接左右为文字时留一个空格，为标点符号时不用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">建议：[bilibili](https://www.bilibili.com/)</span><br><span class="line"></span><br><span class="line">不建议：&lt;https://www.bilibili.com/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>建议：<a href="https://www.bilibili.com/">bilibili</a></p><p>不建议：<a href="https://www.bilibili.com/">https://www.bilibili.com/</a></p></blockquote><h2 id="6-7-图片"><a href="#6-7-图片" class="headerlink" title="6.7 图片"></a>6.7 图片</h2><p>合理调整图片大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="6-8-表格"><a href="#6-8-表格" class="headerlink" title="6.8 表格"></a>6.8 表格</h2><p>表格非特殊情况一律默认左对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h2 id="6-9-高级"><a href="#6-9-高级" class="headerlink" title="6.9 高级"></a>6.9 高级</h2><blockquote><p>以下用法存在一定风险，不建议使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 键盘按键 --&gt;</span><br><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br></pre></td></tr></table></figure><blockquote><p>使用 Ctrl+Alt+Del 重启电脑</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 转义 --&gt;</span><br><span class="line">**文本加粗** </span><br><span class="line">\*\* 正常显示星号 \*\*</span><br></pre></td></tr></table></figure><blockquote><p><strong>文本加粗</strong> ** 正常显示星号 **</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 居中 --&gt;</span><br><span class="line">&lt;center&gt;中&lt;center&gt;</span><br></pre></td></tr></table></figure><blockquote><p>中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 左对齐 --&gt;</span><br><span class="line">&lt;p align=&quot;left&quot;&gt;左&lt;/p&gt;</span><br></pre></td></tr></table></figure><blockquote><p>左</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 右对齐 --&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右&lt;/p&gt;</span><br></pre></td></tr></table></figure><blockquote><p>右</p></blockquote><h1 id="七、文档体系"><a href="#七、文档体系" class="headerlink" title="七、文档体系"></a>七、文档体系</h1><h2 id="7-1-结构"><a href="#7-1-结构" class="headerlink" title="7.1 结构"></a>7.1 结构</h2><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><p><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</p></li><li><p><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</p></li><li><p>入门篇</p><p>（Basics）： [必备] [目录] 又称 “使用篇”，提供初级的使用教程</p><ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><p><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称 “开发篇”，提供中高级的开发教程</p></li><li><p><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</p></li><li><p><strong>FAQ</strong>：[可选] [文件] 常见问题解答</p></li><li><p>附录</p><p>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容</p><ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><h2 id="7-2-文件名"><a href="#7-2-文件名" class="headerlink" title="7.2 文件名"></a>7.2 文件名</h2><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：名词解释.md</span><br><span class="line"></span><br><span class="line">正确：glossary.md</span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line"></span><br><span class="line">正确：troubleshooting.md </span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如 <code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line"></span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></table></figure><h1 id="八、重要问题"><a href="#八、重要问题" class="headerlink" title="八、重要问题"></a>八、重要问题</h1><h2 id="8-1-为什么文件名要小写？"><a href="#8-1-为什么文件名要小写？" class="headerlink" title="8.1 为什么文件名要小写？"></a>8.1 为什么文件名要小写？</h2><p><strong>（1）可移植性</strong></p><p>Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。一般来说，这不是大问题。</p><p>但是，如果两个文件名只有大小写不同，其他都相同，跨平台就会出问题。</p><ul><li><code>foobar</code></li><li><code>Foobar</code></li><li><code>FOOBAR</code></li><li><code>fOObAr</code></li></ul><p>上面四个文件名，Windows 系统会把它们都当作 <code>foobar</code>。如果它们同时存在，你可能没办法打开后面三个文件。</p><p>另一方面，在 Mac 系统上开发时，有时会疏忽，写错大小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正确文件名是 MyModule.js</span><br><span class="line">const module = require(&#x27;./myModule&#x27;);</span><br></pre></td></tr></table></figure><p>上面的代码在 Mac 上面可以运行，因为 Mac 认为 <code>MyModule.js</code> 和 <code>myModule.js</code> 是同一个文件。但是，一旦代码到服务器运行就会报错，因为 Linux 系统找不到 <code>myModule.js</code>。</p><p>如果所有的文件名都采用小写，就不会出现上面的问题，可以保证项目有良好的可移植性。</p><p><strong>（2）易读性</strong></p><p>小写文件名通常比大写文件名更易读，比如 <code>accessibility.txt</code> 就比 <code>ACCESSIBILITY.TXT</code> 易读。</p><p>有人习惯使用 <a href="https://baike.baidu.com/item/%E9%AA%86%E9%A9%BC%E5%91%BD%E5%90%8D%E6%B3%95?fromtitle=%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95&fromid=7560610">驼峰命名法</a>，单词的第一个字母大写，其他字母小写。这种方法的问题是，如果遇到全部是大写的缩略词，就会不适用。</p><p>比如，一个姓李的纽约特警，无论写成 <code>NYPoliceSWATLee</code> 还是 <code>NyPoliceSwatlee</code>，都怪怪的，还是写成 <code>ny-police-swat-lee</code> 比较容易接受。</p><p><strong>（3）易用性</strong></p><p>某些系统会生成一些预置的用户目录，采用首字母大写的目录名。比如，Ubuntu 在用户主目录会默认生成 <code>Downloads</code>、 <code>Pictures</code>、<code>Documents </code>等目录。</p><p>Mac 系统一部分系统目录也是大写的，比如 <code>/Library/Audio/Apple Loops/</code>。</p><p>另外，某些常见的配置文件或说明文件，也采用大写的文件名，比如 <code>Makefile</code>、<code>INSTALL</code>、<code>CHANGELOG</code>、<code>.Xclients</code> 和 <code>.Xauthority</code> 等等。</p><p>所以，用户的文件都采用小写文件名，就很方便与上面这些目录或文件相区分。</p><p>那问到底，为什么操作系统会采用这样的大写文件名？原因也很简单，因为早期 Unix 系统上，<code>ls</code> 命令先列出大写字母，再列出小写字母，大写的路径会排在前面。因此，如果目录名或文件名是大写的，就比较容易被用户首先看到。</p><p><strong>（4）便捷性</strong></p><p>文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用 <code>-i</code> 参数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 大小写敏感的搜索</span><br><span class="line">$ find . -name abc</span><br><span class="line">$ locate &quot;*.htmL&quot;</span><br><span class="line"></span><br><span class="line"># 大小写不敏感的搜索</span><br><span class="line">$ find . -iname abc</span><br><span class="line">$ locate -i &quot;*.HtmL&quot;</span><br></pre></td></tr></table></figure><p>另外，大写字母需要按下 Shift 键，多多少少有些麻烦。如果文件名小写，就不用碰这个键了，不仅省事，还可以提高打字速度。</p><p>程序员长时间使用键盘，每分钟少按几次 Shift，一天下来就可以省掉很多手指动作。长年累月，也是对自己身体的一种保护。</p><p>综上所述，文件名全部使用小写字母和连词线（all-lowercase-with-dashes），是一种值得推广的正确做法。</p><h2 id="8-2-技术文档与文章的区别？"><a href="#8-2-技术文档与文章的区别？" class="headerlink" title="8.2 技术文档与文章的区别？"></a>8.2 技术文档与文章的区别？</h2><ul><li>技术文档注重：专业、严谨、严肃、简练</li><li>技术文章注重：图文并茂、通俗易懂、妙趣横生</li></ul><h2 id="8-3-技术文档与文章的核心？"><a href="#8-3-技术文档与文章的核心？" class="headerlink" title="8.3 技术文档与文章的核心？"></a>8.3 技术文档与文章的核心？</h2><p><strong>（1）技术文档</strong></p><ul><li>必要的声明</li><li>清晰严谨的章节安排</li><li>单独设计合理的目录导航页</li><li>删减一切非必要图片</li><li>严谨地运用链接</li><li>合理留白</li></ul><p><strong>（2）技术文章</strong></p><ul><li>必要的声明</li><li>清晰直观的目录</li><li>合理布局图文内容</li><li>图片适量且具有代表性</li><li>注意文章的平台可移植性</li><li>搭建合理的分享传播途径</li><li>注重通俗易懂</li><li>注重趣味</li><li>注重美观</li><li>合理留白</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档写作规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档写作规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ol><li><p>排序中相关术语解释：</p><p>稳定：如果a原本在b前面，而a&#x3D;b，排序后a仍然在b前面</p><p>不稳定：如果a原本在b前面，而a&#x3D;b，排序后a可能在b后面</p></li><li><p>基数排序（桶排序的扩展），从个位开始对一个数组进行排序，然后是十位、百位（十位百位没有数字就补零），因为十位的排序建立在个位排序的基础之上，百位建立在十位排序的基础之上，所以该算法排序是正确的，排序次数位数组中最大数字的位数，举例如下：</p><p>53 3 542 748 14 214</p><p>个位排序：542 53 3 14 214 748</p><p>十位排序：3 14 214 542 748 53</p><p>百位排序：3 14 53 214 542 748</p></li></ol><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><ol><li><p>插值查找（定位mid的公式进行了优化）：将二分查找中求mid的公式改为 <img src="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220425221317298.png" alt="image-20220425221317298"></p><p>举例说明：数组arr&#x3D;{1，2，3，……100}，假如需要查找的值为1，第一次得到的mid&#x3D;0+(99-0)*(1-1)&#x2F;(100-1)&#x3D;0，公式将mid的求法变为计算key（key是要查找的值）与arr[left]的差距占arr[right]-arr[left]的比例乘此时的数组长度，因为数组是有序的，所以该公式可以快速的找到与key值接近的位置</p><p>该算法中需要<strong>注意</strong>：因为key参与寻找mid（自适应），所以如果key很大的话会导致算出来的mid很大直接越界,而key在arr[left]和arr[right]之间可以保证该公式算出来的值一定不越界，插值查找存在<strong>局限性</strong>，当数组中的有序元素之间存在较大差距时（或者说需要查找的数组中的元素分布不均匀时），插值查找的效率往往不如二分查找</p></li></ol><span id="more"></span><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ol><li><p>二叉树</p><ol><li>前序遍历：中左右；中序遍历：左中右；后序遍历：左右中（父节点先输出就是前序，父节点中间输出为中序，父节点最后输出为后序）</li><li>满二叉树：该二叉树的所有叶子节点（没有子节点的节点）都在最后一层，并且结点总数&#x3D;$2^n$-1,n为层数</li><li>完全二叉树：若设二叉树的高度为h，除第h层外，其他各层（1~h-1）的节点数都达到最大个数，第h层上的节点都集中在该层最左边的若干位置上</li></ol></li><li><p>顺序存储二叉树：存储方式是从树结构上看，从上到下从左到右将每一个节点的值存在数组中。需要实现的方法是将这样存储好的数组以树的方式来进行遍历输出</p><p>顺序存储二叉树的特点：</p><ol><li>通常只考虑完全二叉树</li><li>第n个元素的左子节点为2*n+1（这里及下面的n表示二叉树（其实是数组）中的第几个元素，按零开始编号）</li><li>第n个元素的左子节点为2*n+2</li><li>第n个元素的父节点为（n-1）&#x2F; 2（向下取整除法）</li></ol><p>顺序存储二叉树在堆排序中会用到，可以用数学归纳法证明上面的公式</p></li><li><p>二叉排序树：对于二叉排序树的任何一个非叶子结点，要求左子结点的值比当前结点的值小，右子结点的值比当前结点的值大。（如果有相同的值，可以将该结点放在左子结点或右子结点）</p></li><li><p>平衡二叉树首先是二叉排序树，它是在二叉排序树的基础上实现的。</p><p>平衡二叉树的特点：它是一棵空树或者它的左右两个子树的<strong>高度差</strong>的绝对值<strong>不超过1</strong>，并且左右两个子树都是一颗平衡二叉树，平衡二叉树的实现方法有：红黑树、AVL等。</p></li><li><p>堆：</p></li></ol><ul><li><p>最大堆（又叫大顶堆）：堆顶是整个数组中最大的元素，且任何父节点的值都大于其子节点</p></li><li><p>最小堆（又叫小顶堆）：堆顶是整个数组中最小的元素，且任何父节点的值都小于其子节点</p><p>堆（通常是顺序存储二叉树得到的）的一些操作：下面以<strong>最大堆</strong>为例</p><ul><li><p>插入一个元素：每次插入都是将先将新数据放在数组最后，由于从这个新数据的父结点到根结点必然为一个有序的序列，现在的任务是将这个新数据插入到这个有序序列中——这就类似于直接插入排序中将一个数据并入到有序区间中。我们交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。这就是所谓的 <strong>shift-up</strong>，每一次插入操作后都需要进行。它将一个太大或者太小的数字“浮起”到树的顶部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shiftUp</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parentIndex=(index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (parentIndex &gt;= <span class="number">0</span> &amp;&amp;arr[index]&gt;arr[parentIndex])&#123;</span><br><span class="line">        swap(arr,index,parentIndex);</span><br><span class="line">        shiftUp(arr,parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除堆顶元素：堆中每次都只能删除堆顶元素删除一个元素，由于堆的<strong>完全二叉树的特点</strong>限制，要提防出现最后一层断层，即不连续。</p><p><img src="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220415184950837.png" alt="image-20220415184950837"></p><p>所以采用的方法是把<strong>最末的元素替换堆顶</strong>再进行堆化，这样得到的新堆肯定是符合其自身特点的。很明显，这里是<strong>从上往下的</strong>堆化过程。</p><p>删除堆顶元素的算法如下：将堆顶元素与堆的末尾的元素交换，然后删除该元素后（此时删除的是末尾一个元素），从堆的根结点调用shift-down。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。从根节点开始，找到左右子节点中小的那个，将根结点与之交换，在递归进行比较，直到该节点没有任何子节点或者它比两个子节点都要大为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//这个代码中我实现的是最大堆</span></span><br><span class="line">    <span class="comment">//这个函数就是shiftDown()：如果一个节点比它的子节点小（最大堆），</span></span><br><span class="line">    <span class="comment">//那么需要将它向下移动。这个操作也称作“堆化（heapify）”。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &gt;= len) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largestIndex</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largestIndex]) &#123;</span><br><span class="line">        largestIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largestIndex]) &#123;</span><br><span class="line">        largestIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largestIndex != i) &#123;</span><br><span class="line">        swap(arr, i, largestIndex);</span><br><span class="line">        adjustHeap(arr, largestIndex, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造最大堆：首先将每个叶子节点视为一个堆，再将每个叶子节点与其父节点一起构造成一个包含更多节点的堆。所以，在构造堆的时候，首先需要找到最后一个节点的父节点，从这个节点开始构造最大堆；直到该节点前面所有分支节点都处理完毕，这样最大堆就构造完毕了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//因为顺序化二叉树是从左至右从上至下，所以最后一个叶子节点(len-1)的父节点(len-1-1)/2一定是最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustHeap(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="6"><li><p>优先队列：就是堆</p></li><li><p>最大优先队列：无论入队的顺序，当前最大的元素先出列。<br>最小优先队列：无论入队的顺序，当前最小的元素先出列。</p><p><strong>说明：以最小优先队列为例</strong></p><ul><li>入队操作<br>优先队列本质上就是用二叉堆来实现的，每次插入一个数据都是插入到数据数组的最后一个位置，然后再做上浮操作，如果插入的数是数组中最大数，自然会上浮到堆顶。</li><li>出队操作<br>出队操作就是返回堆顶最小堆的数据之后用数组最后的数插入到堆顶，之后再做下沉操作。</li></ul></li></ol><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ol><li><p>图的一些基本知识：</p><p>连通图：在无向图中任意两个顶点都是连通的(可以不是直接相连)，则称该图为连通图。</p><p>非连通图：易知为上面定义的反面</p></li><li><p>图的深度优先遍历（Depth First Search简称DFS）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    isVisited[i]=<span class="literal">true</span>;<span class="comment">//标记为已访问</span></span><br><span class="line">    System.out.print(vertexList.get(i)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">        <span class="comment">// 这里的for循环就有递归回溯，从当前结点的第一个邻接结点递归遍历后，</span></span><br><span class="line">        <span class="comment">// 会继续寻找当前结点的下一个未访问的邻接结点，如果有就再次进行递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> (edges[i][j]==<span class="number">1</span>&amp;&amp;!isVisited[j])&#123;</span><br><span class="line">            dfs(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//今后调用的是dfsTraverse，以图的所有结点作为初始结点进行遍历，除去已访问的结点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsTraverse</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">            dfs(i);<span class="comment">//对未访问过的顶点调用dfs，如果是连通图，只会执行一次该语句，今后for循环的顶点都已经访问过了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图的广度优先遍历（Broad First Search简称BFS）：</p><p>我们采用示例图来说明这个过程，在搜索的过程中，初始所有节点是白色（代表了所有点都还没开始搜索），把起点V0标志成灰色（表示即将辐射V0），下一步搜索的时候，我们把所有的灰色节点访问一次，然后将其变成黑色（表示已经被辐射过了），进而再将他们所能到达的节点标志成灰色（因为那些节点是下一步搜索的目标点了），但是这里有个判断，就像刚刚的例子，当访问到V1节点的时候，它的下一个节点应该是V0和V4，但是V0已经在前面被染成黑色了，所以不会将它染灰色。这样持续下去，直到目标节点V6被染灰色，说明了下一步就到终点了，没必要再搜索（染色）其他节点了，此时可以结束搜索了，整个搜索就结束了。然后根据搜索过程，反过来把最短路径找出来，下图中把最终路径上的节点标志成绿色。</p></li></ol><p><img src="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220317231004623.png" alt="image-20220317231004623"></p><p><img src="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220317231029925.png" alt="image-20220317231029925"></p><p><img src="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1335725885_9403.png" alt="1335725885_9403"></p><p>​为了便于进行搜索，要设置一个表存储所有的结点。由于在广度优先搜索算法中，要满足先生成的结点先扩展的原则，所以存储结点的表一般采用队列这种数据结构。</p><p>​在编写程序时，可用数组q模拟队列。front和rear分别表示队头指针和队尾指针，初始时front&#x3D;rear&#x3D;0。</p><p>​元素x入队操作为 q[rear++]&#x3D;x;</p><p>​元素x出队操作为 x &#x3D;q[front++];</p><p>广度优先搜索算法的搜索步骤一般是：</p><p>   （1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。</p><p>   （2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。</p><p>  （3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。</p><p>最终可能产生两种结果：找到目标结点，或扩展完所有结点而没有找到目标结点。</p><p>对于广度优先搜索算法来说，问题不同则状态结点的结构和结点扩展规则是不同的，但搜索的策略是相同的。广度优先搜索算法的框架一般如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  BFS（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    队列初始化；</span><br><span class="line"></span><br><span class="line">        初始结点入队；</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> （队列非空）</span><br><span class="line"></span><br><span class="line">        &#123;  </span><br><span class="line"></span><br><span class="line">            队头元素出队，赋给current；</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>  （current 还可以扩展）</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    由结点current扩展出新结点new；</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>  （new 重复于已有的结点状态） <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    new结点入队；</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>  (new结点是目标状态)</span><br><span class="line"></span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                            置flag= <span class="literal">true</span>;    <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些常用算法和数据结构"><a href="#一些常用算法和数据结构" class="headerlink" title="一些常用算法和数据结构"></a>一些常用算法和数据结构</h1><ol><li><p>分治算法：</p><p>分治法在每一层递归上都有三个步骤：</p><p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p>step3 合并：将各个子问题的解合并为原问题的解。</p><p>它的一般的算法设计模式如下：</p><pre><code>Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi6. T ← MERGE(y1,y2,...,yk) △ 合并子问题7. return(T)</code></pre><p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><p><strong>依据分治法设计程序时的思维过程</strong></p><p>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。<br>1、一定是先找到最小问题规模时的求解方法<br>2、然后考虑随着问题规模增大时的求解方法<br>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p></li><li><p><strong>贪心算法（Greedy Algorithm) 简介</strong></p><p>贪心算法，又名贪婪法，是寻找<strong>最优解问题</strong>的常用方法，这种方法模式一般将求解过程分成<strong>若干个步骤</strong>，但每个步骤都应用贪心原则，选取当前状态下<strong>最好&#x2F;最优的选择</strong>（局部最有利的选择），并以此希望最后堆叠出的结果也是最好&#x2F;最优的解，但贪心算法得到的结果<strong>不一定</strong>是最优的结果。{看着这个名字，贪心，贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。}</p><p><strong>贪婪法的基本步骤：</strong></p><p>步骤1：从某个初始解出发；<br>步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；<br>步骤3：将所有解综合起来。</p></li><li><p><strong>最小生成树</strong>：</p><p>问题背景：给定7个村庄，现在要修路把7个村庄连通，各个村庄的距离用边线表示（也就是每条边的权），如何修路保证各个村庄都能连通，并且总的修建公路里程最短？</p><p><strong>prim算法</strong>：将n个点连通最少需要n-1条边，从任意一个点开始，把这个点加入一个集合中，找到集合中的所有点能连通的其他点的所有路，选择距离最短（权最小）的一条路，然后把这条路的终点加入到集合中，重复次过程直到集合中有n个点</p><p><strong>kruskal算法</strong>：先将所给的存在的能所有边按照权值从小到大的顺序进行排序放入一个集合中，依次从排序后的集合中取出一条边，判断这条边加入已修好路的集合中会不会产生回路，如果产生回路，则跳过这条边，从小到大的顺序选择下一条边，如果没有产生回路，则把这条边加入修路集合，直到修路集合中的边的条数为n-1</p><p>两种算法的区别是prim算法的修路集合中的点一定都是连通，因为是从已有的所有点中扩展出去的，但kruskal算法的修路集合中的点不一定都是连通的，因为是按照权值从小到大进行选择，两次选择的边可以没有相同顶点，所以不一定连通</p></li><li><p><strong>单调栈</strong></p><ul><li>单调递增栈：从<strong>栈底到栈顶</strong>，栈中的值单调递增</li><li>单调递减栈：从<strong>栈底到栈顶</strong>，栈中的值单调递减</li></ul><p>单调栈则主要用于解决<strong>NGE问题</strong>（Next Greater Element），也就是，对序列中每个元素，找到下一个比它大的元素。（当然，“下一个”可以换成“上一个”，“比它大”也可以换成“比他小”，原理不变。）</p><p>我们维护一个栈，表示“<strong>待确定NGE的元素</strong>”，然后遍历序列。当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的NGE，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p></li><li><p><strong>单调队列</strong></p><ul><li><strong>单调递增队列</strong>：保证队列头元素一定是当前队列的最小值，用于维护区间的最小值。</li><li><strong>单调递减队列</strong>：保证队列头元素一定是当前队列的最大值，用于维护区间的最大值。</li></ul><p>在说具体怎么实现一个单调队列之前，先来一个简单的例子，感受一下。</p><p>给定数列：<code>[3,1,5,7,4,2,1]</code> 现在要维护区间长度为 3 的最大值。（区间的下标从0开始）</p><table><thead><tr><th align="center">数列遍历到的位置</th><th align="center">操作</th><th align="center">队列中元素</th><th align="center">指定区间最大值</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">3入队</td><td align="center">3</td><td align="center">区间大小不符合</td></tr><tr><td align="center">1</td><td align="center">1入队</td><td align="center">3,1</td><td align="center">区间大小不符合</td></tr><tr><td align="center">2</td><td align="center">3,1出队，5入队</td><td align="center">5</td><td align="center">区间[0,2]的最大值为5</td></tr><tr><td align="center">3</td><td align="center">5出队，7入队</td><td align="center">7</td><td align="center">区间[1,3]的最大值为7</td></tr><tr><td align="center">4</td><td align="center">4入队</td><td align="center">7，4</td><td align="center">区间[2,4]的最大值为7</td></tr><tr><td align="center">5</td><td align="center">2入队</td><td align="center">7，4，2</td><td align="center">区间[3,5]的最大值为7</td></tr><tr><td align="center">6</td><td align="center">1入队，7出队</td><td align="center">4，2，1</td><td align="center">区间[4,6]的最大值为4</td></tr></tbody></table><p>可以发现队列中的元素都是单调递减的（不然也就不叫单调递减队列啦），同时既有入队列的操作、也有出队列的操作。</p><p>实现流程：</p><p>实现单调队列，主要分为三个部分：</p><ul><li><p><strong>去尾操作</strong> ：<strong>队尾元素出队列</strong>。当队列有新元素待入队，需要从队尾开始，删除影响队列单调性的元素，维护队列的单调性。(删除一个队尾元素后，就重新判断新的队尾元素)。<strong>去尾操作结束后，将该新元素入队列。</strong></p></li><li><p><strong>删头操作</strong> ：<strong>队头元素出队列</strong>。判断队头元素是否在待求解的区间之内，如果不在，就将其删除。（这个很好理解呀，因为单调队列的队头元素就是待求解区间的极值）</p></li><li><p><strong>取解操作</strong> ：经过上面两个操作，取出 <strong>队列的头元素</strong> ，就是 <strong>当前区间的极值</strong> 。</p></li></ul><hr><h5 id="去尾操作：队尾元素出队列"><a href="#去尾操作：队尾元素出队列" class="headerlink" title="去尾操作：队尾元素出队列"></a>去尾操作：队尾元素出队列</h5><p>假设需要维护一个 区间长度为 L 的 最大值，显然，我们需要一个 <strong>单调递减队列</strong>。</p><p>现在有一个新元素 new（下标为new_id）待放入队列，在新元素 new 入队列之前，需要先执行下面的操作：</p><ol><li>如果当前 <strong>队列为空</strong>，则 <strong>直接将new放入队列</strong> 。否则，执行下一步。</li><li>（假设队列的尾元素为rear)当前 <strong>队列不为空</strong> 。</li></ol><ul><li>如果rear&lt;new，则 <strong>尾元素rear出队列</strong>，直到 <strong>当前队列为空</strong> 或者 <strong>rear&lt;new不再满足</strong>。紧接着，元素new入队列。</li><li>如果rear&gt;&#x3D;new，直接将元素new放入队列。</li></ul><h5 id="删头操作：队头元素出队列"><a href="#删头操作：队头元素出队列" class="headerlink" title="删头操作：队头元素出队列"></a>删头操作：队头元素出队列</h5><p>将新元素new入队列之后，我们还需要判断当前队列中 <strong>队头元素</strong> 是否在 <strong>待求解的区间范围</strong> 内。</p><p>假设队列的头元素为front(序号为front_id)。如果此时当前 <strong>队列不为空</strong> ，且front_id&lt;new_id-L+1，那么将队列头元素front出队列。不断重复此过程，直至front_id&gt;&#x3D;new_id-L+1（也就是将队列中序号不在区间[new_id-L+1,new_id]的元素删除）</p><h5 id="取解操作"><a href="#取解操作" class="headerlink" title="取解操作"></a>取解操作</h5><p>经过上面的操作，此时 <strong>队列的头元素</strong>就是区间[new_id-L+1,new_id] 的最大值。</p></li><li><p><strong>动态规划</strong></p><p>动态规划特点<br>「分治」是算法中的一种基本思想，其通过将原问题分解为子问题，不断递归地将子问题分解为更小的子问题，并通过组合子问题的解来得到原问题的解。</p><p>类似于分治算法，「动态规划」也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有「重叠子问题」和「最优子结构」两大特性。</p><ul><li><p>重叠子问题<br>动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。</p><p>动态规划在第一次求解某子问题时，会将子问题的解保存；后续遇到重叠子问题时，则直接通过查表获取解，保证每个独立子问题只被计算一次，从而降低算法的时间复杂度。</p></li><li><p>最优子结构<br>如果一个问题的最优解可以由其子问题的最优解组合构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。</p><p>动态规划从基础问题的解开始，不断迭代组合、选择子问题的最优解，最终得到原问题最优解。</p></li></ul></li><li><p><strong>并查集</strong></p><ul><li>定义：</li></ul><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）</p><ul><li>主要构成：</li></ul><p>并查集主要由一个整型数组pre[ ]和两个函数find( )、join( )构成。<br>数组 pre[ ] 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。</p><ul><li>find( )函数的定义与实现：</li></ul><p>首先我们需要定义一个数组：int pre[1000]; （数组长度依题意而定）。这个数组记录了每个人的上级是谁。这些人从0或1开始编号（依题意而定）。比如说pre[16]&#x3D;6就表示16号的上级是6号。如果一个人的上级就是他自己，那说明他就是教主了，查找到此结束。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//查找x的教主</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(pre[x] != x)<span class="comment">//如果x的上级不是自己（则说明找到的人不是教主）</span></span><br><span class="line">x = pre[x];<span class="comment">//x继续找他的上级，直到找到教主为止</span></span><br><span class="line"><span class="keyword">return</span> x;<span class="comment">//教主驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>join( )函数的定义与实现</li></ul><p>join(x,y)的执行逻辑如下：<br>1、寻找 x 的代表元（即教主）；<br>2、寻找 y 的代表元（即教主）；<br>3、如果 x 和 y 不相等，则随便选一个人作为另一个人的上级，如此一来就完成了 x 和 y 的合并。<br>下面给出这个函数的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>                    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fx=find(x), fy=find(y);            </span><br><span class="line">    <span class="keyword">if</span>(fx != fy)                           </span><br><span class="line">        pre[fx]=fy;                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>路径压缩算法之一（优化find( )函数）</li></ul><p>所谓路径压缩，就是将一个集合中所有元素的上级都设为代表元，这样查找效率很高，我们可以通过递归的方法来逐层修改返回时的某个节点的直接前驱（即pre[x]的值）。简单说来就是将x到根节点路径上的所有点的pre（上级）都设为根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法存在一个缺陷：只有当查找了某个节点的代表元（教主）后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。</p><ul><li>路径压缩算法之二 <a href="https://blog.csdn.net/the_zed/article/details/105126583">加权标记法</a></li></ul><p>点链接看看即可，有上面那个优化基本上可以解决大多数题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    x=find(x);<span class="comment">//寻找 x的代表元</span></span><br><span class="line">    y=find(y);<span class="comment">//寻找 y的代表元</span></span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;<span class="comment">//如果 x 和 y 的代表元一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(rank[x]&gt;rank[y])&#123;</span><br><span class="line">        pre[y]=x;<span class="comment">//如果 x 的高度大于 y，则令 y 的上级为 x</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[x]&lt;rank[y])&#123;<span class="comment">//如果x的高度小于y，令x的上级为y</span></span><br><span class="line">        pre[x]=y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rank[y]++;  <span class="comment">//如果 x 的高度和 y 的高度相同，则令 y 的高度加1</span></span><br><span class="line">        pre[x]=y;   <span class="comment">//让 x 的上级为 y</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网计算-review</title>
      <link href="/2022/09/06/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-review/"/>
      <url>/2022/09/06/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-review/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（谢希仁第七版）"><a href="#计算机网络（谢希仁第七版）" class="headerlink" title="计算机网络（谢希仁第七版）"></a>计算机网络（谢希仁第七版）</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>下图是计算机网络体系结构的介绍</strong></p><p><img src="/2022/09/06/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-review/image-20220906173132226.png" alt="image-20220906173132226"></p><h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h2><h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h2><h3 id="3-1-二进制模2除法"><a href="#3-1-二进制模2除法" class="headerlink" title="3.1 二进制模2除法"></a>3.1 二进制模2除法</h3><p>规则：不向上借位，也不比较除数和被除数的相同位数值的大小，相当于相同位数的逻辑异或运算。因为除数的首位总是1，所以余数首位是1就商1，余数首位是0就商0。</p><p><img src="/2022/09/06/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-review/image-20220906224213394.png" alt="image-20220906224213394"></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/06/hello-world/"/>
      <url>/2022/09/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="一些命名规范"><a href="#一些命名规范" class="headerlink" title="一些命名规范"></a>一些命名规范</h2><table><thead><tr><th>项目命名</th><th>全部<strong>以小写字母命名，以中划线分割</strong>。如<em>my-project</em>。</th></tr></thead><tbody><tr><td>目录命名</td><td>小写字母加下划线，如lib_tomcat。</td></tr></tbody></table><h2 id="个人备份习惯"><a href="#个人备份习惯" class="headerlink" title="个人备份习惯"></a>个人备份习惯</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Backup&quot;</span></span><br><span class="line">git push</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>目前假设本地Hexo博客基础环境已经搭好：比如安装git<br>、nodejs、hexo安装…</p><h3 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h3><p>输入下列命令克隆博客必须文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/muzihuaner/hexo.git</span><br><span class="line">//https://gitee.com/muzihuaner/hexo.git换成你的</span><br></pre></td></tr></table></figure><h3 id="恢复博客-1"><a href="#恢复博客-1" class="headerlink" title="恢复博客"></a>恢复博客</h3><p>在clone下来的那个文件夹里面执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p><strong>在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。</strong></p><p>然后就完成了，你如果想也可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
