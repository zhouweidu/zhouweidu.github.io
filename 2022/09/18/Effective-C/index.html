<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouweidu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="条款01:  视C++ 为一个语言联邦 条款02: 尽量以 const, enum, inline 替换 #define">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="https://zhouweidu.github.io/2022/09/18/Effective-C/index.html">
<meta property="og:site_name" content="Irony&#39;s blog">
<meta property="og:description" content="条款01:  视C++ 为一个语言联邦 条款02: 尽量以 const, enum, inline 替换 #define">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhouweidu.github.io/2022/09/18/Effective-C/image-20220918165735085.png">
<meta property="og:image" content="https://zhouweidu.github.io/2022/09/18/Effective-C/image-20220918195311593.png">
<meta property="og:image" content="https://zhouweidu.github.io/2022/09/18/Effective-C/image-20220918213759699.png">
<meta property="og:image" content="https://zhouweidu.github.io/2022/09/18/Effective-C/image-20220918214019413.png">
<meta property="article:published_time" content="2022-09-18T07:54:01.000Z">
<meta property="article:modified_time" content="2022-09-21T06:52:21.915Z">
<meta property="article:author" content="Irony">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhouweidu.github.io/2022/09/18/Effective-C/image-20220918165735085.png">

<link rel="canonical" href="https://zhouweidu.github.io/2022/09/18/Effective-C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Effective C++ | Irony's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Irony's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Maker & Developer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhouweidu.github.io/2022/09/18/Effective-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Irony">
      <meta itemprop="description" content="This is a blog in order to record my learning and growth.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Irony's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Effective C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 15:54:01" itemprop="dateCreated datePublished" datetime="2022-09-18T15:54:01+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 14:52:21" itemprop="dateModified" datetime="2022-09-21T14:52:21+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">个人技术栈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01:  视C++ 为一个语言联邦"></a>条款01:  视C++ 为一个语言联邦</h2><p><img src="/2022/09/18/Effective-C/image-20220918165735085.png" alt="image-20220918165735085"></p>
<h2 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02: 尽量以 const, enum, inline 替换 #define"></a>条款02: 尽量以 const, enum, inline 替换 #define</h2><span id="more"></span>

<h2 id="条款03-尽可能使用-const"><a href="#条款03-尽可能使用-const" class="headerlink" title="条款03: 尽可能使用 const"></a>条款03: 尽可能使用 const</h2><ul>
<li><p>将某些东西声明为 const 可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。 </p>
</li>
<li><p>编译器强制实施 bitwise constness ，但你编写程序时应该使用”概念上的常量性” (conceptual constness) </p>
</li>
<li><p>当 const  non-const 成员函数有着实质等价的实现时，令 non-const 版本调 const 版本可避免代码重复。</p>
</li>
</ul>
<h2 id="条款-04-确定对象被使用前已先被初始化"><a href="#条款-04-确定对象被使用前已先被初始化" class="headerlink" title="条款 04: 确定对象被使用前已先被初始化"></a>条款 04: 确定对象被使用前已先被初始化</h2><ul>
<li>为内置型对象进行手工初始化，因为 C++不保证初始化它们。 </li>
<li>构造函数最好使用成员初值列 (member initialization list) ，而不要在构造函数 本体内使用赋值操作(assignment) 。初值列列出的成员变量，其排列次序应该 和它们在 class 中的声明次序相同。 </li>
<li>为免除”跨编译单元之初始化次序”问题，请以local static 对象（函数内的static对象）替换 non-local static 对象</li>
</ul>
<h2 id="条款-05-了解-C-默默编写并调用哪些函数"><a href="#条款-05-了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 05: 了解 C++ 默默编写并调用哪些函数"></a>条款 05: 了解 C++ 默默编写并调用哪些函数</h2><p>编译器可以暗自为 class 创建 default 构造函数、 copy 构造函数、 copy assignment 操作符，以及析构函数。</p>
<h2 id="条款-06-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06: 若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06: 若不想使用编译器自动生成的函数，就该明确拒绝</h2><h2 id="条款-07-为多态基类声明-virtual-析构函数"><a href="#条款-07-为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07: 为多态基类声明 virtual 析构函数"></a>条款 07: 为多态基类声明 virtual 析构函数</h2><ul>
<li>polymorphic (带多态性质的) base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。 </li>
<li>Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性 (polymorphically) ，就不该声明 virtual 析构函数。（会多出虚函数指针的空间）</li>
</ul>
<h2 id="条款-08-别让异常逃离析构函数"><a href="#条款-08-别让异常逃离析构函数" class="headerlink" title="条款 08: 别让异常逃离析构函数"></a>条款 08: 别让异常逃离析构函数</h2><ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提 供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
<h2 id="条款-09-绝不在构造和析构过程中调用-virtual-函数"><a href="#条款-09-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款 09: 绝不在构造和析构过程中调用 virtual 函数"></a>条款 09: 绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class (比起当前执行构造函数和析构函数的那层)。</p>
<h2 id="条款-10-令operator-x3D-返回一个-reference-to-this"><a href="#条款-10-令operator-x3D-返回一个-reference-to-this" class="headerlink" title="条款 10: 令operator&#x3D; 返回一个 reference to *this"></a>条款 10: 令operator&#x3D; 返回一个 reference to *this</h2><h2 id="条款-11-在operator-x3D-中处理”自我赋值”"><a href="#条款-11-在operator-x3D-中处理”自我赋值”" class="headerlink" title="条款 11: 在operator&#x3D; 中处理”自我赋值”"></a>条款 11: 在operator&#x3D; 中处理”自我赋值”</h2><p><strong>copy and swap 技术</strong></p>
<p><img src="/2022/09/18/Effective-C/image-20220918195311593.png" alt="image-20220918195311593"></p>
<h2 id="条款-12-复制对象时勿忘其每一个成分"><a href="#条款-12-复制对象时勿忘其每一个成分" class="headerlink" title="条款 12: 复制对象时勿忘其每一个成分"></a>条款 12: 复制对象时勿忘其每一个成分</h2><ul>
<li>Copying 函数应该确保复制”对象内的所有成员变量”及”所有 base class 成分”。</li>
<li>不要尝试以某个 copying 函数实现另一个 copying 函数。应该将共同机能放进第三个函数中，并由两个 coping 函数共同调用。</li>
</ul>
<h2 id="条款-13-以对象管理资源"><a href="#条款-13-以对象管理资源" class="headerlink" title="条款 13: 以对象管理资源"></a>条款 13: 以对象管理资源</h2><h2 id="条款-14-在资源管理类中小心coping-行为"><a href="#条款-14-在资源管理类中小心coping-行为" class="headerlink" title="条款 14: 在资源管理类中小心coping 行为"></a>条款 14: 在资源管理类中小心coping 行为</h2><h2 id="条款-15-在资源管理类中提供对原始资源的访问"><a href="#条款-15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15: 在资源管理类中提供对原始资源的访问"></a>条款 15: 在资源管理类中提供对原始资源的访问</h2><h2 id="条款-16-成对使用-new-delete-时要采取相同形式"><a href="#条款-16-成对使用-new-delete-时要采取相同形式" class="headerlink" title="条款 16: 成对使用 new delete 时要采取相同形式"></a>条款 16: 成对使用 new delete 时要采取相同形式</h2><h2 id="条款-17-以独立语句将-new-创建的对象置入智能指针"><a href="#条款-17-以独立语句将-new-创建的对象置入智能指针" class="headerlink" title="条款 17: 以独立语句将 new 创建的对象置入智能指针"></a>条款 17: 以独立语句将 new 创建的对象置入智能指针</h2><p>以独立语句将 new 创建的对象存储于(置入)智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏</p>
<h2 id="条款-18-让接口容易被正确使用，不易被误用"><a href="#条款-18-让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18: 让接口容易被正确使用，不易被误用"></a>条款 18: 让接口容易被正确使用，不易被误用</h2><h2 id="条款-19-设计-class-犹如设计-type"><a href="#条款-19-设计-class-犹如设计-type" class="headerlink" title="条款 19: 设计 class 犹如设计 type"></a>条款 19: 设计 class 犹如设计 type</h2><h2 id="条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款-20-宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款 20: 宁以 pass-by -reference-to-const 替换 pass-by-value"></a>条款 20: 宁以 pass-by -reference-to-const 替换 pass-by-value</h2><ul>
<li>尽量以 pass-by-reference-to-const 替换 pass-by-value 前者通常比较高效，并可避免切割问题 (slicing problem) </li>
<li>以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言， pass-by-value 往往比较适当。</li>
</ul>
<h2 id="条款-21-必须返回对象时，别妄想返回其-reference"><a href="#条款-21-必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21: 必须返回对象时，别妄想返回其 reference"></a>条款 21: 必须返回对象时，别妄想返回其 reference</h2><h2 id="条款-22-将成员变量声明为private（封装）"><a href="#条款-22-将成员变量声明为private（封装）" class="headerlink" title="条款 22: 将成员变量声明为private（封装）"></a>条款 22: 将成员变量声明为private（封装）</h2><h2 id="条款-23-宁以-non-member-non-friend-替换-member-函数"><a href="#条款-23-宁以-non-member-non-friend-替换-member-函数" class="headerlink" title="条款 23: 宁以 non-member non- friend 替换 member 函数"></a>条款 23: 宁以 non-member non- friend 替换 member 函数</h2><p>宁可拿 non-member non- friend 函数替换 member 函数。这样做可以增加封装性、包裹弹性 (packaging flexibility )和机能扩充性。</p>
<h2 id="条款-24-若所育参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款-24-若所育参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款 24 :若所育参数皆需类型转换，请为此采用 non-member 函数"></a>条款 24 :若所育参数皆需类型转换，请为此采用 non-member 函数</h2><h2 id="条款-25-考虑写出一个不抛异常的-swap-函数"><a href="#条款-25-考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25: 考虑写出一个不抛异常的 swap 函数"></a>条款 25: 考虑写出一个不抛异常的 swap 函数</h2><p>普通class写法如下：</p>
<p><img src="/2022/09/18/Effective-C/image-20220918213759699.png" alt="image-20220918213759699"></p>
<p>template class写法如下：</p>
<p><img src="/2022/09/18/Effective-C/image-20220918214019413.png" alt="image-20220918214019413"></p>
<ul>
<li>std: :swap 对你的类型效率不高时，提供一个swap 成员函数，并确定这个函数 不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap 用来调用前者。对 classes (而非 templates) ，也请特化 std: :swap。</li>
<li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何”命 名空间资格修饰”。</li>
<li>为”用户定义类型”进行std templates 全特化是好的，但千万不要尝试在std 内加 入某些对 std 而言全新的东西。</li>
</ul>
<h2 id="条款-26-尽可能延后变量定义式的出现时间"><a href="#条款-26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26: 尽可能延后变量定义式的出现时间"></a>条款 26: 尽可能延后变量定义式的出现时间</h2><h2 id="条款-27-尽量少做转型动作"><a href="#条款-27-尽量少做转型动作" class="headerlink" title="条款 27: 尽量少做转型动作"></a>条款 27: 尽量少做转型动作</h2><h2 id="条款-28-避免返回-handles-指向对象内部成分"><a href="#条款-28-避免返回-handles-指向对象内部成分" class="headerlink" title="条款 28: 避免返回 handles 指向对象内部成分"></a>条款 28: 避免返回 handles 指向对象内部成分</h2><p>避免返回 handles (包括 references 、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const ，并将发生”虚吊号码牌” (dangling handles) 的可能性降至最低。</p>
<h2 id="条款-29-为”异常安全”而努力是值得的"><a href="#条款-29-为”异常安全”而努力是值得的" class="headerlink" title="条款 29: 为”异常安全”而努力是值得的"></a>条款 29: 为”异常安全”而努力是值得的</h2><ul>
<li>异常安全函数 (Exception-safe functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以 copy-and-swap 实现出来，但”强烈保证”并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的”异常安全保证”通常最高只等于其所调用之各个函数的”异常安全保证”中的最弱者</li>
</ul>
<h2 id="条款-30-透彻了解-inlining-的里里外外"><a href="#条款-30-透彻了解-inlining-的里里外外" class="headerlink" title="条款 30: 透彻了解 inlining 的里里外外"></a>条款 30: 透彻了解 inlining 的里里外外</h2><ul>
<li>将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 (binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为 function templates 出现在头文件，就将它们声明为 inline。</li>
</ul>
<h2 id="条款-31-将文件间的编译依存关系降至最低（解耦合）"><a href="#条款-31-将文件间的编译依存关系降至最低（解耦合）" class="headerlink" title="条款 31: 将文件间的编译依存关系降至最低（解耦合）"></a>条款 31: 将文件间的编译依存关系降至最低（解耦合）</h2><h2 id="条款-32-确定你的-public-继承塑模出-is-a-关系"><a href="#条款-32-确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款 32: 确定你的 public 继承塑模出 is-a 关系"></a>条款 32: 确定你的 public 继承塑模出 is-a 关系</h2><h2 id="条款-33-避免遮掩继承而来的名称"><a href="#条款-33-避免遮掩继承而来的名称" class="headerlink" title="条款 33: 避免遮掩继承而来的名称"></a>条款 33: 避免遮掩继承而来的名称</h2><ul>
<li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有 人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或转变函数(forwarding functions)</li>
</ul>
<h2 id="条款-34-区分接口继承和实现继承"><a href="#条款-34-区分接口继承和实现继承" class="headerlink" title="条款 34: 区分接口继承和实现继承"></a>条款 34: 区分接口继承和实现继承</h2><ul>
<li>接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。</li>
<li>virtual 函数只具体指定接口继承。</li>
<li>简朴的(非纯) impure virtual 函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h2 id="条款-35-考虑-virtual-函数以外的其他选择（涉及到设计模式）"><a href="#条款-35-考虑-virtual-函数以外的其他选择（涉及到设计模式）" class="headerlink" title="条款 35: 考虑 virtual 函数以外的其他选择（涉及到设计模式）"></a>条款 35: 考虑 virtual 函数以外的其他选择（涉及到设计模式）</h2><ul>
<li>virtual 函数的替代方案包括 NYl 手法及 Strategy 设计模式的多种形式。 NYI 手法（non-virtual interface) ）自身是一个特殊形式的 Template Method 设计模式。</li>
<li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访 class non-public 成员。 </li>
<li>trl::function 对象的行为就像一般函数指针。这样的对象可接纳”与给定之目标签名式 (target signature) 兼容”的所有可调用物 (callable entities)</li>
</ul>
<h2 id="条款-36-绝不重新定义继承而来的-non-virtual-函数"><a href="#条款-36-绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款 36: 绝不重新定义继承而来的 non-virtual 函数"></a>条款 36: 绝不重新定义继承而来的 non-virtual 函数</h2><h2 id="条款-37-绝不重新定义继承而来的缺省参数值"><a href="#条款-37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37: 绝不重新定义继承而来的缺省参数值"></a>条款 37: 绝不重新定义继承而来的缺省参数值</h2><p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数一一你唯一应该覆写的东西一一却是动态绑定。</p>
<h2 id="关于私有虚函数的相关问题"><a href="#关于私有虚函数的相关问题" class="headerlink" title="关于私有虚函数的相关问题"></a>关于私有虚函数的相关问题</h2><ol>
<li>编译器不检查虚函数的各类属性。</li>
<li>编译器在编译子类成员函数时，会先查询父类，如果存在非虚函数，则隐藏父类函数。如果存在虚函数，则重写该位置的虚函数。此时你又可以赋予该函数在该类中的各种属性（例如public）。</li>
<li>私有只是让子类不能访问父类，仅此而已，对其他规则没限制，也就是说可以重写（覆盖）。</li>
</ol>
<h2 id="条款-38-通过复合塑模出-has-a-或”根据某物实现出”"><a href="#条款-38-通过复合塑模出-has-a-或”根据某物实现出”" class="headerlink" title="条款 38: 通过复合塑模出 has-a 或”根据某物实现出”"></a>条款 38: 通过复合塑模出 has-a 或”根据某物实现出”</h2><ul>
<li>复合(composition，也称为聚合) 的意义和 public 继承完全不同。</li>
<li>在应用域 (application domain) ，复含意味 has-a (有一个)。在实现域 (implementation domain) ，复合意味is-implemented-in-terms-of(根据某物实现出)。</li>
</ul>
<h2 id="条款-39-明智而审慎地使用-private-继承"><a href="#条款-39-明智而审慎地使用-private-继承" class="headerlink" title="条款 39: 明智而审慎地使用 private 继承"></a>条款 39: 明智而审慎地使用 private 继承</h2><ul>
<li>尽可能使用public继承加复合，必要时才使用 private 继承</li>
<li>Private 继承意味 is-implemented-in-terms of (根据某物实现出)。它通常比复合 (composition) 的级别低。但是当 derived class 需要访问 prot ted base class 成员，或需要重新定义继承而来的virtual 函数时，这么设计是合理的。</li>
<li>和复合(composition) 不同， private 继承可以造成 empty base 最优化。这对致 力于”对象只寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
<h2 id="条款-40-明智而审慎地使用多重继承"><a href="#条款-40-明智而审慎地使用多重继承" class="headerlink" title="条款 40: 明智而审慎地使用多重继承"></a>条款 40: 明智而审慎地使用多重继承</h2><ul>
<li><strong>C++ 用来解析 (resolving) 重载函数调用的规则</strong>：看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。 找出最佳匹配函数后才检验其可取用性。</li>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li>
<li>virtual 继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及”public 继承某个 Interface class”和 “private 继承某个协助实现的class” 的两相组合。</li>
</ul>
<h2 id="条款-41-了解隐式接口和编译期多态"><a href="#条款-41-了解隐式接口和编译期多态" class="headerlink" title="条款 41: 了解隐式接口和编译期多态"></a>条款 41: 了解隐式接口和编译期多态</h2><ul>
<li>classes templates 都支持接口(interfaces) 和多态 (polymorphism)</li>
<li>对 classes 而言接口是显式的 (explicit) .以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li>
<li>对 template 参数而言，接口是隐式的(implicit) .奠基于有效表达式。多态则是通过 template 具现化和函数重载解析( function overloading resolution) 发生于编译期</li>
</ul>
<h2 id="条款-42-了解-typename-的双重意义"><a href="#条款-42-了解-typename-的双重意义" class="headerlink" title="条款 42: 了解 typename 的双重意义"></a>条款 42: 了解 typename 的双重意义</h2><ul>
<li>声明 template 参数时，前缀关键字class typenarne可互换。</li>
<li>请使用关键字typenarne标识嵌套从属类型名称:但不得在base class lists (基类列，继承时出现在<code>:</code>后面的基类列表）或 member initialization list (成员初始化列表）内以它作为 base class 修饰符。</li>
</ul>
<h2 id="条款-43-学习处理模板化基类内的名称"><a href="#条款-43-学习处理模板化基类内的名称" class="headerlink" title="条款 43: 学习处理模板化基类内的名称"></a>条款 43: 学习处理模板化基类内的名称</h2><p>可在 derived class templates 内通过” this-&gt;” 指涉 base class templates 内的成员 名称，或藉由一个明白写出的 “base class 资格修饰符”完成，前一种方法更好，如果调用的是虚函数后一种方法丢失了多态性</p>
<h2 id="条款-44-将与参数无关的代码抽离templates"><a href="#条款-44-将与参数无关的代码抽离templates" class="headerlink" title="条款 44: 将与参数无关的代码抽离templates"></a>条款 44: 将与参数无关的代码抽离templates</h2><h2 id="条款-45-运用成员函数模板接受所有兼容类型"><a href="#条款-45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45: 运用成员函数模板接受所有兼容类型"></a>条款 45: 运用成员函数模板接受所有兼容类型</h2><ul>
<li>请使用 member function templates (成员函数模板）生成”可接受所有兼容类型”的函数。</li>
<li>如果你声明 member templates 用于”泛化 copy 构造”或”泛化 assignment操作” 你还是需要声明正常的copy构造函数和 copy assignment 操作符。</li>
</ul>
<h2 id="条款-46-需要类型转换时请为模板定义非成员函数"><a href="#条款-46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46: 需要类型转换时请为模板定义非成员函数"></a>条款 46: 需要类型转换时请为模板定义非成员函数</h2><p>当我们编写一个 class template，而它所提供之”与此 template 相关的”函数支持”所有参数之隐式类型转换”时，请将那些函数定义为” class template 内部的friend 函数”。</p>
<h2 id="条款-47-请使用-traits-classes-表现类型信息（个人感觉有点像反射）"><a href="#条款-47-请使用-traits-classes-表现类型信息（个人感觉有点像反射）" class="headerlink" title="条款 47: 请使用 traits classes 表现类型信息（个人感觉有点像反射）"></a>条款 47: 请使用 traits classes 表现类型信息（个人感觉有点像反射）</h2><ul>
<li>Traits classes 使得”类型相关信息”在编译期可用。它们以templates 和 “templates 特化”完成实现。</li>
<li>整合重载技术(overloading) 后， traits classes 有可能在编译期对类型执行 if…else 测试。</li>
</ul>
<h2 id="条款-48-认识-template-元编程"><a href="#条款-48-认识-template-元编程" class="headerlink" title="条款 48: 认识 template 元编程"></a>条款 48: 认识 template 元编程</h2><ul>
<li>Template metaprogramming (TMP，模板元编程)可将工作由运行期移往编译期， 因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP 可被用来生成”基于政策选择组合” (based on combinations of policy choices) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
<h2 id="条款-49-了解new-handler的行为"><a href="#条款-49-了解new-handler的行为" class="headerlink" title="条款 49:了解new-handler的行为"></a>条款 49:了解new-handler的行为</h2><h2 id="条款-50-了解-new-和-delete-的合理替换时机"><a href="#条款-50-了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50: 了解 new 和 delete 的合理替换时机"></a>条款 50: 了解 new 和 delete 的合理替换时机</h2><h2 id="条款-51-编写-new-delete-时需固守常规"><a href="#条款-51-编写-new-delete-时需固守常规" class="headerlink" title="条款 51: 编写 new delete 时需固守常规"></a>条款 51: 编写 new delete 时需固守常规</h2><h2 id="条款-52-写了-placement-new-也要写-placement-delete"><a href="#条款-52-写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52: 写了 placement new 也要写 placement delete"></a>条款 52: 写了 placement new 也要写 placement delete</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/13/c-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="prev" title="c++高级程序设计">
      <i class="fa fa-chevron-left"></i> c++高级程序设计
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%B7%A6%E7%A8%8B%E4%BA%91%EF%BC%89/" rel="next" title="算法与数据结构（左程云）">
      算法与数据结构（左程云） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE01-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-text">条款01:  视C++ 为一个语言联邦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5-const-enum-inline-%E6%9B%BF%E6%8D%A2-define"><span class="nav-text">条款02: 尽量以 const, enum, inline 替换 #define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><span class="nav-text">条款03: 尽可能使用 const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">条款 04: 确定对象被使用前已先被初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-05-%E4%BA%86%E8%A7%A3-C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-text">条款 05: 了解 C++ 默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-06-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="nav-text">条款 06: 若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-07-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款 07: 为多态基类声明 virtual 析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-08-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款 08: 别让异常逃离析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-09-%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0"><span class="nav-text">条款 09: 绝不在构造和析构过程中调用 virtual 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-10-%E4%BB%A4operator-x3D-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="nav-text">条款 10: 令operator&#x3D; 返回一个 reference to *this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-11-%E5%9C%A8operator-x3D-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9D%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="nav-text">条款 11: 在operator&#x3D; 中处理”自我赋值”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="nav-text">条款 12: 复制对象时勿忘其每一个成分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-13-%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-text">条款 13: 以对象管理资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83coping-%E8%A1%8C%E4%B8%BA"><span class="nav-text">条款 14: 在资源管理类中小心coping 行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">条款 15: 在资源管理类中提供对原始资源的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-delete-%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="nav-text">条款 16: 成对使用 new delete 时要采取相同形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-new-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">条款 17: 以独立语句将 new 创建的对象置入智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="nav-text">条款 18: 让接口容易被正确使用，不易被误用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-19-%E8%AE%BE%E8%AE%A1-class-%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1-type"><span class="nav-text">条款 19: 设计 class 犹如设计 type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-20-%E5%AE%81%E4%BB%A5-pass-by-reference-to-const-%E6%9B%BF%E6%8D%A2-pass-by-value"><span class="nav-text">条款 20: 宁以 pass-by -reference-to-const 替换 pass-by-value</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><span class="nav-text">条款 21: 必须返回对象时，别妄想返回其 reference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate%EF%BC%88%E5%B0%81%E8%A3%85%EF%BC%89"><span class="nav-text">条款 22: 将成员变量声明为private（封装）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-23-%E5%AE%81%E4%BB%A5-non-member-non-friend-%E6%9B%BF%E6%8D%A2-member-%E5%87%BD%E6%95%B0"><span class="nav-text">条款 23: 宁以 non-member non- friend 替换 member 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-24-%E8%8B%A5%E6%89%80%E8%82%B2%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><span class="nav-text">条款 24 :若所育参数皆需类型转换，请为此采用 non-member 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="nav-text">条款 25: 考虑写出一个不抛异常的 swap 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="nav-text">条款 26: 尽可能延后变量定义式的出现时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-27-%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="nav-text">条款 27: 尽量少做转型动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E-handles-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="nav-text">条款 28: 避免返回 handles 指向对象内部成分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-29-%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="nav-text">条款 29: 为”异常安全”而努力是值得的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3-inlining-%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="nav-text">条款 30: 透彻了解 inlining 的里里外外</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E%EF%BC%88%E8%A7%A3%E8%80%A6%E5%90%88%EF%BC%89"><span class="nav-text">条款 31: 将文件间的编译依存关系降至最低（解耦合）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="nav-text">条款 32: 确定你的 public 继承塑模出 is-a 关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">条款 33: 避免遮掩继承而来的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-text">条款 34: 区分接口继承和实现继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-35-%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9%EF%BC%88%E6%B6%89%E5%8F%8A%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">条款 35: 考虑 virtual 函数以外的其他选择（涉及到设计模式）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="nav-text">条款 36: 绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-text">条款 37: 绝不重新定义继承而来的缺省参数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%A7%81%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-text">关于私有虚函数的相关问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-38-%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96%E2%80%9D%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="nav-text">条款 38: 通过复合塑模出 has-a 或”根据某物实现出”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="nav-text">条款 39: 明智而审慎地使用 private 继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text">条款 40: 明智而审慎地使用多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="nav-text">条款 41: 了解隐式接口和编译期多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-42-%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="nav-text">条款 42: 了解 typename 的双重意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">条款 43: 学习处理模板化基类内的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates"><span class="nav-text">条款 44: 将与参数无关的代码抽离templates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text">条款 45: 运用成员函数模板接受所有兼容类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">条款 46: 需要类型转换时请为模板定义非成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-47-%E8%AF%B7%E4%BD%BF%E7%94%A8-traits-classes-%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88%E4%B8%AA%E4%BA%BA%E6%84%9F%E8%A7%89%E6%9C%89%E7%82%B9%E5%83%8F%E5%8F%8D%E5%B0%84%EF%BC%89"><span class="nav-text">条款 47: 请使用 traits classes 表现类型信息（个人感觉有点像反射）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-48-%E8%AE%A4%E8%AF%86-template-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-text">条款 48: 认识 template 元编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">条款 49:了解new-handler的行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-50-%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="nav-text">条款 50: 了解 new 和 delete 的合理替换时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-51-%E7%BC%96%E5%86%99-new-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="nav-text">条款 51: 编写 new delete 时需固守常规</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE-52-%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete"><span class="nav-text">条款 52: 写了 placement new 也要写 placement delete</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Irony</p>
  <div class="site-description" itemprop="description">This is a blog in order to record my learning and growth.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Irony</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
